<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Глава 3. Прикладной протокол HTTP</title>

    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <link rel="stylesheet" href="../modules/vs2015.min.css">
    <script src='../modules/jquery-3.7.1.min.js'></script>
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


</head>
<body>
<script src="../common/counters_body.js"></script>

<h1>Глава 3. Прикладной протокол HTTP</h1>
<h2>История HTTP</h2>
<p>В начале 90-х на свет появилось главное приложение Интернета - Всемирная паутина. Одна из возможных причин, почему Всемирная паутина привлекла пользователей — это то, что принцип ее функционирования — работа по запросу.</p>


<h2>Определение протокола HTTP</h2>
<p><b>HTTP</b> (<i>HyperText Transfer Protocol</i>) (протокол передачи гипертекста) — сетевой протокол прикладного уровня, который изначально предназначался для получения с серверов гипертекстовых документов в формате HTML, а с течением времени стал универсальным средством взаимодействия между узлами как Всемирной паутины, так и изолированных веб-инфраструктур. Определение по основным документациям: <b>HTTP</b> — протокол уровня приложений для распределённых, объединённых, гипермедийных информационных систем, используемый в глобальной информационной инициативе Всемирной паутины с 1990 года.</p>
<p>HTTP реализуется в двух частях приложений: <i>клиентской</i> и <i>серверной</i>. Клиентская и серверная части программ, исполняемые на различных конечных системах, общаются друг с другом, обмениваясь сообщениями HTTP. Протокол HTTP определяет структуру этих сообщений и порядок обмена между клиентом и сервером. Если конкретнее, HTTP определяет порядок того, как веб-клиенты запрашивают веб-страницы с веб-сервера и как сервер передает эти страницы клиентам.</p>
<h2>Терминологические пояснения по WWW</h2>
<p>Перед тем как детально объяснить HTTP, сделаем краткий обзор терминологии Всемирной паутины.</p>
<p><b>Веб-страница</b> (веб-документ) состоит из объектов.</p>
<p><b>Объект</b> - это простой файл, имеющий уникальный URL-адрес, например файл формата HTML, изображение в формате JPEG, Java-апплет или видеоклип.</p>
<p>Большинство веб-страниц состоит из <b>базового HTML-файла</b>, который содержит ссылки на несколько объектов. Например, если веб-страница содержит HTML-текст и пять рисунков в формате JPEG, это значит, что веб-страница содержит шесть объектов: <i>базовый файл</i> плюс пять изображений.</p>
<p>Базовый файл содержит в себе ссылки на другие объекты, в виде их URL-адресов, находящихся в тексте базового файла. Каждый <b>URL-адрес</b> состоит из двух частей: <b>имени сервера</b>, содержащего объект и пути до этого объекта.</p>
<p> Например, URL-адрес <span class="code">http://www.someSchool.edu/someDepartment/picture.gif</span> содержит адрес хоста <span class="code">www.someSchool.edu</span> и имя пути <span class="code">/someDepartment/picture.gif</span>.</p>

<h2>Кратко о HTTP</h2>
<p>Мы будем использовать <i>слова браузер и клиент как взаимозаменяемые</i>, так как веб-браузеры реализуют клиентскую сторону протокола HTTP. Веб-серверы, реализующие серверную сторону HTTP, содержат веб-объекты, на которые указывают ссылки.</p>
<p><b>Когда пользователь запрашивает веб-страницу</b> (например, щелкает по гиперссылке), браузер отправляет HTTP-запрос объектов этой страницы серверу. Сервер получает запрос и отвечает сообщением HTTP, которое содержит объекты.</p>
<p>HTTP использует TCP в качестве базового транспортного протокола. Простой порядок взаимодействия:</p>
<ol>
    <li>HTTP-клиент инициирует TCP-соединение с сервером</li>
    <li>Когда соединение установлено, процессы браузера и сервера получают доступ к TCP через свои сокеты (дверью между клиентским процессом и TCP-соединением)</li>
    <li>HTTP-сервер принимает запрос и отсылает ответное сообщение, используя свой сокет</li>
</ol>
<p>Передача по протоколу TCP <i>надежна</i>, а это означает, что <b>каждый HTTP-запрос, посланный клиентским процессом, обязательно прибудет к серверу, и наоборот, каждый HTTP-ответ, посланный сервером, обязательно будет получен клиентом</b>. Поэтому нам не нужно заботиться о потере данных, т.к. это все работа протокола TCP и протоколов уровней стека более низкого уровня. </p>
<img src="images/http-request-response.png" alt="">
<p>Важно отметить, что сервер отправляет запрошенные файлы клиенту, не сохраняя какой-либо информации о клиенте. Если один и тот же клиент запросит один и тот же файл дважды, то HTTP-сервер отправит его еще раз, забыв, что он только что это делал. Таким образом, <b>HTTP-сервер не обрабатывает информации о клиенте</b>, поэтому говорят, что HTTP - это <b>протокол без сохранения состояния</b>.</p>
<h2>(Не)постоянные соединения</h2>
<p>HTTP-сервер должен отвечать на массу запросов посылаемых клиентом. Когда взаимодействие происходит через TCP, то разработчик приложения должен принять решение о том, как отправлять каждую пару запрос-ответ - через <i>отдельное</i> или через <i>одно и то же</i> TCP-соединение.</p>
<ul>
    <li><b>Непостоянное соединение</b>: запрос-ответы посылаются каждый отдельно через собственные соединения</li>
    <li><span data-tooltip="HTTP по умолчанию использует постоянное HTTP-соединение"><b>Постоянное соединение</b></span>: запрос-ответы посылаются через одно постоянное соединение</li>
</ul>

<h3>Непостоянные HTTP-соединения</h3>
<p>Рассмотрим этапы передачи веб-страницы в случае непостоянного соединения. Предположим, что страница состоит из базового HTML-файла и десяти изображений в формате JPEG и все эти 11 объектов находятся на одном сервере. Пусть URL-адрес для базового HTML-файла имеет вид: <span class="code">http://www.someSchool.edu/someDepartment/home.index</span>
</p>
<p>Вот что происходит:</p>
<ol>
    <li>HTTP-клиент инициирует TCP-соединение с сервером <span class="code">www.someSchool.edu</span> по порту <span class="code">80</span> (<b>порт по умолчанию для HTTP</b>). Этому TCP-соединению выделяются сокеты на клиентской и серверной стороне.</li>
    <li>HTTP-клиент отправляет запрос серверу через свой сокет. Запрос включает путь к базовому файлу <span class="code">/someDepartment/home.index</span>.</li>
    <li>Процесс HTTP-сервера получает запрос через свой сокет, извлекает объект <span class="code">/someDepartment/home.index</span> из своего места хранения (оперативной памяти или диска), помещает объект в ответное HTTP-сообщение и отправляет клиенту через свой сокет.</li>
    <li>Процесс HTTP-сервера дает команду протоколу TCP закрыть соединение, когда сервер получит сообщение об успехе передачи.</li>
    <li>HTTP-клиент получает ответ от сервера, и TCP-соединение разрывается. Сообщение указывает, что полученный объект — это HTML-файл. Клиент извлекает файл из сообщения, обрабатывает его и находит ссылки на 10 объектов (файлов в формате JPEG).</li>
    <li>Шаги с первого по четвертый повторяются для каждого из десяти JPEG-объектов.</li>
</ol>
<p>Заметим, что спецификация протокола HTTP определяет только протокол взаимодействия между программой клиента и программой сервера, но ничего не говорит о том, как веб-страница должна интерпретироваться клиентом, поэтому могут существовать разночтения от браузера к браузеру. </p>
<p>Таким образом, непостоянное HTTP-соединение - это соединение, при котором TCP-соединение передает ровно одно сообщение запрос и одно сообщение ответ. В примере выше было установлено ровно 11 TCP-соединений.</p>
<p>Тут намеренно не уточнялось получил ли клиент 10 изобраажений серией из 10 последовательных TCP-соединений, или параллельно. Большинство современных веб-браузеров в режиме по умолчанию открывают 5-10 параллельных TCP-соединений, и каждый обрабатывается параллельно. Если установить ограничение на 1 одновременное TCP-соединение, то мы получим простой случай очереди TCP-соединений. </p>
<h4>Оценка интервала времени непостоянного HTTP-запрос/ответа</h4>
<p>Произведем оценку времени, проходящего между отправкой клиентом HTTP-запроса базового документа до момента, когда весь файл (включая содержимое) получен. Для этого определим <b>время оборота</b> (round-trip time, <b>RTT</b>), т.е. время требуемое пакету малого размера для передачи от клиента к серверу и обратно (также известно как время двусторонней задержки).</p>
<p>RTT включает:</p>
<ol>
    <li>Задержка распространения</li>
    <li>Задержка ожидания в промежуточных маршрутизаторах и коммутаторах</li>
    <li>Задержка на обработку пакета</li>
</ol>
<p>Рассмотрим на конкретном примере. Допустим пользователь кликает на гиперссылку.</p>
<div style="display: flex">
    <img src="images/rtt-http.png" style="margin: 0px;height: 300px;align-items: center;">
<ol>
    <li>Браузер инициирует TCP-соединение с сервером, с "тройным рукопожатием"</li>
    <li>Клиент отправляет серверу небольшой TCP-сегмент</li>
    <li>Сервер подтверждает и отправялет в ответ также небольшой TCP-сегмент</li>
    <li>Клиент получает ответ от сервера. Прошло \( RTT\) времени</li>
    <li>Клиент вновь отправляет HTTP-запрос в TCP-соединение.</li>
    <li>Сервер получает HTTP-запрос и отправляет в ответ  HTML-файл</li>
    <li>HTML-файл прибывает клиенту. Прошло \( RTT\) времени</li>
    <li>Происходит загрузка HTML-файла клиентом.</li>
    <div style="border: 1px black solid;
    width: min-content;"><b>Суммарное время</b>: \(RTT+RTT+T_{download}=2RTT+T_{download}\)
    <ul>
        <li>\(RTT\) установления TCP-соединения</li>
        <li>\(RTT\) для отправки запроса и получения
            ответа</li></ul></div>
</ol>
</div>
<!--todo:  реализовать подсказки с помощью Tippy.js-->

<h3>Постоянные HTTP-соединения</h3>
<p>У непостоянного соединения есть ряд недостатков</p>
<p>Во-первых, <b>для каждого запрашиваемого объекта должно устанавливаться и обслуживаться новое соединение</b>. Для каждого из соединений протокол TCP должен выделить буфер, а также сохранить несколько переменных как на стороне клиента, так и на стороне сервера. Это может быть затруднительно для веб-сервера обслуживающих сотни, тысячи или даже миллионы одновременных соединений. </p>
<p>Во-вторых, <b>передача каждого объекта занимает задержку равную \(2RTT+T_{download}\)</b></p>
<p>В случае постоянного соединения сервер после отправки ответа оставляет TCP-соединение открытым. Через одно и то же соединение можно отправить последовательность запросов и ответов между одним и тем же клиентом и сервером. Например, одним TCP-соединением можно передать всю HTML-страницу со всем своим содержимым.</p>
<p>Более того, через одно постоянное соединение можно отправить одному и тому же клиенту много веб-страниц, размещенных на том же сервере. Так реализуется конвейеризация - запросы объектов делаются один за другим без ожидания ответов на запрос от сервера. Сервер отвечает на каждый запрос, отправляя в ответ запрошенный объект. Обычно TCP-соединение закрывается после некоторого тайм-аута неиспользования. </p>

<h2>Формат HTTP-сообщения</h2>
<p>В протоколе HTTP определено 2 типа сообщений - запрос (<span class="code">request</span>) и ответ (<span class="code">response</span>).</p>

<h3>Сообщение-запрос (<span class="code">request</span>) HTTP</h3>
<p></p>
<pre><code class="code-tips" data-tooltip-cont="1">GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr</code>
<div class='code-tips'>
    0. GET{}
    0. HTTP/1.1{}
    1. Host{}
    2. Connection{}
    3. User-agent{}
    4. Accept-language{}
</div></pre>
<!--todo: реализовать включение/отключение номера строки в блоке кода-->
<!--todo: перед хайлайтингом собирается инфа по строке, элементу и тексту подсказки-->
<!--todo: после хайлайтинга мы модифицируем строки оборачивая-->
<script>

</script>

<pre><code class="code-tips">TEST МЕТОД UTL HTTP/версия
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr</code></pre>

<h3>Сообщение-ответ HTTP</h3>

<pre><code>HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(данные данные данные данные данные...)</code></pre>

<pre><code>telnet cis.poly.edu 80
GET /~ross/ HTTP/1.1
Host: cis.poly.edu</code></pre>

<!--<script>-->
<!--    `<div></div>`$($0).text().split('\n').length-->
<!--</script>-->


https://habr.com/ru/articles/215117/
https://ru.wikipedia.org/wiki/HTTP

</body>
</html>