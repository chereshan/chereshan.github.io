<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Глава 3. Прикладной протокол HTTP</title>

    <style>
        @import url("../styles/styles.css");
        @import url("../modules/vs2015.min.css");
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../modules/jquery-3.7.1.min.js"><'+'/script>')</script>
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


</head>
<body>
<script src="../common/counters_body.js"></script>

<!--todo: привести эту страницу в приличный вид-->
<!--todo: rename urls without html for github pages-->
<h1>Глава 3. Прикладной протокол HTTP</h1>
<h2>История HTTP</h2>
<p>В начале 90-х на свет появилось главное приложение Интернета - Всемирная паутина. Одна из возможных причин, почему Всемирная паутина привлекла пользователей — это то, что принцип ее функционирования — работа по запросу.</p>


<h2>Определение протокола HTTP</h2>
<p><b>HTTP</b> (<i>HyperText Transfer Protocol</i>) (протокол передачи гипертекста) — сетевой протокол прикладного уровня, который изначально предназначался для получения с серверов гипертекстовых документов в формате HTML, а с течением времени стал универсальным средством взаимодействия между узлами как Всемирной паутины, так и изолированных веб-инфраструктур. Определение по основным документациям: <b>HTTP</b> — протокол уровня приложений для распределённых, объединённых, гипермедийных информационных систем, используемый в глобальной информационной инициативе Всемирной паутины с 1990 года.</p>
<p>HTTP реализуется в двух частях приложений: <i>клиентской</i> и <i>серверной</i>. Клиентская и серверная части программ, исполняемые на различных конечных системах, общаются друг с другом, обмениваясь сообщениями HTTP. Протокол HTTP определяет структуру этих сообщений и порядок обмена между клиентом и сервером. Если конкретнее, HTTP определяет порядок того, как веб-клиенты запрашивают веб-страницы с веб-сервера и как сервер передает эти страницы клиентам.</p>
<h2>Терминологические пояснения по WWW</h2>
<p>Перед тем как детально объяснить HTTP, сделаем краткий обзор терминологии Всемирной паутины.</p>
<p><b>Веб-страница</b> (веб-документ) состоит из объектов.</p>
<p><b>Объект</b> - это простой файл, имеющий уникальный URL-адрес, например файл формата HTML, изображение в формате JPEG, Java-апплет или видеоклип.</p>
<p>Большинство веб-страниц состоит из <b>базового HTML-файла</b>, который содержит ссылки на несколько объектов. Например, если веб-страница содержит HTML-текст и пять рисунков в формате JPEG, это значит, что веб-страница содержит шесть объектов: <i>базовый файл</i> плюс пять изображений.</p>
<p>Базовый файл содержит в себе ссылки на другие объекты, в виде их URL-адресов, находящихся в тексте базового файла. Каждый <b>URL-адрес</b> состоит из двух частей: <b>имени сервера</b>, содержащего объект и пути до этого объекта.</p>
<p> Например, URL-адрес <span class="code">http://www.someSchool.edu/someDepartment/picture.gif</span> содержит адрес хоста <span class="code">www.someSchool.edu</span> и имя пути <span class="code">/someDepartment/picture.gif</span>.</p>

<h2>Кратко о HTTP</h2>
<p>Мы будем использовать <i>слова браузер и клиент как взаимозаменяемые</i>, так как веб-браузеры реализуют клиентскую сторону протокола HTTP. Веб-серверы, реализующие серверную сторону HTTP, содержат веб-объекты, на которые указывают ссылки.</p>
<p><b>Когда пользователь запрашивает веб-страницу</b> (например, щелкает по гиперссылке), браузер отправляет HTTP-запрос объектов этой страницы серверу. Сервер получает запрос и отвечает сообщением HTTP, которое содержит объекты.</p>
<p>HTTP использует TCP в качестве базового транспортного протокола. Простой порядок взаимодействия:</p>
<ol>
    <li>HTTP-клиент инициирует TCP-соединение с сервером</li>
    <li>Когда соединение установлено, процессы браузера и сервера получают доступ к TCP через свои сокеты (дверью между клиентским процессом и TCP-соединением)</li>
    <li>HTTP-сервер принимает запрос и отсылает ответное сообщение, используя свой сокет</li>
</ol>
<p>Передача по протоколу TCP <i>надежна</i>, а это означает, что <b>каждый HTTP-запрос, посланный клиентским процессом, обязательно прибудет к серверу, и наоборот, каждый HTTP-ответ, посланный сервером, обязательно будет получен клиентом</b>. Поэтому нам не нужно заботиться о потере данных, т.к. это все работа протокола TCP и протоколов уровней стека более низкого уровня. </p>
<img src="images/http-request-response.png" alt="">
<p>Важно отметить, что сервер отправляет запрошенные файлы клиенту, не сохраняя какой-либо информации о клиенте. Если один и тот же клиент запросит один и тот же файл дважды, то HTTP-сервер отправит его еще раз, забыв, что он только что это делал. Таким образом, <b>HTTP-сервер не обрабатывает информации о клиенте</b>, поэтому говорят, что HTTP - это <b>протокол без сохранения состояния</b>.</p>
<h2>(Не)постоянные соединения</h2>
<p>HTTP-сервер должен отвечать на массу запросов посылаемых клиентом. Когда взаимодействие происходит через TCP, то разработчик приложения должен принять решение о том, как отправлять каждую пару запрос-ответ - через <i>отдельное</i> или через <i>одно и то же</i> TCP-соединение.</p>
<ul>
    <li><b>Непостоянное соединение</b>: запрос-ответы посылаются каждый отдельно через собственные соединения</li>
    <li><span data-tooltip="HTTP по умолчанию использует постоянное HTTP-соединение"><b>Постоянное соединение</b></span>: запрос-ответы посылаются через одно постоянное соединение</li>
</ul>

<h3>Непостоянные HTTP-соединения</h3>
<p>Рассмотрим этапы передачи веб-страницы в случае непостоянного соединения. Предположим, что страница состоит из базового HTML-файла и десяти изображений в формате JPEG и все эти 11 объектов находятся на одном сервере. Пусть URL-адрес для базового HTML-файла имеет вид: <span class="code">http://www.someSchool.edu/someDepartment/home.index</span>
</p>
<p>Вот что происходит:</p>
<ol>
    <li>HTTP-клиент инициирует TCP-соединение с сервером <span class="code">www.someSchool.edu</span> по порту <span class="code">80</span> (<b>порт по умолчанию для HTTP</b>). Этому TCP-соединению выделяются сокеты на клиентской и серверной стороне.</li>
    <li>HTTP-клиент отправляет запрос серверу через свой сокет. Запрос включает путь к базовому файлу <span class="code">/someDepartment/home.index</span>.</li>
    <li>Процесс HTTP-сервера получает запрос через свой сокет, извлекает объект <span class="code">/someDepartment/home.index</span> из своего места хранения (оперативной памяти или диска), помещает объект в ответное HTTP-сообщение и отправляет клиенту через свой сокет.</li>
    <li>Процесс HTTP-сервера дает команду протоколу TCP закрыть соединение, когда сервер получит сообщение об успехе передачи.</li>
    <li>HTTP-клиент получает ответ от сервера, и TCP-соединение разрывается. Сообщение указывает, что полученный объект — это HTML-файл. Клиент извлекает файл из сообщения, обрабатывает его и находит ссылки на 10 объектов (файлов в формате JPEG).</li>
    <li>Шаги с первого по четвертый повторяются для каждого из десяти JPEG-объектов.</li>
</ol>
<p>Заметим, что спецификация протокола HTTP определяет только протокол взаимодействия между программой клиента и программой сервера, но ничего не говорит о том, как веб-страница должна интерпретироваться клиентом, поэтому могут существовать разночтения от браузера к браузеру. </p>
<p>Таким образом, непостоянное HTTP-соединение - это соединение, при котором TCP-соединение передает ровно одно сообщение запрос и одно сообщение ответ. В примере выше было установлено ровно 11 TCP-соединений.</p>
<p>Тут намеренно не уточнялось получил ли клиент 10 изобраажений серией из 10 последовательных TCP-соединений, или параллельно. Большинство современных веб-браузеров в режиме по умолчанию открывают 5-10 параллельных TCP-соединений, и каждый обрабатывается параллельно. Если установить ограничение на 1 одновременное TCP-соединение, то мы получим простой случай очереди TCP-соединений. </p>
<h4>Оценка интервала времени непостоянного HTTP-запрос/ответа</h4>
<p>Произведем оценку времени, проходящего между отправкой клиентом HTTP-запроса базового документа до момента, когда весь файл (включая содержимое) получен. Для этого определим <b>время оборота</b> (round-trip time, <b>RTT</b>), т.е. время требуемое пакету малого размера для передачи от клиента к серверу и обратно (также известно как время двусторонней задержки).</p>
<p>RTT включает:</p>
<ol>
    <li>Задержка распространения</li>
    <li>Задержка ожидания в промежуточных маршрутизаторах и коммутаторах</li>
    <li>Задержка на обработку пакета</li>
</ol>
<p>Рассмотрим на конкретном примере. Допустим пользователь кликает на гиперссылку.</p>
<div style="display: flex">
    <img src="images/rtt-http.png" style="margin: 0px;height: 300px;align-items: center;">
<ol>
    <li>Браузер инициирует TCP-соединение с сервером, с "тройным рукопожатием"</li>
    <li>Клиент отправляет серверу небольшой TCP-сегмент</li>
    <li>Сервер подтверждает и отправялет в ответ также небольшой TCP-сегмент</li>
    <li>Клиент получает ответ от сервера. Прошло \( RTT\) времени</li>
    <li>Клиент вновь отправляет HTTP-запрос в TCP-соединение.</li>
    <li>Сервер получает HTTP-запрос и отправляет в ответ  HTML-файл</li>
    <li>HTML-файл прибывает клиенту. Прошло \( RTT\) времени</li>
    <li>Происходит загрузка HTML-файла клиентом.</li>
    <div style="border: 1px black solid;
    width: min-content;"><b>Суммарное время</b>: \(RTT+RTT+T_{download}=2RTT+T_{download}\)
    <ul>
        <li>\(RTT\) установления TCP-соединения</li>
        <li>\(RTT\) для отправки запроса и получения
            ответа</li></ul></div>
</ol>
</div>
<!--todo:  реализовать подсказки с помощью Tippy.js-->

<h3>Постоянные HTTP-соединения</h3>
<p>У непостоянного соединения есть ряд недостатков</p>
<p>Во-первых, <b>для каждого запрашиваемого объекта должно устанавливаться и обслуживаться новое соединение</b>. Для каждого из соединений протокол TCP должен выделить буфер, а также сохранить несколько переменных как на стороне клиента, так и на стороне сервера. Это может быть затруднительно для веб-сервера обслуживающих сотни, тысячи или даже миллионы одновременных соединений. </p>
<p>Во-вторых, <b>передача каждого объекта занимает задержку равную \(2RTT+T_{download}\)</b></p>
<p>В случае постоянного соединения сервер после отправки ответа оставляет TCP-соединение открытым. Через одно и то же соединение можно отправить последовательность запросов и ответов между одним и тем же клиентом и сервером. Например, одним TCP-соединением можно передать всю HTML-страницу со всем своим содержимым.</p>
<p>Более того, через одно постоянное соединение можно отправить одному и тому же клиенту много веб-страниц, размещенных на том же сервере. Так реализуется конвейеризация - запросы объектов делаются один за другим без ожидания ответов на запрос от сервера. Сервер отвечает на каждый запрос, отправляя в ответ запрошенный объект. Обычно TCP-соединение закрывается после некоторого тайм-аута неиспользования. </p>

<h2>Формат HTTP-сообщения</h2>
<p>В протоколе HTTP определено 2 типа сообщений - запрос (<span class="code">request</span>) и ответ (<span class="code">response</span>).</p>

<h3>Сообщение-запрос (<span class="code">request</span>) HTTP</h3>
<p></p>
<pre><code class="code-tips">GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr


</code>
</pre>
<!--todo: переписать фрагмент ниже с помощью типов-->
<p>Начнем с того, что сообщение представлено обычными ASCI-символами. В сообщении 5 строк, каждая из которых заканчиавается переносом строки, а последняя двумя переносами. На самом деле GET-запрос необхяательно должен иметь эти 5 строк, обзем случае он может содержать от одной и более строк. </p>
<ul>
    <li>Первая строка - строка запроса</li>
    <li>Следующие строки - строки заголовков</li>
    <li>Строка запроса содержит: поле метода, поле URL и поле ерсии протокола HTTP</li>
    <li>Поле метода может принимать значения GET, POST, HEAD, PUT, DELETE</li>
    <li>Большинсто запросо однако используют метод GET. Он применяется, когда браузер запрашиает объект идентифицируемый полем URL. В данном примере браузер запрашиает объект /somedir/page.html</li>
    <li>Строка заголовка Host - адреса хоста, на котором размещается объект. Несмотря на то, что может показаться, что эта строка не необходима, т.к. соединение с данным хостом уже устанолено, однако эта информация нужна для кэширующего прокси-серера</li>
    <li>Строка заголока Connection - браузер сообщает сереру, что не собирается работать с постоянным соединением, и его нужно разорать после отпраки запрашиаемого объекта</li>
    <li>Строа заголока User-agent - тип браузера, который соершает запрос к сереру. Эта информация полезна, т.к. серер может отсылать разную информацию рахным браузерам</li>
    <li>Строка Accept-language - указыает, что пользоатель предпочитает получить ерсию объекта на французском языке, если такая сущестует.  В протином случае серер отошлет клиенту дефолтную версию объекта. </li>
</ul>
<p>Ниже предстален общий формат GET-запроса. </p>
<pre><code>МЕТОД URL ВЕРСИЯ //СТРОКА ЗАПРОСА
ИМЯ_ПОЛЯ_ЗАГОЛОВКА: ЗНАЧЕНИЕ//СТРОКА ЗАГОЛОВКА
ИМЯ_ПОЛЯ_ЗАГОЛОВКА: ЗНАЧЕНИЕ//СТРОКА ЗАГОЛОВКА
ИМЯ_ПОЛЯ_ЗАГОЛОВКА: ЗНАЧЕНИЕ//СТРОКА ЗАГОЛОВКА
//ПУСТАЯ СТРОКА
ТЕЛО СООБЩЕНИЯ</code></pre>
<p>tip: Тело сообщения пусто при использовании метода GET и содержит информацию, если используется метод POST.</p>
<p>Чаще всего метод POST применяется со стороны клиента, когда пользоаетль заполняет форму и ответ со стороны сервера должен отличаться в заисимости от введенных клиентом данных, например, поисковой запрос. </p>
<p> Иногда вместо этого используется метод GET, в котором особый запрос клиента передается в URL. Допустим, в форму введены значения monkey и bananas, то тогда GET-запрос может иметь следующий вид:</p>
<pre><code >GET /somedir/animalsearch?monkeys&bananas HTTP/1.1
Host: www.someschool.edu
</code></pre>
<p>Метод HEAD аналогичен методу GET. Когда серер получает с помощью него запрос, то он отпраляет отетное HTTP-сообщение, но не пересылает в нем объект. Этот метод чаще всего используется для отлади со стороны разработчиков.</p>
<p>Метод PUT часто испольузется соместно с инструментами веб-публикации. Он позволяет загружать объъект по указанному адресу на конкретный веб-серверу. Он также используется приложениями, требующщими загрузки объектов на веб-серверы. </p>
<p>Метод DELETE позволяет пользователю удалять объект на веб-сервере. </p>

<!--todo: реализовать включение/отключение номера строки в блоке кода-->
<!--todo: перед хайлайтингом собирается инфа по строке, элементу и тексту подсказки-->
<!--todo: после хайлайтинга мы модифицируем строки оборачивая-->

<h3>Сообщение-ответ (<span class="code">response</span>) HTTP</h3>
<p>Ниже приведено типичное ответное сообщение, используемое протоколом HTTP.</p>
<pre><code class="code-tips">HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(данные данные данные данные данные...)</code></pre>
<ul>
    <li>Ответное сообщение состоит из строки состояния, шести строк заголовка (необязательно 6) и тела сообщения</li>
    <li>Тело сообщения содержит сам запрашиваемый объект</li>
    <li>Строка состояния содержит три поля: поле версии протокола, код состояния и фразу состояния</li>
    <li>В данном примере: сервер использует версию протокола HTTP/1.1 и что все ОК, т.е. сервер нашел запрашиваемый объект и начал его передачу.</li>
    <li>Строка Connection: close - сервер сообщает клиенту, что он собирается закрыть TCP-соединение после отправки сообщения.</li>
    <li>Строка Date: - указывает время и дату создания ответа сервером. Это не время создания или изменения объекта, а время когда сервер извлекает объект из своей файловой системы, вставляет его в ответное сообщение и отправляет клиенту. </li>
    <li>Строка заголовка Server: означает, что сообщение было сгенерировано сервером Apache. Здесь прослеживает аналогия с User-agent. </li>
    <li>Last-Modified: - время последнего изменения объекта. Эта строка наиболее критична для кэширования объекта как для локальных клиентов, так и для сетевых кэширующих серверов</li>
    <li>Строка заголовка Content-Length: - показывает число бай и пересылаемом объекте</li>
    <li>Content-Type: - информирует о том, что объект в теле сообщения является текстом в формате HTML (расширение файла в файловой системе)</li>
</ul>
<p>Вариации строки состояния:</p>
<ul>
    <li>200 OK: запрос выполнен успешно и информация передана в ответном письме.</li>
    <li>301 Moved Permanently: запрошенный объект перемещен; новый URL-адрес указывается в заголовке ответного сообщения, содержащем строку Location:. Браузер автоматически перенаправляет юзера на новую страницу.</li>
    <li>400 Bad Request: код ошибки - запрос не может быть распознан сервером</li>
    <li>404 Not Found: запрошенный документ на сервере не существует</li>
    <li>505 HTTP Version Not Supported: запрошенная версия HTTP-протокола не поддерживается сервером</li>
</ul>
<p>Общий формат сообщения-ответа протокола HTTP:</p>
<pre><code>ВЕРСИЯ КОД_СОСТОЯНИЯ ФРАЗА //СТРОКА СОСТОЯНИЯ
ИМЯ_ПОЛЯ_ЗАГОЛОВКА: ЗНАЧЕНИЕ//СТРОКА ЗАГОЛОВКА
ИМЯ_ПОЛЯ_ЗАГОЛОВКА: ЗНАЧЕНИЕ//СТРОКА ЗАГОЛОВКА
ИМЯ_ПОЛЯ_ЗАГОЛОВКА: ЗНАЧЕНИЕ//СТРОКА ЗАГОЛОВКА
//ПУСТАЯ СТРОКА
ТЕЛО СООБЩЕНИЯ</code></pre>

<p>На Windows можно испытать на практике работу HTTP-протокол. Для этого необходимо ввести следующее в командной строке Windows:</p>
<pre><code>telnet cis.poly.edu 80
GET /~ross/ HTTP/1.1
Host: cis.poly.edu
    
</code></pre>
<p>В результате этой команды открывается TCP-соединение с хостом cis.poly.edu по порту 80 и ему отправляется сообщение-запрос. </p>

<h2>Взаимодействие юзера и сервера: <span class="code">cookie</span></h2>
<p>Ранее было упомянуто, что HTTP-серввер не сохраняет состояние соединение (т.е. информации о клиенте). Это позволяет HTTP-серверам иметь высокий показатель latency, открывая одновременно тысячи TCP-соединений. Однако это ограничиввает возможности сервера в тех приложениях, где необходима идентифкация группы или конкретных пользователей. Например, сервер нуобходимо ограничивать права пользователей в зависимости от его идентифкации. Для этих целей в HTTP используются <span class="code">cookie</span>. Механизм cookie позволяет сайтам отслеживать состояние пользовательсого соединения. </p>
<p>Технология cookie включает 4 основных компонента:</p>
<ol>
    <li>строка заголовка в ответном HTTP-сообщении сервера</li>
    <li>строка заголовка в HTTP-запросе клиента</li>
    <li>cookie-файл, хранящийся на хосте пользователя и управляемый его браузером</li>
    <li>база данных на стороне веб-сервера</li>
</ol>
<p>Представим следующую ситуацию, клиент выходит в интернет со своего ПК, используя браузер Chrome и в первый раз посещает сервер Amazon.com. Допустим, ранее он посещал сайт eBay.</p>

<img src="images/cookie-mechanism.png" alt="">
<ol>
    <li>Клиент посещает сайт eBay, на сервере eBay создается запись с его <span class="code">id=8734</span>, в cookies клиента записан <span class="code">id_ebay=8734</span></li>
    <li>Клиент заходит на сайт Amazon.ru. Посылается HTTP-запрос.</li>
    <li>Сервер получает запрос клиента. Он создает запись с <span class="code">id=1678</span> клиента в своей базе данных.</li>
    <li>Сервер Amazon посылает HTTP-ответ с хедером <span class="code">Set-cookie: 1678</span></li>
    <li>Браузер видит в ответном HTTP-сообщении заголовок <span class="code">Set-cookie: 1678</span> и добавляет эту строку в хранящиеся на стороне клиента cookie. Они содержат имя сервера и идентифкационный номер из заголовка. Пусть cookie-файл клиента имеет следующий вид: <pre><code >amazon: 1678
ebay: 873</code></pre></li>
    <li>Теперь когда клиент будет отправлять HTTP-запрос к серверу Amazon или eBay, он будет также посылать заголовок <span class="code">cookie: 1678</span></li>
    <li>Сервер будет получать HTTP-запрос и смотреть в своей базе данных запись с данным идентифкатором и отправлять данные в ответ измененные исходя из данного идентифкатора. </li>
</ol>
<p>Благодаря механизму cookie сервер может знать когда и какие страницы посетил данный клиент, не зная никакой персональной информации о нем. Так он может, например, организовать карту покупок конкретного клиента, которая будет сохранятся даже после окончания сеанса пользователя на сайте.</p>
<p>Amazon исходя из истории покупок пользователя, записанных в базе данных под идентификатором пользователя может рекомендовать пользователю конкретные товары.</p>
<p>Если вдобавок лиент зарегистрируется на сайте, передав своем имя, номер телефона, электронную почту и номер карты, то сервер запишет эти данные в свою базу данных, связав имя клиента и его идентифкационный номер. </p>
<p>Таким образом, cookie-механизм создает как бы дополнительный сеансовый уровень поверх протокола HTTP, который не сохраняет информацию соединения.</p>
<h2>Веб-кэширование (прокси-сервер)</h2>
<p><b>Веб-кэш</b> (также называемый <b>прокси-сервером</b>) - это элемент серти, который обрабатывает HTTP-запрос в дополнение к "настоящему" серверу. Для этого на прокси-сервере имеется собственное дисковое хранилище, куда помещаются копии недавно запрошенных объектов.</p>
<p>Допустим, что клиент запрашивает объект <span class="code">http://www.someschool.edu/campus.gif</span>:</p>

<div style="display: flex">
    <img src="images/proxy-server.png" style="margin: 0px;height: 300px;align-items: center;">
    <ol>
        <li>Браузер устанавливает TCP-соединение с прокси-сервером и отправляет ему HTTP-запрос объекта.</li>
        <li>Прокси-сервер получает запрос и проверяет хранится ли у него локально копия запрошенного объекта. Если да, то этот объект возвращается в сообщении-ответе браузеру.</li>
        <li>Если сервер не нашел запрошенный объект, то он открывает TCP-соединение с серером <span class="code">www.someschool.edu</span> и затем отправляет HTTP-запрос объекта в соединении между прокси-сервером и веб-сервером. </li>
        <li>Прокси-сервер получает объект и сохраняет его копию, а затем отправляет эту копию браузеру клиента вместе с HTTP-ответом на изначальный запрос клиента через существующее TCP-соединение между клиентом и прокси-сервером.</li>
    </ol>
</div>
<p>Заметим, что веб-кэш (прокси-сервером) в выше описанной ситуации является и сервером, и клиентом. </p>
<p>Обычно прокси-серверы устанавливают интернет-провайдеры.</p>
<p>Технология веб-кэша распространена в интернете по двум причинам:</p>
<ol>
    <li>Она позволяет уменьшить время овтета на запрос клиента, особенно если пропускная линия между клиентом и веб-серевром намного меньше, чем между клиентом и прокси-сервером. Обычно между клиентом и проси-сервером устанавливается высокоскоростное соединение. </li>
    <li>Прокси-сервер может уменьшить трафик в сети доступа организации, а это позволяет снизить расходы и положительно сказывается на производительности приложений, использующих сеть.</li>
</ol>
<h3>Сравнение сети с прокси сервером и без на примере</h3>
<p>Проиллюстрируем выигрыш от использования прокси-сервера на конкретном примере. </p>
<p>Условия задачи:</p>
<ul>
    <li>Имеем 2 сущности - <i>сеть организации</i> и <i>публичный интернет</i></li>
    <li>Сеть организации - высокоскоростная ЛВС</li>
    <li>Мрашрутизатор организации и маршрутизатор публичного интенета соединены <i>каналом связи</i> со скоростью <b>\(15\) \(Мбит/с\)</b>.</li>
    <li>Веб-серверы публичного интернета размещены по всему миру</li>
    <li>Размер среднего запрашиваемого клиентами организации объекта из публичного интернета - <b>\(1\) \(Мбит\)</b></li>
    <li>Средняя скорость запросов от браузеров организации к веб-серерам - 15 запросов/с</li>
    <li>Пусть, размер HTTP-запроса принебрежительно мал и не создает трафкиа ни в сетях организации, ни в канале связи между маршрутизаторами. </li>
    <li>Пусть среднее время, прошедшее с момента, когда маршрутизатор со стороны публинчого интернета перенаправляет HTTP-запрос до получения ответа равно 2 секундам. Это время мы будем называть задержкой интернета (\(T_{www}\))</li>
</ul>
<div style="display: flex">
    <img src="images/proxy-example.png" style="margin: 0px;height: 400px;align-items: center;">
    <ol>
        <li>Общее время ответа (время от момента запроса объектов браузером до получения им объекта) - это сумма задержки ЛВС, задержки доступа (задержки в канале между маршрутизаторами) и задержки интернета. Таким образом, \(T_{totalresponse}=T_{LVSdelay}+T_{access}+T_{www}\) </li>
        <li>Интенсивность трафика в сети ЛВС равна:
            \(15\times1/100=0.15\)</li>
        <!--todo: tip: 15 запросов/с 1Мбит/запрос 100 Мбит/с -->
        <li>Интенсивность трафика в канале доступа равна:
            \(15\times1/15=1\)</li>
        <!--todo: tip: 15 запросов/с 1Мбит/запрос 15 Мбит/с -->
        <li>\(0.15\Rightarrow 10 мс\) задеркжи, т.е. этой задержкой можно принебречь</li>
        <li>\(1\Rightarrow +\infty\) задержки, т.е. время задержки может достигать нескольких минут, если не больше, что для организации неприемлемо.</li>
        <!--todo: может достигать значений вплоть до бесконечных -->
        <li>Если мы увеличим скорость доступа до 100 Мбит/с, то это понизит интенсивность трафика до 0.15, и в этом случае время ответа станет примерно равным 2 мс, т.е. равной задержке интернета, но это значит, что сеть организации необходимо модернизировать.</li>
    </ol>
    </div>
<p>Рассмотрим альтернативную ситуацию, в которой вместо модернизации сети используется прокси-сервер. Добавим к уже имеющимся условиям следующие:</p>
    <ol>
        <li>Доля запросов, обслуживаемых прокси-серером (<b>коэффицент попадания в кэш</b>) обычно варьируется от 0.2 до 0.7. Для нашего примера предположим данный коэффицент постоянным и равным 0.4.</li>
        <li>Клиенты и прокси-сервер соединены одной высоскоростной ЛВС и 40% запросов будут удовлетоворены немедленно, т.е. в течение 10 мс.</li>
        <li>Оставшиеся 60% запросов должны пройти через сеть доступа</li>
    </ol>

<div style="display: flex">
    <img src="images/proxy-server-example2.png" style="margin: 0px;height: 400px;align-items: center;">
    <ol>
        <li>40% запросов будут иметь \(0.15\Rightarrow 10 мс\) задеркжи, т.е. этой задержкой можно принебречь</li>
        <li>60% запросов будут иметь интенсивность \(15\times0.6\times1/15=0.6\)</li>
        \(0.6\Rightarrow +2 с\) задержки, т.е. время задержки может достигать нескольких минут, если не больше, что для организации неприемлемо.</li>
        <li>Средняя задержка станет равна: \(0.4\times0.01+0.6\times2=1.2 c\)</li>
    </ol>
</div>
<p>Таким образом, прокси-сервер обеспеичвает еще больший выигрыш в задержке, не требуя расходов на модернизацию сети. </p>
<p>С появлением сетей доставки контента (Content Distribution Networks, или CDN) прокси-серверы стали играть важную роль в интернете. Компании-провайдеры CDN инсталируют территориально распределенные прокси-серверы интернета, тем самым локализуя трафик.</p>


<h2>Метод <span class="code">GET</span> с условием</h2>
<p>Несмотря на то, что кэширование уменьшает время ответа пользовательскому браузеру добавляется еще одна проблема - копия объекта, находящаяся в кэше может устареть с теъ пор, пока она была прокэширована клиентом, т.е. объект размещенный на веб-сервере мог измениться.</p>
<p>HTTP-протокол имеет механизм размещения этой проблемы. позволяя прокси-серверу проверять актуальность объекта в памяти. Для жтого применяется т.н. <b>условный <span class="code">GET</span>-запрос</b> со строкой заголовка <span class="code">If-Modified-Since:</span>.</p>
<p>Допустим, что прокси-сервер от имени браузера отправляет запрос сереру:</p>
<pre><code>GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
</code></pre>
<p>Затем веб-серев отправляет ответное сообщение с запрошенным объектом прокси-серверу:</p>
<pre><code>HTTP/1.1 200 OK
Date: Sat, 8 Oct 2011 15:39:29
Server: Apache/1.3.0 (Unix)
Last-Modified: Wed, 7 Sep 2011 09:23:24
Content-Type: image/gif
(данные данные данные данные данные...)
</code></pre>
<p>Прокси-сервер перенаправляет объект браузеру, но, кроме того, сохраняет у себя в кэше его локальную копию с датой его последнего изменения.</p>
<p>Допустим, спустя неделю браузер опять запрашивает этот объект через проси-сервер. Прокси-сервер отправляет следующий запрос на веб-сервер:</p>
<pre><code >GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 7 Sep 2011 09:23:24</code></pre>
<p>Если объект не был изменен и строки If-modified-since: и Last-Modified: совпадают, то веб-сервер отправит следующий ответ буз запрашиваемого объекта:</p>
<pre><code>HTTP/1.1 304 Not Modified
Date: Sat, 15 Oct 2011 15:39:29
Server: Apache/1.3.0 (Unix)
(пустое тело сообщения)</code></pre>


</body>
</html>