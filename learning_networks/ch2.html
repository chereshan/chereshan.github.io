<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="UTF-8">
    <title>Глава 2. Прикладной уровень сетей</title>
<!--    Подключение матджакса(латекс-формул)-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src='../modules/jquery-3.7.1.min.js'></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
</head>
<body>
<script src="../common/counters_body.js"></script>
<h1>Глава 2. Прикладной уровень сетей</h1>

<h2>Принципы сетевых приложений</h2>
<p>Ключевую часть разработки сетевых приложений составляет написание программ, которые работают на различных конечных системах и общаются друг с другом по сети. Например, <b>веб-приложение</b> — это две различные программы, взаимодействующие друг с другом: <b>браузер</b>, запущенный на хосте пользователя (настольном компьютере, ноутбуке, планшете, смартфоне и так далее), и <b>веб-сервер</b>, работающий на серверном хосте.</p>
<p>Другой пример — это одноранговые системы совместного доступа к файлам, где на каждом из хостов, который участвует в файловом обмене, запущена такая программа. В этом случае программы на различных хостах могут быть аналогичными или даже идентичными.</p>
<p>Важно отметить здесь, что вам не нужно писать программное обеспечение для устройств, составляющих ядро сети, таких как маршрутизаторы или коммутаторы канального уровня. Но даже если бы вы и задались такой целью, вы бы не смогли это сделать, т.к. данные устройства функционируют не на прикладном уровне, а на сетевом и более низких уровнях</p>

<h3>Архитектура сетевых приложений</h3>
<p>С точки зрения разработчика приложения, архитектура сети постоянна и предлагает определенный набор служб приложениям. С другой стороны, <b>архитектура приложения</b> создается разработчиком этого приложения и определяет, каким образом оно будет строиться на различных конечных системах. Выбирая архитектуру приложения, разработчик, скорее всего, выберет одну из двух доминирующих архитектурных парадигм, используемых в современной разработке сетевых приложений: <b>клиент-серверная</b> или <b>одноранговая</b> (P2P).</p>
<p><b>Доминирующие архитектурные парадигмы для сетевых приложений:</b></p>
<ul>
    <li><b>Клиент-серверная</b>: существует 1 хост (сервер), который постоянно находится онлайн и обслуживает запросы от других хостов (клиентов). Когда веб-сервер получает запрос объекта от хоста-клиента, он в ответ отправляет запрашиваемый объект этому хосту. Заметим, что в данном виде архитектуры клиенты непосредственно не связываются друг с другом; например, в веб-приложении два браузера напрямую не обмениваются информацией. Еще одной характеристикой клиент-серверной архитектуры является то, что сервер имеет фиксированный, известный всем адрес, называемый IP-адресом (обсудим вскоре). Поскольку сервер имеет постоянный, известный адрес и всегда включен, клиент может всегда взаимодействовать с ним, отправляя пакеты на IP-адрес этого сервера. <br>Некоторые из хорошо известных приложений клиент-серверной архитектуры — это <i>Всемирная паутина</i>, <i>FTP</i>, <i>Telnet</i> и <i>электронная почта</i>.  </li>
    <li><b>Одноранговая (P2P)</b> - архитектура, в которой применение серверов или центров обработки сведено до минимума или вообще до нуля. Вместо них приложения используют непосредственное взаимодействие между парой соединенных хостов, называемых пирами (также партнерами или узлами). Пирами являются обычные ПК. Т.к. они взаимодействуют без выделенного сервера, такая архитектура называется одноранговой (<i>peer-to-peer</i>). Примеры - файлообменные приложения, ускорители загрузок, IP-телевидение. </li>
</ul>
<img src="images/p2p.png" alt="">
<p>Преимуществом одноранговой архитектуры является ее самомасштабируемость, т.к. вычислительные/накопительные мощности системы растут по мере роста аудитории. </p>
<p>Проблемы одноранговой архитектуры:</p>
<ol>
    <li>Адаптация к сетям доступа. Большинство сетей доступа (DSL и кабельные сети) построены по ассиметричному принципу, т.е. скорость входящего трафика значительно превышает скорость исходящего. Поскольку P2P-приложения для обработки видео от ссерверов к сетям доступа смещают исодящий трафик от серверов к сетям доступа, то нагрухка на них значительно возрастает. </li>
    <li>Безопасность. </li>
    <li>Стимулирование юзеров к вкладу в P2P-сеть./li>
</ol>
<h3>Взаимодействие процессов</h3>
<p>Процесс - программа, запущенная на конечной системе. Когда процессы работают на одном хосте, то они взаимодействуют друг с другом с помощью средств межпроцессного взаимодествия. Как же взаимодестйвуют процессы на разных хостах?</p>
<p> <i>Процессы на двух хостаз взаимодествуют друг с другом обмениваясь сообщениями через сеть. Например, в веб-приложении процесс браузера клиента обменивается сообщениями с процессом веб-сервера. В случае P2P файлообменной сети процесс одного хоста преедает файл в процесс другого хоста.</i></p>
<p><i>В контексте сеанса взаимодествия между парой процессов тот, который инициирует взаимодествие (т.е. первым контактирует с другим процессом в начале сеанса), обозначается как <b>клиентский</b>.</i></p>
<p>Процесс, который ожидает контакта для начала сеанса, называется <b>серверными</b>.</p>
<h4>Интерфейс между процессом и компьютерной сетью</h4>
<p>Процессы отправляют и принимают сообщения через программный интерфейс, называемый <b>сокетом</b>. Рассмотрим аналогию для лучшего понимания процессов и сокетов. Процесс аналогичен дому, а его сокет подобен двери в этом доме. Когда процесс пытается отправить сообщение другому процессу на удаленном хосте, он «проталкивает» сообщение через свою дверь (сокет). Такая отправка предполагает, что с другой стороны этой двери существует некоторая транспортная инфраструктура, которая организует доставку сообщения до двери процесса назначения. Когда сообщение прибывает на хост назначения, оно проходит через дверь принимающего процесса (через сокет). Принимающий процесс затем обрабатывает это сообщение.</p>
<p>Сокет - это API между сетевыми приложениями и сетью (протоколом транпортного уровня).</p>
<img src="images/sockets.png" alt="">
<p>Разработчик управляет всем, что находится на прикладном уровне сокета, но со стороны транспортного уровня он управляет лишь:</p>
<ul>
    <li>выбор транспортного протокола</li>
    <li>возможность фиксации параметров транспортного уровня (например, максимальный буфер и максимальный размер сегмента)</li>
</ul>
<h4>Адресация процессов</h4>
<p>Когда запущенный на одном хосте процесс пытается отправить пакеты процессу, работающему на другом хосте, то необходимо знать адрес второго процесса. Для идентификации процесса-получателя необходима информация о двух вещах:</p>
<ol>
    <li>Адрес хоста назначения. Это IP-адрес</li>
    <li>Идентфикатор процесса на хосте назначения. ID открыторого принимающего веб-сокета запушенного на хосте-получаетле. Номер порта решает эту проблему</li>
</ol>
<h3>Транспортные службы, доступные приложениям</h3>
<p>Критерии выбора транспортного протокола</p>
<ul>
    <li>Надежная передача данных. Потеря данных может иметь место во многих приложения, например, электроннаяя почта, передача файлов, удаленный доступ и т.д. Если протокол обеспечивает гарантированную службу доставки, то говорят, что обеспечивается надежная передача данных. Приложения, для которых потеря некоторого объема данных некритична, называются устойчивыми к потерям данных. </li>
    <li>Пропускная способность - скорость, с которой передающий процесс может доставлять биты принимающему процессу. Приложения, которые требует некоторой минимальной пропускной способности называются чувствительными к скорости передачи. В тоже время эластичные приложения используют доступнуб пропускную способность. К таким приложениям относятся электронная почта, передача файлов, веб-приложения. </li>
    <li>Время доставки. Транспортным протоколом может также гарантироваться миниматальное относительное время доставки. Например, протокол может гарантировать, что каждый бит, отправленный передающей сторонной в сокет, приходит на сокет получаетеля не более через 100мс. Примерами приложения,  для которых обоснована такая гарантия - это IP-телефония, виртуальное окружения, телеконференции, а также многопользователтские игры. </li>
    <li>Безопасность. Например, транспортный протоколо на передающем хосте способен шифровать все данные, отправленные процессом источником, а затем на принимающем хосте расшифровывать их пред доставкой процессу получателю. </li>
</ul>
<h3>Транспортные средства, предоставляемые интернетом</h3>
<p></p>
<p></p>
<p></p>




</body>
</html>