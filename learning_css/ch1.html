<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Глава 1. Введение в CSS</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../modules/jquery-3.7.1.min.js"><'+'/script>')</script>
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
    <style>
        @import url("../styles/styles.css");
        @import url("../modules/vs2015.min.css");
    </style>

</head>
<body>
<script src="../common/counters_body.js"></script>
<h1>Глава 1. Введение в CSS</h1>
<!--todo: regex-калькулятор специфичности стилей-->
<h2>Размещение CSS-стилей</h2>
<p>Таблицы стилей могут создаваться с помощью трех различных методов. Если
    расположить их в порядке приоритетности сверху вниз, получится следующий
    список.</p>
<ol>
    <li>внедренные стили;</li>
    <li>встроенная таблица стилей;</li>
    <li>внешняя таблица стилей.</li>
</ol>
<p>Эти методы создания таблиц стилей также применяются в порядке, обратном порядку их приоритетности. Поэтому сначала обрабатываются все внешние таблицы стилей, и к документу применяются их стили.</p>
<p>Затем обрабатываются любые встроенные стили (которые находятся внутри тегов <span class="code">&lt;style>...&lt;/style></span>). Все, что конфликтует с внешними правилами, получает приоритет и заменяет эти правила.</p>
<p>И наконец, наивысший приоритет получают любые стили, применяемые непосредственно к элементу в качестве внедренного стиля (такие, как
<span class="code">&lt;div style="...">...&lt;/div></span>), которые заменяют все предыдущие заданные
свойства.</p>

<p>Стили CSS также можно разместить внутри документа напрямую внутри содержимого style-тега в head документа.</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;style type = "text/css"&gt;
            body p
            {   background: white;
                color: black;
                font-family: Arial, sans-serif;
                font-size: 16px;
                line-height: 1.58;
                text-rendering: optimizeLegibility;
                -webkit-font-smoothing: antialiased;}
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;CSS-стили внутри элемента style и применяются к этому абзацу в HTML-коде веб-страницы&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>CSS-стиль также можно задать для конкретного элемента документа.</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body style = "font-family: Arial;"&gt;
    &lt;p&gt;При выводе в браузере этот абзац наследует форматирование шрифтом Arial из строкового стиля в родительском элементе.&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>



<p>Когда стиль нужно применить не к одной странице, а ко всему сайту, лучше управлять таблицами стилей путем их полного перемещения из веб-страниц в отдельные файлы с последующим импортом той таблицы, которая вам нужна. Тем самым предоставляется возможность применения разных таблиц стилей к разным форматам подачи информации (например, в варианте просматриваемой веб-страницы и в варианте вывода на печать) без изменения HTML.</p>
<p>Код CSS можно разместить в отдельном документе, а затем подключить его к HTML-документу с помощью link-тега в head-разделе документа.</p>
<pre><code class="language-html">&lt;link rel = "stylesheet"
    type = "text/css"
    href = "style.css"&gt;</code></pre>
<p>Все каскадные таблицы стилей имеют тип
    <span class="code">text/css</span>. Таблицы стилей JavaScript применяют тип <span class="code">text/javascript</span>.
    Можно опустить данный атрибут и надеяться, что броузер сам поймет,
    какой тип используется.</p>
<p>Напомним, что тег <span class="code">&lt;link></span> связывает документ, в котором он содержит
    ся, с какимто другим документом в сети. В примере мы сообщаем бро
    узеру, что документ, поименованный в атрибуте <span class="code">href</span>, имеет тип
    <span class="code">stylesheet</span>, как это указано в атрибуте <span class="code">type</span>. Ссылка на внешнюю табли
    цу стилей в теге <span class="code">&lt;link></span> требует указания атрибутов href и <span class="code">type</span>. Кроме
    того, мы явно, причем добровольно, сообщаем броузеру, что отношение файла к нашему документу определяется значением <span class="code">stylesheet</span>
    (таблица стилей)</p>



<p>Другим способом применения стилей для всей страницы является использование директивы <span class="code">@import url("адрес стиля")</span>. Результат использования <span class="code">@import</span> будет точно таким же, как и при использовании <span class="code">&lt;link></span> , но <span class="code">&lt;link></span> является тегом, применяемым только в HTML, и не относится к стилевым директивам, поэтому он не может задействоваться в одной таблице стилей для импорта другой такой таблицы. Он также не может помещаться внутри пары тегов <span class="code">&lt;style>...&lt;/style></span>.</p>
<p>На эту страницу стили вызываются следующим образом:</p>
<pre><code >&lt;style>
    @import url("../styles/styles.css");
    @import url("../modules/vs2015.min.css");
&lt;/style></code></pre>
<p>Директива <span class="code">@import</span> ожидает параметр в виде URL, указывающего путь
    в сети к внешней таблице стилей. Как показано в этом примере, URL
    может быть заключенной в двойные кавычки строкой, заканчиваю
    щейся точкой с запятой, или следовать за ключевым словом <span class="code">url</span>, так
    же оканчиваясь точкой с запятой, но помещаясь при этом в скобки.
    URL может быть абсолютным или относительным, отсчитываемым от
    базового URL документа.</p>
<p>Директива <span class="code">@import</span> может появиться в определениях стиля на уровне
    документа или даже в другой таблице стилей, что позволяет создавать
    вложенные таблицы стилей.</p>
<p>Таким образом, способ с <span class="code">@import</span> также является предпочтительным.</p>

<!--todo: у автооглавления главы есть проблема с выводом тегов в именах глав-->
<h3><span class="code">&lt;link></span> или <span class="code">@import</span>?</h3>
<p>На первый взгляд может показаться, что способы присоединения таб
лиц стилей, использующие тег <span class="code">&lt;link></span> и директиву <span class="code">@import</span>, эквивалент
ны и применяют различный синтаксис для достижения одной и той же
цели. Это так, если в документе только один тег <span class="code">&lt;link></span>. Когда их боль
ше, в игру вступают специальные правила CSS.</p>
<p>Когда в документе содержится один тег <span class="code">&lt;link></span>, броузер должен загру
    зить стили из таблицы, на которую ссылается тег, и в соответствии
    с ними провести форматирование, учитывая, что при конфликте уста
    новки на уровне документа и встроенные стили отменяют внешние оп
    ределения. Если в документе содержатся два и более тегов <span class="code">&lt;link></span>, бро
    узер должен представить пользователю список таблиц стилей, на кото
    рые ссылаются теги. Пользователь выбирает таблицу, которую бро
    узер загружает и применяет при форматировании документа.
    Остальные таблицы из тегов <span class="code">&lt;link></span> при этом игнорируются.</p>
<p>Если речь идет об <span class="code">@import</span>, то, напротив, всякий распознающий стили
    броузер должен слить множество указанных в директивах таблиц
    в один набор стилевых правил для документа. При возникновении ка
    кихлибо взаимных противоречий приоритет имеет последняя импор
    тированная таблица. Следовательно, если внешняя таблица стилей
    <span class="code">gen_styles.css</span> предлагает броузеру отобразить содержимое тега <span class="code">&lt;h1></span>
    синим курсивом, а spec_styles.css настаивает на красном цвете текста
    того же тега, то содержимое будет отображено красным курсивом.
    И если впоследствии мы определим для тега <span class="code">&lt;h1></span> другой цвет, скажем
    желтый, на уровне документа, тег <span class="code">&lt;h1></span> будет желтым и наклонным.
        Каскадный эффект.</p>
<p>На практике популярные броузеры обращаются с таблицами стилей,
присоединенными с помощью тега <span class="code">&lt;link></span>, так же, как с импортирован
ными таблицами, каскадным образом совмещая их действие. Броузе
ры в настоящее время не позволяют выбирать таблицу стилей. Импор
тированные стили замещают стили, присоединенные тегом <span class="code">&lt;link></span>,
точно так же, как определенные на уровне документа и встроенные
в тег стили замещают внешние определения. Собирая все это вместе,
рассмотрим пример:</p>
<pre><code >&lt;link rel=stylesheet href=sheet1.css type=text/css>
&lt;link rel=stylesheet href=sheet2.css type=text/css>
&lt;style>
    &lt;!
    @import url(sheet3.css);
    @import url(sheet4.css);
    >
&lt;/style></code></pre>
<p>В соответствии с моделью CSS2 броузер должен предложить пользова
    телю выбирать между <span class="code">sheet1.css</span> и <span class="code">sheet2.css</span>. Затем он должен загру
    зить выбранную таблицу, за которой последуют <span class="code">sheet3.css</span> и <span class="code">sheet4.css</span>.
    Стили, определенные в таблицах <span class="code">sheet3.css</span> и <span class="code">sheet4.css</span>, так же как
    и встроенные стили, будут в случае конфликта применяться вместо
    стилей выбранной таблицы. На практике популярные броузеры кас
    кадным образом объединят правила таблиц из примера, обрабатывая
    их в том порядке, в каком они появляются, от <span class="code">sheet1</span> до <span class="code">sheet4</span>.</p>
<p>Вместо этого они каскадно объединяют ука
    занные в тегах <span class="code">&lt;link></span> таблицы, так что правила каждой следующей
    таблицы сильнее правил предыдущей.</p>

<h2>Каскадность стилей</h2>
<p>Все современные браузеры поддерживают три основных типа таблиц стилей.
    В порядке приоритетности сверху вниз они располагаются следующим образом:</p>
<ol>
    <li>созданные автором документа;</li>
    <li>созданные пользователем;</li>
    <li>созданные браузером.</li>
</ol>
<p>Эти три набора таблиц стилей обрабатываются в обратном порядке. Сначала к документу применяются исходные настройки браузера. Без них веб-страницы, не использующие таблицы стилей, выглядели бы ужасно. Они включают внешний вид, размер и цвет шрифта, интервалы между элементами, обрамление и отступы в таблицах и все остальные разумные стандарты, ожидаемые пользователем.</p>
<p>Затем, если пользователь создал какие-нибудь стили, которые предпочитает применять в качестве стандартных, эти стили заменяют исходные стили браузера, с которыми они могут конфликтовать.</p>
<p>И наконец, применяются любые стили, созданные автором текущего документа, заменяя любые стили, либо созданные в качестве исходных стилей браузера, либо созданные пользователем</p>

<h2>Селекторы</h2>
<p><b>Селектор</b> - элемент разметки, который подчиняется правилу, следующему за ним двух фигурных скобок (<span class="code">{}</span>) и заключенного в этих скобках списка пар вида свойство:значение (<span class="code">property:value</span>), элементы которого разделяются точками с запятой.</p>
<!--todo: tip если значений несколько и они перечисляются через запятую, то, как правило, применяется первое допустимое. -->
<ul>
    <b>Виды селекторов:</b>
    <li><span class="code">ul</span> - селектор типа.</li>
    <li><span class="code">.class</span> - селектор класса.</li>
    <li><span class="code">ul.class1.class2</span> - селектор всех элементов класса1 и класса2 (одновременно).</li>
    <li><span class="code">ul</span> - селектор типа.</li>
    <li><span class="code">#id</span> - селектор id</li>
    <li><span class="code">ul li</span> - селектор потомка</li>
    <li><span class="code">*</span> - универсальный селектор</li>
    <li><span class="code">p>span</span> - селектор дочерних элементов в CSS.</li>
    <li><span class="code">br+em</span> - Селектор соседних элементов в CSS позволяет выбрать элементы, которые находятся непосредственно рядом друг с другом и имеют общего родителя. Он записывается через символ "+", и указывается первый элемент, за которым следует второй элемент.</li>
    <li><span class="code">a[target="_blank"]</span> - Мы выбираем все ссылки (<span class="code">&lt;a></span>), у которых атрибут <span class="code">target</span> установлен в <span class="code">"_blank"</span>, что означает, что они открываются в новой вкладке.</li>
</ul>
<p>Существует три разных способа выбора стилизуемых элементов. В порядке убывания приоритетности их список имеет такой вид.</p>
<ol>
    <li>обращение по индивидуальному идентификатору или селектор атрибутов;</li>
    <li>обращение в группах по классу;</li>
    <li>обращение по тегам элементов.</li>
</ol>
<p>Селекторы обрабатываются согласно количеству и типам элементов, подпадающих под правило, которое несколько отличается от предыдущих двух правил разрешения конфликтов. Причина состоит в том, что правила не должны сразу применяться только к одному типу селектора и могут иметь отношение к разным селекторам.</p>

<h2>Специфичность стилей</h2>
<p>Специфика правила вычисляется путем создания тернарных чисел на основе типов селекторов в показанном выше списке. Эти составные числа сначала выглядят как <span class="code">[0,0,0]</span>. При обработке правила каждый селектор, который ссылается на идентификатор, увеличивает первое число на единицу, и составное число приобретает вид <span class="code">[1,0,0]</span>.</p>
<p>Посмотрим на следующее правило. У него имеется семь ссылок, три из которых — ID-ссылки (<span class="code">#heading</span>, <span class="code">#main</span> и <span class="code">#menu</span>), поэтому составное число приобретает вид <span class="code">[3,0,0]</span>:
</p>
<pre><code >#heading #main #menu .text .quote p span {
// Здесь размещаются правила;
}</code></pre>
<p>Количество классов в селекторе помещается во второй части составного числа. В данном примере два класса (<span class="code">.text</span> и <span class="code">.quote</span>), поэтому составное число приобретает вид <span class="code">[3,2,0]</span>.</p>
<p>И наконец, вычисляется количество селекторов, ссылающихся на теги элементов, и результат помещается в последнюю часть составного числа. В нашем примере таких селекторов два (<span class="code">p</span> и <span class="code">span</span>), поэтому составное число приобретает следующий окончательный вид: <span class="code">[3,2,2]</span>.</p>
<p>Этого вполне достаточно для сравнения специфики данного правила с другими спецификами. В случаях, подобных этому, когда в составном числе набирается девять или меньше селекторов каждого типа, его можно преобразовать непосредственно в десятичное число, в нашем случае это 322. Правила с меньшим числом, чем это, будут иметь меньший приоритет, а правила с более высоким числом будут иметь больший приоритет. Когда у двух правил будет одно и то же значение, выиграет последнее из применявшихся.</p>
<p>Предположим, к примеру, что у нас также есть следующее правило:</p>
<pre><code >#heading #main .text .quote .news p span {
// Здесь размещаются правила;
}</code></pre>
<p>Здесь, несмотря на то что ссылка также идет на семь элементов, имеется только две ID-ссылки, но три ссылки на классы, в результате чего получается составное число <span class="code">[2,3,2]</span>. Поскольку <span class="code">322</span> больше, чем <span class="code">232</span>, у первого примера приоритет выше, чем у второго.</p>
<h3>Специфичность более высоких порядков</h3>
<p>Когда в составном числе набирается более девяти типов селекторов, нужно переходить к использованию «более старшей» системы. Например, составное число <span class="code">[11,7,19]</span> не подлежит преобразованию в десятичное простым объединением трех частей. Вместо этого его можно преобразовать в число с более высоким основанием системы счисления, например с основанием 20 (или выше, если будет больше 19 селекторов любого типа).</p>
<p>Для этого нужно умножить все три части и сложить результаты, как показано
    ниже, начиная с крайнего справа числа и переходя влево:</p>
<pre><code >20 х 19 = 380
20x20 х 7 = 2800
20x20x20 х 11 = 88000
Всего в десятичном виде = 91180</code></pre>

<h3>Одинаковая специфичность</h3>
<p>Когда два правила задания стилей или более имеют абсолютно одинаковый уровень приоритета, то по умолчанию будет применяться последнее обработанное правило. Но вы можете придать правилу более высокий уровень приоритета по сравнению с другими равными ему правилами, используя объявление <span class="code">!important</span>:</p>
<pre><code >p { color:#ff0000 !important; }</code></pre>
<p>При этом все предыдущие равные настройки заменяются (даже те, в которых используется объявление <span class="code">!important</span>), и любые равные правила, обрабатываемые позже, игнорируются. Например, второе из двух следующих правил в обычном случае имело бы приоритет, но из-за применения объявления <span class="code">!important</span> в ранее заданном правиле оно игнорируется:</p>
<pre><code >p { color:#ff0000 !important; }
p { color:#ffff00 }</code></pre>





<h2>Распространенные свойства</h2>
<ol>
    <li><span class="code">color</span>: Каким бы вашим веб-сайтам ни нужен цвет - от классического черного до огненного красного или океанской голубой - свойство color позволяет вам окрасить текст в любой оттенок, создавая невероятные комбинации.</li>
    <li><span class="code">font-size</span>: Это свойство позволяет вам регулировать размер шрифта на вашей веб-странице. С ним вы можете сделать текст более читаемым или, наоборот, выделить важные моменты.</li>
    <li><span class="code">margin</span> и <span class="code">padding</span>: Если ваш веб-сайт - это торт, то margin - это глазурь снаружи, а padding - нежное начинка внутри. Они позволяют вам управлять отступами и внутренним пространством элементов, чтобы создать идеальное сочетание.</li>
    <li><span class="code">background-color</span>: Выбирайте любой цвет радуги и назначайте его фону ваших элементов. Это свойство позволяет вам создавать захватывающие цветовые палитры для вашего веб-сайта.</li>
    <li><span class="code">border</span>: Если вы хотите, чтобы ваши элементы были как картины в рамках, то свойство border вам в помощь. Вы можете настраивать толщину, стиль и цвет рамок, чтобы придать элементам уникальный вид.</li>
    <li><span class="code">font-family</span>: Выбирайте шрифты как палитру для холста и придавайте вашему тексту индивидуальность. С помощью font-family вы можете использовать разные шрифты для заголовков и текста, чтобы подчеркнуть их важность.</li>
    <li><span class="code">text-align</span>: Это свойство позволяет вам выровнять текст по центру, слева, справа или по ширине контейнера. Ваш текст может быть организован так, как вы хотите.</li>
    <li><span class="code">box-shadow</span>: Если вам нужно добавить элементам объем и глубину, то box-shadow - как создание иллюзии трехмерности. Вы можете создать тени, которые сделают ваши элементы более выразительными.</li>
</ol>

<h2>Псевдоэлементы</h2>
<p> <b>Псевдоэлементы</b> в CSS - это ключевые слова, которые добавляются к селекторам для определения определенного состояния элемента. Они используются для стилизации элементов, которые находятся в определенном состоянии, например, когда пользователь наводит на элемент мышкой или когда элемент является первым или последним в своем контейнере.</p>
<p><span class="code">first-letter</span> - задает стиль первой букве слова. Пусть на нашей html-странице есть какой-нибудь абзац:</p>
<pre><code class="language-css">p:first-letter{
  color:red;}</code></pre>
<p><span class="code">first-line</span> - задает стиль первой строке текста. Пусть на нашей html-странице есть какой-нибудь абзац:</p>
<pre><code class="language-css">p:first-letter{
  color:red;
}
p:first-line{
  color:blue;
}</code></pre>
<h2>Псевдоклассы</h2>
<p>В CSS существуют четыре <b>псевдокласса</b>, они позволяют работать со ссылками. Как вы знаете, у ссылок есть четыре состояния: простая, активная, посещенная и та, на которую наведен курсор. Состояние ссылок зависит от действия пользователя, и браузер, в зависимости от этих действий может применять разные стили. Для описания этих стилей и существуют псевдоклассы.</p>
<ul>
    <li><span class="code">a:link</span> - задает стиль обычной ссылки.</li>
    <li><span class="code">a:active</span> - задает стиль активной ссылки.</li>
    <li><span class="code">a:visited</span> - задает стиль посещенной ссылки.</li>
    <li><span class="code">a:hover</span> - задает стиль ссылки, на которую наведен курсор.</li>
</ul>
<p>Теперь, давайте зададим стиль для ссылки, на которую наведен курсор. Пусть она становится красного цвета:</p>
<pre><code class="language-css">a{
  color:green;
  text-decoration:none;
}
a:hover{
  color:red;
}</code></pre>
<p><span class="code">:first-child</span> - этот псевдокласс выбирает первый дочерний элемент внутри своего родительского контейнера.</p>
<pre><code >li:nth-child(even) {
  background-color: lightgray;
}</code></pre>
<p><span class="code">:odd</span> - этот псевдокласс выбирает каждый нечетный элемент в родительском контейнере.</p>
<pre><code >li:nth-child(odd) {
  font-weight: bold;
}</code></pre>
<p><span class="code">:nth-child(2n)</span> - этот псевдокласс выбирает каждый элемент с четным индексом (2n) внутри родительского контейнера.</p>
<pre><code class="language-css">li:nth-child(2n) {
  text-decoration: underline;
}</code></pre>

<h3>Псевдоклассы <span class="code">&lt;a></span></h3>
<p>Популярные, поддерживающие стандарт CSS2 браузеры различают
три специальных состояния гиперссылок, созданных при помощи тега
<span class="code">&lt;a></span>:
<ul>
    <li><i>неиспользованная</i> (<span class="code">a:link</span>) управляет внешним видом ссылок, которые не выбраны пользователем и не посещались прежде.</li>
    <li><i>используемая</i> (<span class="code">a:active</span>) определяет внешний вид гиперссылок, которые в настоящий момент выбраны и обрабатываются броузером.</li>
    <li><i>использованная</i> (<span class="code">a:visited</span>) устанавливает облик ссылок, которые ранее уже были использованы</li>
</ul>
<p>Чтобы полностью определить все три состояния тега <span class="code">&lt;a></span>, можно написать:</p>
<pre><code >a:link {color: blue}
a:active {color: red; font	weight: bold}
a:visited {color: green}</code></pre>
Стандарт CSS2 определяет два псевдокласса, которые вместе <span class="code">:active</span> реагируют на поступки пользователя и советуют интерактивному агенту, скажем браузеру, как отображать элемент, подвергнувшийся внешнему воздействию. Другими словами, эти два псевдокласса являются динамическими: <span class="code">:hover</span> и <span class="code">:focus</span>.
<p>Если вы добавите псевдокласс <span class="code">:hover</span> к списку стилевых правил для гиперссылки из нашего примера:</p>
<pre><code>a:hover {color: yellow}</code></pre>
<p>Подобным образом псевдокласс <span class="code">:focus</span> позволяет изменить стиль элемента, который стал объектом внимания. Элемент может попасть в сферу обзора, если вы дошли до него, нажимая клавишу «Tab», щелкнули на нем мышью или – в зависимости от броузера – подвели к нему курсор. Независимо от способа, каким ему уделено внимание, стилевое
правило, ассоциированное с псевдоклассом <span class="code">:focus</span>, будет применяться к этому элементу, пока вы не утратите к нему интереса.</p>

<h2>Наследование у классов</h2>
<p>Классы наследуют свойства стиля от своих базовых тегов. К примеру, каждое свойство обычного тега <span class="code">&lt;p></span> применяется к специально установленному классу абзацев, если класс не переопределяет этого свойства. </p>
<p>Классы не могут наследовать от других классов, а только от «свободного» тега. Таким образом, как можно большее число стилевых свойств необходимо определить в спецификациях тега, а в правила классов включать только те из них, что специфичны для данного класса. Это упростит поддержание и совместное использование стилевых классов, особенно в случае больших собраний документов.</p>

<h2>Стилевые свойства</h2>
Стандарт разбивает эти свойства на шесть групп:
<ol>
    <li>шрифт</li>
    <li>фон и цвет</li>
    <li>текст</li>
    <li>рамка и макет</li>
    <li>списки</li>
    <li>классификация тегов</li>
</ol>


<h2>Добавление контента с помощью CSS</h2>
<ol>
    <li><span class="code">a[href^="http://"]::after</span> и <span class="code">a[href^="https://"]::after</span> - Мы выбираем все ссылки (&lt;a>), у которых href начинается с "http://" или "https://". Это позволяет нам выбрать все внешние ссылки.</li>
    <li><span class="code">content: " →";</span> - мы добавляем символ "→" после каждой внешней ссылки, что делает её выдающейся на космической карте.</li>
    <li><span class="code"></span></li>
</ol>
<pre><code class="language-css">a[href^="http://"]::after,
a[href^="https://"]::after {
  content: " →";
  color: blue;
}</code></pre>
<p></p>
<pre><code class="language-css"></code></pre>

background-color
<div style="background: rgba(0, 128, 0, 0.1)">
    <p>10% Прозрачность</p>
</div>
<div style="background: rgba(0, 128, 0, 0.3)">
    <p>30% Прозрачность</p>
</div>
<div style="background: rgba(0, 128, 0, 0.6)">
    <p>60% Прозрачность</p>
</div>
background-image: url(адрес_изображения);
background-repeat
background-attachment
background-position.

<h2>Позиционирование элементов</h2>
<p>Элементы попадают на веб-страницу туда, где они находятся в документе, но
могут перемещаться путем изменения свойства позиции элемента от исходной
статической (<span class="code">static</span>) до абсолютной (<span class="code">absolute</span>), относительной (<span class="code">relative</span>),
прилипчивой (<span class="code">sticky</span>) или фиксированной (<span class="code">fixed</span>).</p>
<h3>Абсолютное позиционирование</h3>
<p>Элемент с абсолютным позиционированием удаляется из документа, и любые
другие элементы, которые в состоянии это сделать, займут освободившееся
пространство. Затем вы можете позиционировать объект в любое нужное место
в документе, используя свойства «верх» — <span class="code">top</span>, «право» — <span class="code">right</span>, «низ» — <span class="code">bottom</span>
и «лево» — <span class="code">left</span>.</p>
<p>Например, для перемещения объекта с ID, имеющим значение object, в абсолютное место, находящееся на 100 пикселов ниже начала документа и на 200 пикселов от левого края, к нему нужно применить следующие правила (вы также
можете использовать любые другие единицы измерений, поддерживаемые CSS):</p>
<pre><code >#object {
position:absolute;
top :100px;
left :200px;
}</code></pre>
<p>Объект будет располагаться либо поверх других элементов, либо за другими,
перекрывающими его элементами, в зависимости от значения, присвоенного
свойству <span class="code">z-index</span> (которое работает только в отношении позиционированных
элементов). По умолчанию это свойство имеет значение auto, присваиваемое
браузером без вашего участия. Вместо этого вы можете дать этому свойству
целочисленное значение (которое может быть и отрицательным):</p>
<pre><code >#object {
position:absolute;
top :100px;
left :200px;
z-index:100;
}</code></pre>
<p>После этого объекты будут появляться на экране в порядке от самого низкого
и до самого высокого значения их свойства <span class="code">z-index</span>, при этом объекты с более
высокими значениями станут отображаться поверх объектов с более низкими
значениями. По умолчанию значение <span class="code">z-index</span> для элемента <span class="code">html</span> равно <span class="code">0</span>, все
остальные значения по умолчанию являются автоматическими.</p>
<h3>Относительное позиционирование</h3>
<p>Подобным образом можно переместить объект относительно того места, которое
он занимал бы при обычном ходе формирования документа. Так, например, для
перемещения объекта на 10 пикселов вниз и 10 пикселов вправо от его обычного
положения нужно воспользоваться следующими правилами:</p>
<pre><code >#object {
position:relative;
top :10px;
left :10px;
}</code></pre>
<h3>Фиксированное позиционирование</h3>
<p>Заключительные настройки свойства <span class="code">position</span> позволяют переместить объект
в абсолютное положение, но только внутри окна просмотра текущего браузера.
Затем при прокрутке документа объект остается именно там, куда он был помещен, а основной документ будет прокручиваться под ним — это неплохой способ создания док-панелей и других подобных устройств. Для фиксирования
объекта в левом верхнем углу браузера нужно воспользоваться следующими
правилами:</p>
<pre><code >#object {
position:fixed;
top :0px;
left :0px;
}</code></pre>
После прокрутки тут же выяснится, что элемент с фиксированной позицией
(object3) останется на своем месте, несмотря на прокрутку. Также можно будет
наблюдать, что элемент-контейнер (по имени container) обладает абсолютным
позиционированием и размещается в точности на 50 пикселов ниже, с горизонтальным смещением 0 пикселов, поэтому элемент object1 (имеющий абсолютное позиционирование внутри элемента container) появляется именно в этом
месте. А элемент object2 имеет относительное позиционирование, поэтому он
смещен от левой границы элемента container на 110 пикселов, выстраиваясь
рядом с элементом object1.
Показанный на рисунке элемент object3, несмотря на то что он в коде HTML
появляется внутри элемента container, имеет фиксированное позиционирование, в результате чего он фактически совершенно независим от других объектов
и не скован границами элемента container. Изначально он был настроен на
нахождение на одной линии с элементами object1 и object2, но остался на месте,
в то время как другие элементы были прокручены вверх по странице, и теперь
object3 смещен ниже этих элементов.


Какой тип таблиц стилей применять и когда
Раз уж вы решили применять каскадные таблицы стилей (на горе себе
или на радость), следующим вопросом будет, какого типа стили –
встроенные, определенные таблицами на уровне документа или внеш
ние – следует употреблять и когда? У каждого типа есть свои достоин
ства и недостатки. Каждый из них лучше всего подходит в определен
ных обстоятельствах.
8.6.2.1. Достоинства и недостатки внешних таблиц
Когда таблицы стилей должны обеспечить стилистическое единство
документов, внешние таблицы позволяют наилучшим и самым лег
ким способом управлять стилями во всем собрании документов. Про
сто внесите нужное стилевое правило в таблицу стилей и примените их
к нужным документам. И поскольку одна таблица стилей действует на
все документы, преобразование всего собрания к новому стилю ока
жется не труднее, чем изменение одного стилевого правила в соответ
ствующей внешней таблице.
Даже в том случае, когда документы могут различаться по стилю, час
то оказывается возможным собрать несколько основных правил в одну
таблицу, которой смогут совместно пользоваться несколько докумен
тов, различных в остальных отношениях. Эти стилевые правила могут
включать в себя:
• Цвет фона
• Фоновое изображение
• Размеры и начертания шрифтов
• Поля
• Выравнивание текста
Еще одно преимущество употребления таблиц стилей состоит в том,
что другие авторы сетевых документов, которые захотят скопировать
ваш стиль, могут с легкостью получить такую таблицу и сделать свои
страницы похожими на ваши. Подражание – это самая искренняя
форма лести, так что не стоит огорчаться, что ктото решил сымитиро
вать внешний облик и характер ваших страниц. Более того, вы не смо
жете защитить свои таблицы от подключения, так что расслабьтесь.
Как и обычные HTMLдокументы, таблицы стилей нельзя зашифро
вать или както еще спрятать, чтобы окружающие не могли их видеть
и пользоваться ими.
Самая большая проблема с внешними таблицами стилей заключается
в том, что они увеличивают время, необходимое для получения досту
па к странице. Мало того, что броузер должен ее загрузить, он должен
также загрузить таблицу перед тем, как страницу удастся представить
на обозрение. Хотя большинство таблиц стилей относительно невели
ки, их присутствие можно с определенностью ощутить, когда соедине
ние с сетью медленное.
Без соответствующей дисциплины внешние таблицы быстро становят
ся большими и громоздкими. При их создании помните, что включать
в таблицы следует только стили, общие для всех обращающихся к ней
документов. Если ряд стилевых правил употребляется только одним
или двумя документами, лучше выделить их в отдельную таблицу или
вставить в документ, используя стили на его уровне. В противном слу
чае вы можете обнаружить, что тратите непомерно много усилий на
нейтрализацию действия внешних стилей во множестве отдельных до
кументов.
8.6.2.2. Достоинства и недостатки определения стилей
на уровне документа
Определение стиля на уровне документа полезней всего при подгонке
документа под особые требования. Такие определения позволяют пе
реиначить одно или несколько правил, определенных во внешних таб
лицах, чтобы создать слегка отличающийся документ.
Иногда хочется попробовать новые стилевые правила на уровне доку
мента, прежде чем применять их в таблицах стилей. Добавляя и изме
няя правила на уровне документа, вы избегаете риска поместить во
внешнюю таблицу плохо или совсем не работающий стиль, который
испортит внешний вид всех документов, применяющих эту таблицу.
Самая большая проблема таблиц на уровне документа состоит в том,
что можно поддаться соблазну использовать только их, вместо того
чтобы создать правильную внешнюю таблицу для управления всей
коллекцией. Это так легко – добавлять правила в новый документ при
его создании – вырезал и вставил. К несчастью, управление собранием
документов со стилями, определенными на уровне документа, – это
скучное и чреватое ошибками занятие. Внесение даже простого изме
нения может потребовать нескольких часов редактирования (с воз
можными ошибками).
В качестве рабочего подхода можно принять, что любое правило, кото
рое используется тремя или большим числом документов, следует вы
нести во внешнюю таблицу стилей и применить к ним с помощью тега
<link> или команды @import. Приверженность этому правилу при соз
дании семейств документов окупит себя со временем, когда придет
время менять стили.
8.6.2.3. Достоинства и недостатки встроенных стилей
И наконец, расположенные в самом низу каскада встроенные в теги
стили могут переопределить более общие стили. Возьмите в привычку
употреблять встроенные стили редко и только для этой цели. Встроен
ные стили не подлежат повторному использованию, что приводит к бо
лее трудному контролю над ними. Кроме того, нужные изменения раз
бросаны по всему документу, а это делает обнаружение и правку встро
енных стилей источником ошибок.
Всякий раз, применяя встроенные стили, хорошо подумайте, нельзя
ли достичь того же результата, используя определение класса стилей.
К примеру, лучше написать:
<style type="text/css">
    <!
    p.centered {text	align: center}
    em.blue {color: blue}
    >
</style>
а затем применить это определение:
<p class=centered>
    <em class=blue>
        чем использовать эквивалентную по результату конструкцию:
<p style="text	align: center">
    <em style="color: blue">
        Классы стилей легче находить и обслуживать, и их можно употреб
        лять повторно в других документах.


































</body>
</html>