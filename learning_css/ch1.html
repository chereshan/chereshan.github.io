<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Глава 1. Введение в CSS</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../modules/jquery-3.7.1.min.js"><'+'/script>')</script>
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
    <style>
        @import url("../styles/styles.css");
        @import url("../modules/vs2015.min.css");
    </style>

</head>
<body>
<script src="../common/counters_body.js"></script>
<h1>Глава 1. Введение в CSS</h1>
<!--todo: regex-калькулятор специфичности стилей-->
<h2>Размещение CSS-стилей</h2>
<p>Таблицы стилей могут создаваться с помощью трех различных методов. Если
    расположить их в порядке приоритетности сверху вниз, получится следующий
    список.</p>
<ol>
    <li>внедренные стили;</li>
    <li>встроенная таблица стилей;</li>
    <li>внешняя таблица стилей.</li>
</ol>
<p>Эти методы создания таблиц стилей также применяются в порядке, обратном порядку их приоритетности. Поэтому сначала обрабатываются все внешние таблицы стилей, и к документу применяются их стили.</p>
<p>Затем обрабатываются любые встроенные стили (которые находятся внутри тегов <span class="code">&lt;style>...&lt;/style></span>). Все, что конфликтует с внешними правилами, получает приоритет и заменяет эти правила.</p>
<p>И наконец, наивысший приоритет получают любые стили, применяемые непосредственно к элементу в качестве внедренного стиля (такие, как
<span class="code">&lt;div style="...">...&lt;/div></span>), которые заменяют все предыдущие заданные
свойства.</p>

<p>Стили CSS также можно разместить внутри документа напрямую внутри содержимого style-тега в head документа.</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;style type = "text/css"&gt;
            body p
            {   background: white;
                color: black;
                font-family: Arial, sans-serif;
                font-size: 16px;
                line-height: 1.58;
                text-rendering: optimizeLegibility;
                -webkit-font-smoothing: antialiased;}
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;CSS-стили внутри элемента style и применяются к этому абзацу в HTML-коде веб-страницы&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>CSS-стиль также можно задать для конкретного элемента документа.</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body style = "font-family: Arial;"&gt;
    &lt;p&gt;При выводе в браузере этот абзац наследует форматирование шрифтом Arial из строкового стиля в родительском элементе.&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>



<p>Когда стиль нужно применить не к одной странице, а ко всему сайту, лучше управлять таблицами стилей путем их полного перемещения из веб-страниц в отдельные файлы с последующим импортом той таблицы, которая вам нужна. Тем самым предоставляется возможность применения разных таблиц стилей к разным форматам подачи информации (например, в варианте просматриваемой веб-страницы и в варианте вывода на печать) без изменения HTML.</p>
<p>Код CSS можно разместить в отдельном документе, а затем подключить его к HTML-документу с помощью link-тега в head-разделе документа.</p>
<pre><code class="language-html">&lt;link rel = "stylesheet"
    type = "text/css"
    href = "style.css"&gt;</code></pre>
<p>Все каскадные таблицы стилей имеют тип
    <span class="code">text/css</span>. Таблицы стилей JavaScript применяют тип <span class="code">text/javascript</span>.
    Можно опустить данный атрибут и надеяться, что броузер сам поймет,
    какой тип используется.</p>
<p>Напомним, что тег <span class="code">&lt;link></span> связывает документ, в котором он содержит
    ся, с какимто другим документом в сети. В примере мы сообщаем бро
    узеру, что документ, поименованный в атрибуте <span class="code">href</span>, имеет тип
    <span class="code">stylesheet</span>, как это указано в атрибуте <span class="code">type</span>. Ссылка на внешнюю табли
    цу стилей в теге <span class="code">&lt;link></span> требует указания атрибутов href и <span class="code">type</span>. Кроме
    того, мы явно, причем добровольно, сообщаем броузеру, что отношение файла к нашему документу определяется значением <span class="code">stylesheet</span>
    (таблица стилей)</p>



<p>Другим способом применения стилей для всей страницы является использование директивы <span class="code">@import url("адрес стиля")</span>. Результат использования <span class="code">@import</span> будет точно таким же, как и при использовании <span class="code">&lt;link></span> , но <span class="code">&lt;link></span> является тегом, применяемым только в HTML, и не относится к стилевым директивам, поэтому он не может задействоваться в одной таблице стилей для импорта другой такой таблицы. Он также не может помещаться внутри пары тегов <span class="code">&lt;style>...&lt;/style></span>.</p>
<p>На эту страницу стили вызываются следующим образом:</p>
<pre><code >&lt;style>
    @import url("../styles/styles.css");
    @import url("../modules/vs2015.min.css");
&lt;/style></code></pre>
<p>Директива <span class="code">@import</span> ожидает параметр в виде URL, указывающего путь
    в сети к внешней таблице стилей. Как показано в этом примере, URL
    может быть заключенной в двойные кавычки строкой, заканчиваю
    щейся точкой с запятой, или следовать за ключевым словом <span class="code">url</span>, так
    же оканчиваясь точкой с запятой, но помещаясь при этом в скобки.
    URL может быть абсолютным или относительным, отсчитываемым от
    базового URL документа.</p>
<p>Директива <span class="code">@import</span> может появиться в определениях стиля на уровне
    документа или даже в другой таблице стилей, что позволяет создавать
    вложенные таблицы стилей.</p>
<p>Таким образом, способ с <span class="code">@import</span> также является предпочтительным.</p>

<!--todo: у автооглавления главы есть проблема с выводом тегов в именах глав-->
<h3><span class="code">&lt;link></span> или <span class="code">@import</span>?</h3>
<p>На первый взгляд может показаться, что способы присоединения таб
лиц стилей, использующие тег <span class="code">&lt;link></span> и директиву <span class="code">@import</span>, эквивалент
ны и применяют различный синтаксис для достижения одной и той же
цели. Это так, если в документе только один тег <span class="code">&lt;link></span>. Когда их боль
ше, в игру вступают специальные правила CSS.</p>
<p>Когда в документе содержится один тег <span class="code">&lt;link></span>, броузер должен загру
    зить стили из таблицы, на которую ссылается тег, и в соответствии
    с ними провести форматирование, учитывая, что при конфликте уста
    новки на уровне документа и встроенные стили отменяют внешние оп
    ределения. Если в документе содержатся два и более тегов <span class="code">&lt;link></span>, бро
    узер должен представить пользователю список таблиц стилей, на кото
    рые ссылаются теги. Пользователь выбирает таблицу, которую бро
    узер загружает и применяет при форматировании документа.
    Остальные таблицы из тегов <span class="code">&lt;link></span> при этом игнорируются.</p>
<p>Если речь идет об <span class="code">@import</span>, то, напротив, всякий распознающий стили
    броузер должен слить множество указанных в директивах таблиц
    в один набор стилевых правил для документа. При возникновении ка
    кихлибо взаимных противоречий приоритет имеет последняя импор
    тированная таблица. Следовательно, если внешняя таблица стилей
    <span class="code">gen_styles.css</span> предлагает броузеру отобразить содержимое тега <span class="code">&lt;h1></span>
    синим курсивом, а spec_styles.css настаивает на красном цвете текста
    того же тега, то содержимое будет отображено красным курсивом.
    И если впоследствии мы определим для тега <span class="code">&lt;h1></span> другой цвет, скажем
    желтый, на уровне документа, тег <span class="code">&lt;h1></span> будет желтым и наклонным.
        Каскадный эффект.</p>
<p>На практике популярные броузеры обращаются с таблицами стилей,
присоединенными с помощью тега <span class="code">&lt;link></span>, так же, как с импортирован
ными таблицами, каскадным образом совмещая их действие. Броузе
ры в настоящее время не позволяют выбирать таблицу стилей. Импор
тированные стили замещают стили, присоединенные тегом <span class="code">&lt;link></span>,
точно так же, как определенные на уровне документа и встроенные
в тег стили замещают внешние определения. Собирая все это вместе,
рассмотрим пример:</p>
<pre><code >&lt;link rel=stylesheet href=sheet1.css type=text/css>
&lt;link rel=stylesheet href=sheet2.css type=text/css>
&lt;style>
    &lt;!
    @import url(sheet3.css);
    @import url(sheet4.css);
    >
&lt;/style></code></pre>
<p>В соответствии с моделью CSS2 броузер должен предложить пользова
    телю выбирать между <span class="code">sheet1.css</span> и <span class="code">sheet2.css</span>. Затем он должен загру
    зить выбранную таблицу, за которой последуют <span class="code">sheet3.css</span> и <span class="code">sheet4.css</span>.
    Стили, определенные в таблицах <span class="code">sheet3.css</span> и <span class="code">sheet4.css</span>, так же как
    и встроенные стили, будут в случае конфликта применяться вместо
    стилей выбранной таблицы. На практике популярные броузеры кас
    кадным образом объединят правила таблиц из примера, обрабатывая
    их в том порядке, в каком они появляются, от <span class="code">sheet1</span> до <span class="code">sheet4</span>.</p>
<p>Вместо этого они каскадно объединяют ука
    занные в тегах <span class="code">&lt;link></span> таблицы, так что правила каждой следующей
    таблицы сильнее правил предыдущей.</p>

<h2>Каскадность стилей</h2>
<p>Все современные браузеры поддерживают три основных типа таблиц стилей.
    В порядке приоритетности сверху вниз они располагаются следующим образом:</p>
<ol>
    <li>созданные автором документа;</li>
    <li>созданные пользователем;</li>
    <li>созданные браузером.</li>
</ol>
<p>Эти три набора таблиц стилей обрабатываются в обратном порядке. Сначала к документу применяются исходные настройки браузера. Без них веб-страницы, не использующие таблицы стилей, выглядели бы ужасно. Они включают внешний вид, размер и цвет шрифта, интервалы между элементами, обрамление и отступы в таблицах и все остальные разумные стандарты, ожидаемые пользователем.</p>
<p>Затем, если пользователь создал какие-нибудь стили, которые предпочитает применять в качестве стандартных, эти стили заменяют исходные стили браузера, с которыми они могут конфликтовать.</p>
<p>И наконец, применяются любые стили, созданные автором текущего документа, заменяя любые стили, либо созданные в качестве исходных стилей браузера, либо созданные пользователем</p>

<h2>Селекторы</h2>
<p><b>Селектор</b> - элемент разметки, который подчиняется правилу, следующему за ним двух фигурных скобок (<span class="code">{}</span>) и заключенного в этих скобках списка пар вида свойство:значение (<span class="code">property:value</span>), элементы которого разделяются точками с запятой.</p>
<!--todo: tip если значений несколько и они перечисляются через запятую, то, как правило, применяется первое допустимое. -->
<ul>
    <b>Виды селекторов:</b>
    <li><span class="code">ul</span> - селектор типа.</li>
    <li><span class="code">.class</span> - селектор класса.</li>
    <li><span class="code">ul.class1.class2</span> - селектор всех элементов класса1 и класса2 (одновременно).</li>
    <li><span class="code">ul</span> - селектор типа.</li>
    <li><span class="code">#id</span> - селектор id</li>
    <li><span class="code">ul li</span> - селектор потомка</li>
    <li><span class="code">*</span> - универсальный селектор</li>
    <li><span class="code">p>span</span> - селектор дочерних элементов в CSS.</li>
    <li><span class="code">br+em</span> - Селектор соседних элементов в CSS позволяет выбрать элементы, которые находятся непосредственно рядом друг с другом и имеют общего родителя. Он записывается через символ "+", и указывается первый элемент, за которым следует второй элемент.</li>
    <li><span class="code">a[target="_blank"]</span> - Мы выбираем все ссылки (<span class="code">&lt;a></span>), у которых атрибут <span class="code">target</span> установлен в <span class="code">"_blank"</span>, что означает, что они открываются в новой вкладке.</li>
</ul>
<p>Существует три разных способа выбора стилизуемых элементов. В порядке убывания приоритетности их список имеет такой вид.</p>
<ol>
    <li>обращение по индивидуальному идентификатору или селектор атрибутов;</li>
    <li>обращение в группах по классу;</li>
    <li>обращение по тегам элементов.</li>
</ol>
<p>Селекторы обрабатываются согласно количеству и типам элементов, подпадающих под правило, которое несколько отличается от предыдущих двух правил разрешения конфликтов. Причина состоит в том, что правила не должны сразу применяться только к одному типу селектора и могут иметь отношение к разным селекторам.</p>

<h2>Специфичность стилей</h2>
<p>Специфика правила вычисляется путем создания тернарных чисел на основе типов селекторов в показанном выше списке. Эти составные числа сначала выглядят как <span class="code">[0,0,0]</span>. При обработке правила каждый селектор, который ссылается на идентификатор, увеличивает первое число на единицу, и составное число приобретает вид <span class="code">[1,0,0]</span>.</p>
<p>Посмотрим на следующее правило. У него имеется семь ссылок, три из которых — ID-ссылки (<span class="code">#heading</span>, <span class="code">#main</span> и <span class="code">#menu</span>), поэтому составное число приобретает вид <span class="code">[3,0,0]</span>:
</p>
<pre><code >#heading #main #menu .text .quote p span {
// Здесь размещаются правила;
}</code></pre>
<p>Количество классов в селекторе помещается во второй части составного числа. В данном примере два класса (<span class="code">.text</span> и <span class="code">.quote</span>), поэтому составное число приобретает вид <span class="code">[3,2,0]</span>.</p>
<p>И наконец, вычисляется количество селекторов, ссылающихся на теги элементов, и результат помещается в последнюю часть составного числа. В нашем примере таких селекторов два (<span class="code">p</span> и <span class="code">span</span>), поэтому составное число приобретает следующий окончательный вид: <span class="code">[3,2,2]</span>.</p>
<p>Этого вполне достаточно для сравнения специфики данного правила с другими спецификами. В случаях, подобных этому, когда в составном числе набирается девять или меньше селекторов каждого типа, его можно преобразовать непосредственно в десятичное число, в нашем случае это 322. Правила с меньшим числом, чем это, будут иметь меньший приоритет, а правила с более высоким числом будут иметь больший приоритет. Когда у двух правил будет одно и то же значение, выиграет последнее из применявшихся.</p>
<p>Предположим, к примеру, что у нас также есть следующее правило:</p>
<pre><code >#heading #main .text .quote .news p span {
// Здесь размещаются правила;
}</code></pre>
<p>Здесь, несмотря на то что ссылка также идет на семь элементов, имеется только две ID-ссылки, но три ссылки на классы, в результате чего получается составное число <span class="code">[2,3,2]</span>. Поскольку <span class="code">322</span> больше, чем <span class="code">232</span>, у первого примера приоритет выше, чем у второго.</p>
<h3>Специфичность более высоких порядков</h3>
<p>Когда в составном числе набирается более девяти типов селекторов, нужно переходить к использованию «более старшей» системы. Например, составное число <span class="code">[11,7,19]</span> не подлежит преобразованию в десятичное простым объединением трех частей. Вместо этого его можно преобразовать в число с более высоким основанием системы счисления, например с основанием 20 (или выше, если будет больше 19 селекторов любого типа).</p>
<p>Для этого нужно умножить все три части и сложить результаты, как показано
    ниже, начиная с крайнего справа числа и переходя влево:</p>
<pre><code >20 х 19 = 380
20x20 х 7 = 2800
20x20x20 х 11 = 88000
Всего в десятичном виде = 91180</code></pre>

<h3>Одинаковая специфичность</h3>
<p>Когда два правила задания стилей или более имеют абсолютно одинаковый уровень приоритета, то по умолчанию будет применяться последнее обработанное правило. Но вы можете придать правилу более высокий уровень приоритета по сравнению с другими равными ему правилами, используя объявление <span class="code">!important</span>:</p>
<pre><code >p { color:#ff0000 !important; }</code></pre>
<p>При этом все предыдущие равные настройки заменяются (даже те, в которых используется объявление <span class="code">!important</span>), и любые равные правила, обрабатываемые позже, игнорируются. Например, второе из двух следующих правил в обычном случае имело бы приоритет, но из-за применения объявления <span class="code">!important</span> в ранее заданном правиле оно игнорируется:</p>
<pre><code >p { color:#ff0000 !important; }
p { color:#ffff00 }</code></pre>





<h2>Распространенные свойства</h2>
<ol>
    <li><span class="code">color</span>: Каким бы вашим веб-сайтам ни нужен цвет - от классического черного до огненного красного или океанской голубой - свойство color позволяет вам окрасить текст в любой оттенок, создавая невероятные комбинации.</li>
    <li><span class="code">font-size</span>: Это свойство позволяет вам регулировать размер шрифта на вашей веб-странице. С ним вы можете сделать текст более читаемым или, наоборот, выделить важные моменты.</li>
    <li><span class="code">margin</span> и <span class="code">padding</span>: Если ваш веб-сайт - это торт, то margin - это глазурь снаружи, а padding - нежное начинка внутри. Они позволяют вам управлять отступами и внутренним пространством элементов, чтобы создать идеальное сочетание.</li>
    <li><span class="code">background-color</span>: Выбирайте любой цвет радуги и назначайте его фону ваших элементов. Это свойство позволяет вам создавать захватывающие цветовые палитры для вашего веб-сайта.</li>
    <li><span class="code">border</span>: Если вы хотите, чтобы ваши элементы были как картины в рамках, то свойство border вам в помощь. Вы можете настраивать толщину, стиль и цвет рамок, чтобы придать элементам уникальный вид.</li>
    <li><span class="code">font-family</span>: Выбирайте шрифты как палитру для холста и придавайте вашему тексту индивидуальность. С помощью font-family вы можете использовать разные шрифты для заголовков и текста, чтобы подчеркнуть их важность.</li>
    <li><span class="code">text-align</span>: Это свойство позволяет вам выровнять текст по центру, слева, справа или по ширине контейнера. Ваш текст может быть организован так, как вы хотите.</li>
    <li><span class="code">box-shadow</span>: Если вам нужно добавить элементам объем и глубину, то box-shadow - как создание иллюзии трехмерности. Вы можете создать тени, которые сделают ваши элементы более выразительными.</li>
</ol>

<h2>Псевдоэлементы</h2>
<p> <b>Псевдоэлементы</b> в CSS - это ключевые слова, которые добавляются к селекторам для определения определенного состояния элемента. Они используются для стилизации элементов, которые находятся в определенном состоянии, например, когда пользователь наводит на элемент мышкой или когда элемент является первым или последним в своем контейнере.</p>
<p><span class="code">first-letter</span> - задает стиль первой букве слова. Пусть на нашей html-странице есть какой-нибудь абзац:</p>
<pre><code class="language-css">p:first-letter{
  color:red;}</code></pre>
<p><span class="code">first-line</span> - задает стиль первой строке текста. Пусть на нашей html-странице есть какой-нибудь абзац:</p>
<pre><code class="language-css">p:first-letter{
  color:red;
}
p:first-line{
  color:blue;
}</code></pre>
<h2>Псевдоклассы</h2>
<p>В CSS существуют четыре <b>псевдокласса</b>, они позволяют работать со ссылками. Как вы знаете, у ссылок есть четыре состояния: простая, активная, посещенная и та, на которую наведен курсор. Состояние ссылок зависит от действия пользователя, и браузер, в зависимости от этих действий может применять разные стили. Для описания этих стилей и существуют псевдоклассы.</p>
<ul>
    <li><span class="code">a:link</span> - задает стиль обычной ссылки.</li>
    <li><span class="code">a:active</span> - задает стиль активной ссылки.</li>
    <li><span class="code">a:visited</span> - задает стиль посещенной ссылки.</li>
    <li><span class="code">a:hover</span> - задает стиль ссылки, на которую наведен курсор.</li>
</ul>
<p>Теперь, давайте зададим стиль для ссылки, на которую наведен курсор. Пусть она становится красного цвета:</p>
<pre><code class="language-css">a{
  color:green;
  text-decoration:none;
}
a:hover{
  color:red;
}</code></pre>
<p><span class="code">:first-child</span> - этот псевдокласс выбирает первый дочерний элемент внутри своего родительского контейнера.</p>
<pre><code >li:nth-child(even) {
  background-color: lightgray;
}</code></pre>
<p><span class="code">:odd</span> - этот псевдокласс выбирает каждый нечетный элемент в родительском контейнере.</p>
<pre><code >li:nth-child(odd) {
  font-weight: bold;
}</code></pre>
<p><span class="code">:nth-child(2n)</span> - этот псевдокласс выбирает каждый элемент с четным индексом (2n) внутри родительского контейнера.</p>
<pre><code class="language-css">li:nth-child(2n) {
  text-decoration: underline;
}</code></pre>

<h3>Псевдоклассы <span class="code">&lt;a></span></h3>
<p>Популярные, поддерживающие стандарт CSS2 браузеры различают
три специальных состояния гиперссылок, созданных при помощи тега
<span class="code">&lt;a></span>:
<ul>
    <li><i>неиспользованная</i> (<span class="code">a:link</span>) управляет внешним видом ссылок, которые не выбраны пользователем и не посещались прежде.</li>
    <li><i>используемая</i> (<span class="code">a:active</span>) определяет внешний вид гиперссылок, которые в настоящий момент выбраны и обрабатываются броузером.</li>
    <li><i>использованная</i> (<span class="code">a:visited</span>) устанавливает облик ссылок, которые ранее уже были использованы</li>
</ul>
<p>Чтобы полностью определить все три состояния тега <span class="code">&lt;a></span>, можно написать:</p>
<pre><code >a:link {color: blue}
a:active {color: red; font	weight: bold}
a:visited {color: green}</code></pre>
Стандарт CSS2 определяет два псевдокласса, которые вместе <span class="code">:active</span> реагируют на поступки пользователя и советуют интерактивному агенту, скажем браузеру, как отображать элемент, подвергнувшийся внешнему воздействию. Другими словами, эти два псевдокласса являются динамическими: <span class="code">:hover</span> и <span class="code">:focus</span>.
<p>Если вы добавите псевдокласс <span class="code">:hover</span> к списку стилевых правил для гиперссылки из нашего примера:</p>
<pre><code>a:hover {color: yellow}</code></pre>
<p>Подобным образом псевдокласс <span class="code">:focus</span> позволяет изменить стиль элемента, который стал объектом внимания. Элемент может попасть в сферу обзора, если вы дошли до него, нажимая клавишу «Tab», щелкнули на нем мышью или – в зависимости от броузера – подвели к нему курсор. Независимо от способа, каким ему уделено внимание, стилевое
правило, ассоциированное с псевдоклассом <span class="code">:focus</span>, будет применяться к этому элементу, пока вы не утратите к нему интереса.</p>

<h2>Наследование у классов</h2>
<p>Классы наследуют свойства стиля от своих базовых тегов. К примеру, каждое свойство обычного тега <span class="code">&lt;p></span> применяется к специально установленному классу абзацев, если класс не переопределяет этого свойства. </p>
<p>Классы не могут наследовать от других классов, а только от «свободного» тега. Таким образом, как можно большее число стилевых свойств необходимо определить в спецификациях тега, а в правила классов включать только те из них, что специфичны для данного класса. Это упростит поддержание и совместное использование стилевых классов, особенно в случае больших собраний документов.</p>

<h2>Стилевые свойства</h2>
Стандарт разбивает эти свойства на шесть групп:
<ol>
    <li>шрифт</li>
    <li>фон и цвет</li>
    <li>текст</li>
    <li>рамка и макет</li>
    <li>списки</li>
    <li>классификация тегов</li>
</ol>


<h2>Добавление контента с помощью CSS</h2>
<ol>
    <li><span class="code">a[href^="http://"]::after</span> и <span class="code">a[href^="https://"]::after</span> - Мы выбираем все ссылки (&lt;a>), у которых href начинается с "http://" или "https://". Это позволяет нам выбрать все внешние ссылки.</li>
    <li><span class="code">content: " →";</span> - мы добавляем символ "→" после каждой внешней ссылки, что делает её выдающейся на космической карте.</li>
    <li><span class="code"></span></li>
</ol>
<pre><code class="language-css">a[href^="http://"]::after,
a[href^="https://"]::after {
  content: " →";
  color: blue;
}</code></pre>
<p></p>
<pre><code class="language-css"></code></pre>

background-color
<div style="background: rgba(0, 128, 0, 0.1)">
    <p>10% Прозрачность</p>
</div>
<div style="background: rgba(0, 128, 0, 0.3)">
    <p>30% Прозрачность</p>
</div>
<div style="background: rgba(0, 128, 0, 0.6)">
    <p>60% Прозрачность</p>
</div>
background-image: url(адрес_изображения);
background-repeat
background-attachment
background-position.

<h2>Позиционирование элементов</h2>
<p>Элементы попадают на веб-страницу туда, где они находятся в документе, но
могут перемещаться путем изменения свойства позиции элемента от исходной
статической (<span class="code">static</span>) до абсолютной (<span class="code">absolute</span>), относительной (<span class="code">relative</span>),
прилипчивой (<span class="code">sticky</span>) или фиксированной (<span class="code">fixed</span>).</p>
<h3>Абсолютное позиционирование</h3>
<p>Элемент с абсолютным позиционированием удаляется из документа, и любые
другие элементы, которые в состоянии это сделать, займут освободившееся
пространство. Затем вы можете позиционировать объект в любое нужное место
в документе, используя свойства «верх» — <span class="code">top</span>, «право» — <span class="code">right</span>, «низ» — <span class="code">bottom</span>
и «лево» — <span class="code">left</span>.</p>
<p>Например, для перемещения объекта с ID, имеющим значение object, в абсолютное место, находящееся на 100 пикселов ниже начала документа и на 200 пикселов от левого края, к нему нужно применить следующие правила (вы также
можете использовать любые другие единицы измерений, поддерживаемые CSS):</p>
<pre><code >#object {
position:absolute;
top :100px;
left :200px;
}</code></pre>
<p>Объект будет располагаться либо поверх других элементов, либо за другими,
перекрывающими его элементами, в зависимости от значения, присвоенного
свойству <span class="code">z-index</span> (которое работает только в отношении позиционированных
элементов). По умолчанию это свойство имеет значение auto, присваиваемое
браузером без вашего участия. Вместо этого вы можете дать этому свойству
целочисленное значение (которое может быть и отрицательным):</p>
<pre><code >#object {
position:absolute;
top :100px;
left :200px;
z-index:100;
}</code></pre>
<p>После этого объекты будут появляться на экране в порядке от самого низкого
и до самого высокого значения их свойства <span class="code">z-index</span>, при этом объекты с более
высокими значениями станут отображаться поверх объектов с более низкими
значениями. По умолчанию значение <span class="code">z-index</span> для элемента <span class="code">html</span> равно <span class="code">0</span>, все
остальные значения по умолчанию являются автоматическими.</p>
<h3>Относительное позиционирование</h3>
<p>Подобным образом можно переместить объект относительно того места, которое
он занимал бы при обычном ходе формирования документа. Так, например, для
перемещения объекта на 10 пикселов вниз и 10 пикселов вправо от его обычного
положения нужно воспользоваться следующими правилами:</p>
<pre><code >#object {
position:relative;
top :10px;
left :10px;
}</code></pre>
<h3>Фиксированное позиционирование</h3>
<p>Заключительные настройки свойства <span class="code">position</span> позволяют переместить объект
в абсолютное положение, но только внутри окна просмотра текущего браузера.
Затем при прокрутке документа объект остается именно там, куда он был помещен, а основной документ будет прокручиваться под ним — это неплохой способ создания док-панелей и других подобных устройств. Для фиксирования
объекта в левом верхнем углу браузера нужно воспользоваться следующими
правилами:</p>
<pre><code >#object {
position:fixed;
top :0px;
left :0px;
}</code></pre>
После прокрутки тут же выяснится, что элемент с фиксированной позицией
(object3) останется на своем месте, несмотря на прокрутку. Также можно будет
наблюдать, что элемент-контейнер (по имени container) обладает абсолютным
позиционированием и размещается в точности на 50 пикселов ниже, с горизонтальным смещением 0 пикселов, поэтому элемент object1 (имеющий абсолютное позиционирование внутри элемента container) появляется именно в этом
месте. А элемент object2 имеет относительное позиционирование, поэтому он
смещен от левой границы элемента container на 110 пикселов, выстраиваясь
рядом с элементом object1.
Показанный на рисунке элемент object3, несмотря на то что он в коде HTML
появляется внутри элемента container, имеет фиксированное позиционирование, в результате чего он фактически совершенно независим от других объектов
и не скован границами элемента container. Изначально он был настроен на
нахождение на одной линии с элементами object1 и object2, но остался на месте,
в то время как другие элементы были прокручены вверх по странице, и теперь
object3 смещен ниже этих элементов.





<h2>Цвета в CSS</h2>
<script>
    $(function(){
        $('.css-color').each(function(){
            $(this).css('background-color', $(this).text())
        })
    })
</script>
<p>Цвета могут применяться к первому плану, а также к фону текста и объектов
путем использования свойства цвета — color и фонового цвета — <span class="code">background-color</span> (или путем предоставления единственного аргумента свойству фона —
<span class="code">background</span>). Указанный цвет может быть одним из именованных цветов (например, <span class="css-color">red</span> или <span class="css-color">blue</span>), цветом, составленным из трех шестнадцатеричных чисел <span class="code">RGB</span>
(например, <span class="css-color">#ff0000</span> или <span class="css-color">#0000ff</span>), или цветом, составленным с использованием
CSS-функции rgb.</p>
<p>Названия стандартных 16 цветов CSS следующие: аквамарин — <span class="css-color">aqua</span>, черный — <span class="css-color">black</span>, синий — <span class="css-color">blue</span>, яркий пурпурно-красный, или фуксия, — <span class="css-color">fuchsia</span>, серый — <span class="css-color">gray</span>,
зеленый — <span class="css-color">green</span>, яркий светло-зеленый — <span class="css-color">lime</span>, красно-коричневый — <span class="css-color">maroon</span>,
темно-синий — <span class="css-color">navy</span>, оливковый — <span class="css-color">olive</span>, фиолетовый — <span class="css-color">purple</span>, красный — <span class="css-color">red</span>,
серебристый — <span class="css-color">silver</span>, зеленовато-голубой — <span class="css-color">teal</span>, белый — <span class="css-color">white</span> и желтый —
<span class="css-color">yellow</span>.</p>

<h2>Градиенты</h2>
<p>Вместо использования сплошного цветового фона можно применить градиент,
который будет автоматически переходить от выбранного исходного до выбранного конечного цвета. Градиент лучше использовать в связке с простым цветовым
правилом, чтобы браузеры, не поддерживающие градиенты, отображали хотя
бы сплошной цвет.</p>
<pre><code >&lt;style>
    .orangegrad {
        background:orange;
        background:linear-gradient(top, #fb0, #f50);
&lt;/style>
&lt;div class='orangegrad'>Черный текст &lt;br>
    на оранжевом &lt;br>линейном градиенте&lt;/div></code></pre>
<style>
    .orangegrad {
        background: orange;
        background: linear-gradient(top, #fb0, #f50);
    }
</style>
<div class='orangegrad'>Черный текст <br>на оранжевом <br>линейном градиенте</div>
<p>Для создания градиента нужно выбрать, где он будет начинаться: вверху (<span class="code">top</span>),
внизу (<span class="code">bottom</span>), слева (<span class="code">left</span>), справа (<span class="code">right</span>), по центру (<span class="code">center</span>) или в любых
составных местах, например в левом верхнем углу (<span class="code">top left</span>) или от центра
вправо (<span class="code">center right</span>). Затем следует ввести нужные начальный и конечный
цвета и применить правило либо линейного (<span class="code">linear-gradient</span>), либо радиального (<span class="code">radial-gradient</span>) градиента, обеспечив правила для всех браузеров, на
которые вы нацелились.</p>

</body>
</html>