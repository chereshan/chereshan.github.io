<!--TODO: LEARN HOW TO DO HIGHLIGHT.JS SUBSTRINGS <span>-->
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src='../modules/jquery-3.7.1.min.js'></script>
    <link rel="stylesheet" href="../modules/vs2015.min.css">
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
    <title>Глава 1. Введение в JavaScript</title>
</head>
<body>
<script src="../common/counters_body.js"></script>
<h1>Глава 1. Введение в JavaScript</h1>

<h2>Что такое JS?</h2>
<p> Формально JS самый распространенный ЯП в истории, т.к. все современные веб-браузеры включают его интерпретатор.</p>
<p>JS - это ЯП, который:</p>
<ul>
<li><b>Высокоуровневый</b></li>
<li><b>Динамический</b></li>
<li><b>Интерпретируемый</b></li>
<li><b>Нетипизированный</b></li>
<li><b><span data-tooltip="в общих чертах это означает, что вместо глобальных функций для обработки значений различных типов типы сами могут определять методы для обработки значений">Подходит для ООП</span></b></li>
<li><b>Подходит для функционального стиля программирования</b></li>
<li><b>Имеет автоматическую сборку мусора памяти</b> - это означает, что программа может создавать объекты по мере необходимости, но программисту нет необходимости беспокоиться об уничтожении этих объектов и освобождении занимаемой ими памяти. Когда объект выходит за пределы области видимости (т. е. когда программа утрачивает возможность доступа к этому объекту) и интерпретатор обнаруживает, что данный объект никогда больше не сможет использоваться, он автоматически освобождает занимаемую им память.</li>
</ul>

<h3>Практические особенности JS</h3>
<p>JS обладает следующими особенностями:</p>
<ul>
    <li>JS чувствителен к регистру (<span class="code">while</span>≠<span class="code">WHILE</span>)</li>
    <li>Комментарии:<span class="code">//</span> и <span class="code">/**/</span></li>
    <li>Интерпретатор игнорирует пробелы</li>
    <li><span class="code">;</span> иногда можно опускать, если операторы записаны на разных строках</li>
</ul>



<h2>История JS</h2>
<p>Язык JavaScript был создан в компании Netscape Communications на заре истории веб-сети. Формально “JavaScript” — это торговая марка, зарегистрированная компанией Sun Microsystems (теперь Oracle), которая применяется для описания реализации языка от Netscape (в настоящее время Mozilla).</p>
<p>На протяжении большей части 2010-х годов все веб-браузеры поддерживали версию 5 стандарта ECMAScript. В этой книге ES5 рассматривается как отправная точка совместимости и предшествующие ей версии языка больше не обсуждаются. Стандарт ES6 был выпущен в 2015 году и обзавелся важными новыми средствами, включая синтаксис классов и модулей, которые превратили JavaScript из языка написания сценариев в серьезный универсальный язык, подходящий для крупномасштабной разработки ПО.</p>
<p>Чтобы быть полезным, каждый язык обязан иметь платформу, или стандартную библиотеку, для выполнения таких действий, как базовый ввод и вывод. В основном языке JavaScript определен минимальный API-интерфейс для чисел, текста, массивов, множеств, отображений и т.д., но какая-либо функциональность ввода или вывода отсутствует. За ввод и вывод (а также за более сложные средства наподобие работы с сетью, хранилищем и графикой) несет ответственность “среда размещения”, внутрь которой встраивается JavaScript. Изначально такой исполняющей средой был веб-браузер.</p>

<h2>Hello, world!</h2>
<pre><code class="language-javascript">console.log('Hello, world!');
</code></pre>

<h2>Базовые типы</h2>
<p>Типы:</p>
<ol>
    <li><b>Элементарные</b>: числа, строки, були, <span class="code">null</span>, <span class="code">undefinеd</span>, <span class="code">symbol</span></li>
    <li><b>Объектные</b> - все, что не относятся к выше перечисленным
        <ul>
            <li><span class="code">Array</span></li>
            <li><span class="code">Set</span></li>
            <li><span class="code">Map</span></li>
            <li><span class="code">RegExp</span></li>
            <li><span class="code">Date</span></li>
            <li><span class="code">Error</span></li>
        </ul>
</ol>
<p>Элементарные типы <b>не изменяемы</b>, а объектные типы <b>изменяемы</b></p>
<p>Типы в JS задаются литералами.</p>
<pre><code class="language-javascript">// Все, что следует за двумя символами косой черты, является комментарием.
// Переменная представляет собой символическое имя значения.
// Переменные объявляются с помощью ключевого слова var:
var x; // Объявление переменной по имени х.
// Присваивать значения переменным можно посредством знака =.
x=12;              // int
x=0.01;            // float
x='Hello, world!'; // string
x=true;            // bool
x=/javascript/gi   // regex
x=null;            // Пустой объект
x=undefined;       //
</code></pre>
<p>JS отличается от других статичных ЯП тем, что функции и классы - не просто часть синтаксиса: они сами являются значениями, которыми можно манипулировать.</p>
<ul>
    <li><span class="code">1=='1'</span> вернет <span class="code">true</span></li>
    <li><span class="code">1==='1'</span> вернет <span class="code">false</span></li>
</ul>

<h3>Числа</h3>
<p>В отличие от многих языков программирования, в JavaScript не делается различий между целыми и вещественными значениями. Все числа в JavaScript представляются вещественными значениями (с плавающей точкой).</p>
<h4>Формы записи чисел</h4>
<p>Существует наиболее общая форма записи для числа в JS, которая имеет следующий вид:</p>
<pre><span class="code">[цифры][.цифры][(E|e)[(+|-)]цифры]</span></pre>
<pre><code class="language-javascript">let billion=1_000_000_000
let bytes= 0x89_AB_CD_EF;
let bits=0b0001_1101_0111;
let fraction = 0.123_456_789;
</code></pre>
<h4>Численные методы</h4>
<pre><code class="language-javascript">Math.pow(2,53) // => 9007199254740992: 2 в степени 53
Math.round(.6) // => 1.0: округление до ближайшего целого
Math.ceil(.6) // => 1.0: округление вверх
Math.floor(.6) // => 0.0: округление вниз
Math.abs(-5) // => 5: абсолютное значение
Math.max(x,y,z) // Возвращает наибольший аргумент
Math.min(x,y,z) // Возвращает наименьший аргумент
Math.random() // Псевдослучайное число x, где 0 <= x < 1.0
Math.PI // π: длина окружности / диаметр
Math.E // e: Основание натурального логарифма
Math.sqrt(3) // Корень квадратный из 3
Math.pow(3, 1/3) // Корень кубический из 3
Math.sin(0) // Тригонометрия: имеются также Math.cos, Math.atan и другие.
Math.log(10) // Натуральный логарифм 10
Math.log(100)/Math.LN10 // Логарифм 100 по основанию 10 (десятичный)
Math.log(512)/Math.LN2 // Логарифм 512 по основанию 2
Math.exp(3) // Math.E в кубе</code></pre>
<p>Деление на ноль не считается ошибкой в JavaScript: в этом случае просто возвращается бесконечность или отрицательная бесконечность. Однако есть одно исключение: операция деления нуля на ноль не имеет четко определенного значения, поэтому в качестве результата такой операции возвращается специальное значение «не число» (not-a-number), которое обозначается как <span class="code">NaN</span>. Значение <span class="code">NaN</span> возвращается также при попытке разделить бесконечность на бесконечность, извлечь квадратный корень из отрицательного числа или выполнить арифметическую операцию с нечисловыми операндами, которые не могут быть преобразованы в числа.</p>
<pre><code class="language-javascript">let x=10;
Infinity // Переменная, доступная для чтения/записи,
 // инициализированная значением Infinity.
Number.POSITIVE_INFINITY // То же значение, доступное только для чтения.
1/0 // То же самое значение.
Number.MAX_VALUE + 1 // Это выражение также возвращает Infinity.
Number.NEGATIVE_INFINITY // Возвращают отрицательную бесконечность.
-Infinity
-1/0
-Number.MAX_VALUE - 1
NaN // Переменная, доступная для чтения/записи,
 // инициализированная значением NaN.
Number.NaN // Свойство, доступное только для чтения, с тем же значением.
0/0 // Возвращает NaN.
Number.MIN_VALUE/2 // Потеря значащих разрядов: возвращает 0
-Number.MIN_VALUE/2 // Отрицательный ноль
-1/Infinity // Также отрицательный ноль

var zero = 0; // Обычный ноль
var negz = -0; // Отрицательный ноль
zero === negz // => true: ноль и отрицательный ноль равны
1/zero === 1/negz // => false: Infinity и -Infinity не равны</code></pre>


<h3>Строки</h3>
<pre><code class="language-javascript">let msg = "Hello," + "world"; //Образует строку "Hello, world"
let name = 'egor';
let greeting = "Welcome to my blog," + " " + name;

let s = "Hello, world";

var s = "hello, world" // Начнем с того же текста.
s.charAt(0)          // => "h": первый символ.
s.charAt(s.length-1) // => "d": последний символ.
s.substring(1,4)     // => "ell": 2-й, 3-й и 4-й символы.
s.slice(1,4)         // => "ell": то же самое
s.slice(-3)          // => "rld": последние 3 символа
s.indexOf("l")       // => 2: позиция первого символа l.
s.lastIndexOf("l")   // => 10: позиция последнего символа l.
s.indexOf("l", 3)    // => 3: позиция первого символа "l", следующего за 3 символом в строке
s.split(", ")        // => ["hello", "world"] разбивает на подстроки
s.replace("h", "H")  // => "Hello, world": замещает все вхождения подстроки
s.toUpperCase()      // => "HELLO, WORLD"
s[0]                 // => "h"
s[s.length-1]        // => "d"

// Шаблонные литералы
let greetings = `Hello ${ name }.`; //Hello egor.
</code> </pre>
<p>Преобразования регистра символов</p>
<pre><code class="language-js">var catName = "Kitty";
catName.toLowerCase(); //kitty
catName.toUpperCase(); //KITTY
// для языков, правила которых противоречат Unicode
catName.toLocaleLowerCase(); //kitty
catName.toLocaleUpperCase(); //KITTY</code></pre>


<p>В JS определены так называемые управляющие последовательности: <span class="code">\n</span>, <span class="code">\b</span>, <span class="code">\t</span>, <span class="code">\r</span> и т.д.</p>

<h4>Проверка того, что строка существует и она не пустая</h4>
<p>Убедимся, что:</p>
<ol>
    <li>Переменная существует</li>
    <li>Является строкой:
        <pre><code class="language-js">if (typeof unknownVariable === 'string') {
                // unknownVariable — это строка
                }</code></pre>

    </li>
    <li>Не пустая:
        <pre><code class="language-js">if (typeof unknownVariable === 'string' && unknownVariable.length > 0) {
                // Это именно строка, и она содержит какие-то символы либо пробелы
                }</code></pre>
    </li>
    <li>Не состоит из пробелов:
        <pre><code class="language-js">if (typeof unknownVariable === 'string' && unknownVariable.trim().length > 0) {
                // Это именно строка, она непустая и состоит не только из пробелов
                }</code></pre>

    </li>
</ol>

<p>Вам будет попадаться следующий старомодный способ валидации строк. Он не требует, чтобы переменная действительно была строкой, а лишь
    проверяет, что значение может трактоваться как строка и она не будет пустой:</p>
<pre><code class="language-js">if (unknownVariable) {
/* Мы попадем сюда, если:
unknownVariable объявлена
unknownVariable не равна null
unknownVariable не является пустой строкой ('')
*/
}
//Это работает, потому что:
Boolean('')==false
Boolean(null)==false
Boolean(undefined)==false</code></pre>



<h3>Булевые типы</h3>
<pre><code class="language-javascript">false==undefined, //false
false==null,      //false
false==0,         //true
false==-0,        //true
false==NaN,       //false
false==""         //true
</code></pre>


<h3>Регулярные выражения</h3>
<p>В языке JavaScript определен конструктор <span class="code">RegExp()</span>, предназначенный для создания объектов, представляющих текстовые шаблоны. Эти шаблоны описываются с помощью регулярных выражений, синтаксис которых был заимствован языком JavaScript из языка Perl. И строки, и объекты <span class="code">RegExp</span> имеют методы, позволяющие выполнять операции сопоставления с шаблоном и поиска с заменой при помощи регулярных выражений.</p>
<pre><code class="language-javascript">/^HTML/ // Соответствует символам H T M L в начале строки
/[1-9][0-9]*/ // Соответствует цифре, кроме нуля, за которой следует любое число цифр
/\bjavascript\b/i // Соответствует подстроке "javascript" как отдельному слову, учитывает регистр символов
var text = "testing: 1, 2, 3"; // Образец текста
var pattern = /\d+/g // Соответствует всем вхождениям одной или более цифр
pattern.test(text) // => true: имеется совпадение
text.search(pattern) // => 9: позиция первого совпадения
text.match(pattern) // => ["1", "2", "3"]: массив всех совпадений
text.replace(pattern, "#"); // => "testing: #, #, #"
text.split(/\D+/); // => ["","1","2","3"]: разбить по нецифровым символам</code></pre>
<p>Объект <span class="code">RegExp</span> в JavaScript имеет следующие свойства:</p>
<ul>
    <li><span class="code">source</span> - собственно текст регулярного выражения</li>
    <li><span class="code">ignoreCase</span> - логическое значение обозначающее наличие флага "<span class="code">i</span>", доступно только для чтения</li>
    <li><span class="code">global</span> - логическое значение обозначающее наличие флага "<span class="code">g</span>", доступно только для чтения</li>
    <li><span class="code">multiline</span> - логическое значение обозначающее наличие флага "<span class="code">m</span>", доступно только для чтения</li>
    <li><span class="code">lastIndex</span> - счетчик, указывающий, с какой позиции в строке начинать поиск</li>
</ul>

<p>У RegExp есть по крайней мере 2 метода: </p>
<ul>
    <li><span class="code">exec(text)</span> - выполнение поиска в строке, указанной в качестве параметра, возвращает массив найденных соответствий.</li>
    <li><span class="code">test(text)</span> - проверка соответствия регулярному выражению, возвращает true\false</li>
</ul>
<pre><code class="language-js">var myString = "This is just a test text";  // Задаем строку для поиска
var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"
result = myPattern.exec(myString);
//result будет равен "is" - первому совпадению шаблона, свойство myPattern.lastIndex примет значение 4
result = myPattern.exec(myString); //result == "is" - второму совпадению шаблона, lastIndex == 7
result = myPattern.exec(myString); //result == "te" - третьему совпадению шаблона, lastIndex == 17
result = myPattern.exec(myString); //result == "te" - четвертому совпадению шаблона, lastIndex == 22</code></pre>
<pre><code class="language-js">var myString = "This is just a test text";  // Задаем строку для поиска
var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"
result = myPattern.test(myString);
// result будет равен true, поскольку будет найдено первое совпадение, свойство lastIndex примет значение 4
result = myPattern.test(myString); // result == true, lastIndex == 7
result = myPattern.test(myString); // result == true, lastIndex == 17
result = myPattern.test(myString); // result == true, lastIndex == 22
result = myPattern.test(myString); // result == false, lastIndex == 0</code></pre>

<p>Буква <span class="code">g</span> в конце регулярного выражения — это дополнительный элемент, называемый <b>глобальным флагом</b>. Он показывает, что нужно искать совпадения с шаблоном во всей строке. Если не поставить флаг <span class="code">g</span>, то при вызове <span class="code">replaceAll()</span> получим ошибку. При вызове метода <span class="code">replace()</span> можно использовать регулярное выражение без глобального флага, но тогда будет заменен только первый фрагмент, соответствующий шаблону</p>
<pre><code class="language-js">const originalString = 'Now is the time, this is the tame';
const regex = /t\w{2}e/g;
const newString = originalString.replaceAll(regex, 'place');
// newString = 'Now is the place, this is the place'</code></pre>


<h3>Дата и время</h3>
<p>В базовом JS существует конструктор <span class="code">Date()</span> для создания объектов, представляющих дату и время.</p>
<pre><code class="language-js">var x = new Date(миллисекунды) //Количество миллисекунд отсчитывая с 1 января 1970г
var myDate = new Date("December 14, 1975 12:10:00") //Sun Dec 14 1975 12:10:00 GMT+0300 (RTZ 2 (зима))
var myDate = new Date(1989, 6, 14)  //Fri Jul 14 1989 00:00:00 GMT+0400 (RTZ 2 (лето))
var myDate = new Date(1998, 6, 14, 11, 20, 00) //Tue Jul 14 1998 11:20:00 GMT+0400 (RTZ 2 (лето))</code></pre>

<pre><code class="language-javascript">
let timestamp = Date.now(); //Текущее время как отметка времени (число) .
let now = new Date(); // Текущее время как объект Date.
let ms = now.getTime(); // Преобразовать в миллисекундную
let iso = now.toISOString(); // Преобразовать в строку со стандартным
console.log(timestamp,now, ms, iso)
//1702701966891 2023-12-16T04:46:06.891Z 1702701966891 2023-12-16T04:46:06.891Z
</code></pre>

<pre><code class="language-js">var myDate = new Date();               // Создаем объект типа Date, в нем оказывается текущая дата
myDate.setFullYear(2017, 4, 22);       // Присваиваем ему значение даты - 22 мая 2017
myDate.setDate(myDate.getDate() + 10); // Устанавливаем новое значение даты, получив прежнее и прибавив 10.</code></pre>

<h4>Получение данных из объекта <span class="code">Date</span></h4>
<pre><code class="language-js">var then = new Date(2010, 0, 1); // Первый день первого месяца 2010 года
var later = new Date(2010, 0, 1, 17, 10, 30); // Та же дата, в 17:10:30 локального времени
var now = new Date(); // Текущие дата и время
var elapsed = now - then; // Разность дат: интервал в миллисекундах
later.getFullYear() // => 2010
later.getMonth() // => 0: счет месяцев начинается с нуля
later.getDate() // => 1: счет дней начинается с единицы
later.getDay() // => 5: день недели. 0 - воскр., 5 - пятн.
later.getHours() // => 17: 17 часов локального времени
later.getMinutes()
later.getSeconds()
later.getMilliseconds()
later.getUTCHours() // часы по UTC; зависит от часового пояса</code></pre>

<h4>Запись данных в объект <span class="code">Date</span></h4>
<pre><code class="language-js">later.setYear() - устанавливает значение года минус 1900, к использованию не очень рекомендуется.
later.setFullYear() // устанавливает значение года.
later.setMonth() // устанавливает месяц, от 0 до 11
later.setDate() // устанавливает день месяца, от 1 до 31
later.setHours() // устанавливает час, от 0 до 23
later.setMinutes() // устанавливает количество минут, от 0 до 59
later.setSeconds() // устанавливает количество секунд, от 0 до 59
later.setMilliseconds() // устанавливает количество миллисекунд, от 0 до 999
later.setTime() // устанавливает количество миллисекунд, прошедших с полуночи 1 января 1970г GMT.</code></pre>

<h4>Преобразование данных объекта <span class="code">Date</span></h4>
<pre><code class="language-javascript">
later.parse() // преобразовывает строку с датой, например "Jul 05, 2017" и возвращает количество миллисекунд, прошедших с полуночи 1 января 1970 г. Если строку преобразовать не удалось - возвращает NaN.
later.toString() // => "Fri Jan 01 2010 17:10:30 GMT+0300"
later.toUTCString() // => "Fri, 01 Jan 2010 14:10:30 GMT"
later.toLocaleDateString() // => "1 Январь 2010 г."
later.toLocaleTimeString() // => "17:10:30"
later.toISOString() // => "2010-01-01T14:10:30.000Z"</code></pre>
<p>Объекты типа Date() можно изменять и сравнивать:</p>
<pre><code class="language-js">var myDate = new Date();               // Создаем объект типа Date, в нем оказывается текущая дата
myDate.setFullYear(2017, 4, 22);       // Присваиваем ему значение даты - 22 мая 2017
myDate.setDate(myDate.getDate() + 10); // Устанавливаем новое значение даты, получив прежнее и прибавив 10.</code></pre>
<pre><code class="language-js">var currentDate = new Date();             // Объявляем переменную для текущей даты
var nextNewYear = new Date();             // Объявляем переменную для даты Нового Года
nextNewYear.setFullYear(2018, 0, 1);        // Записываем значение даты для Нового Года - 1 января 2018
//  в данном случае, мы хотим проверить, что эти объекты имеют одинаковое значение, а не их идентичность.
if (+currentDate == +nextNewYear) {
alert("Поздравляем с Новым, 2018-м Годом! Ура!!!");
}</code></pre>

<h3>Объекты</h3>
<p><b>Объект в JS</b> - это неупорядоченная коллекция свойств, где каждое свойство имеет имя и значение.</p>
<pre><code class="language-javascript">// Самым важным типом данных JavaScript является объект.
// Объект - это коллекция пар имя/значение
let book = { // объект заключается в фигурные скобки
    topic: 'JavaScript', // свойство топик имееет хг джаваскрипт
    edition: 7
};
// аналог словаря питона, но имя здесь это переменная(?)
// доступ к значениям свойств через . или []
console.log('До добавления нового свойства:',book.topic, book.edition, book['topic']);
book.author='Flanagan'; //создаем новое свойство присваиванием
book.contents={};
console.log('После добавления нового свойства:',book.author);
//условный доступ к свойствам объекта
book.contents?.ch01?.sect1
</code></pre>
<p></p>

<h3>Массивы</h3>
<pre><code class="language-javascript">// js также поддерживает массивы
let primes =[2,3,5,7];
// -1 для массивов js не работает
console.log(primes[0],primes[-1]);
// нужно вызывать свойство length
console.log(primes[primes.length-1]);
//длина пустого массива =0
let empty=[];
// массивы и объекты могу содержать другие массивы и объекты
let points=[
    {x:0,y:0},
    {x:1,y:1}
];
let data = {
    trial1:[[1,2],[3,4]],
    trial2:[[2,3],[4,5]]
};
</code></pre>
<p>Особенности массивов в JS</p>
<ul>
    <li><b>Упорядоченность</b>: Элементы массива располагаются в определенном порядке и доступ к ним осуществляется по индексу. Индексы массива начинаются с 0, то есть первый элемент имеет индекс 0, второй - индекс 1 и так далее.</li>
    <li><b>Динамическое изменение размера</b>: Массивы в JavaScript могут динамически изменять свой размер, добавлять новые элементы или удалять существующие. Нет необходимости задавать начальный размер массива при его создании.</li>
    <li><b>Разнородность данных</b>: Массивы в JavaScript могут содержать значения различных типов данных, например, числа, строки, булевы значения, объекты и даже другие массивы.</li>
    <li><b>Доступ к элементам</b>: Элементы массива могут быть доступны по их индексу с использованием квадратных скобок и индекса элемента. Например, <span class="code">array[0]</span> обращается к первому элементу массива.</li>
</ul>

<h4>Методы массивов</h4>

<h5>push</h5>
<pre><code class="language-javascript">//Метод push() - добавляет элементы в конец массива:
const fruits = ['apple', 'banana', 'orange'];
fruits.push('grape');
console.log(fruits); // Выводит ['apple', 'banana', 'orange', 'grape']</code></pre>

<h5>unshift</h5>
<p>Добавляет элемент в начало массива. </p>
<pre><code class="language-js">myArray.unshift("Сергеев", "Дмитриев")</code></pre>

<h5>pop</h5>
<pre><code class="language-javascript">// Метод pop() - удаляет последний элемент из массива и возвращает его:
const fruits = ['apple', 'banana', 'orange'];
const removedFruit = fruits.pop();
console.log(removedFruit); // Выводит 'orange'
console.log(fruits); // Выводит ['apple', 'banana']</code></pre>

<h5>delete</h5>
<p>Удалить элемент массива можно с помощью оператора delete, как обычное свойство.</p>
<pre><code class="language-javascript">delete myArray[2];</code></pre>
<p>Значение 3-го элемента массива будет установлено в <span class="code">undefined</span>, т.е. очищено, однако количество элементов в массиве не изменится, все остальные элементы останутся на своих местах.</p>

<h5>shift</h5>
<p>Метод <span class="code">shift()</span> (противоположный методу unshift) который удаляет элемент в начале массива и сдвигает все элементы на 1 позицию в начало.</p>

<h5>concat</h5>
<pre><code class="language-javascript">// Метод concat() - объединяет два или более массива:
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const combinedArray = array1.concat(array2);
console.log(combinedArray); // Выводит [1, 2, 3, 4, 5, 6]</code></pre>

<h5>slice</h5>
<pre><code class="language-javascript">// Метод slice() - создает новый массив, содержащий выбранные элементы из исходного массива:
const fruits = ['apple', 'banana', 'orange', 'grape', 'mango'];
const slicedArray = fruits.slice(1, 4);
console.log(slicedArray); // Выводит ['banana', 'orange', 'grape']</code></pre>

<h5>indexOf</h5>
<pre><code class="language-javascript">// Метод indexOf() - возвращает индекс первого вхождения заданного элемента в массиве:
const fruits = ['apple', 'banana', 'orange'];
const index = fruits.indexOf('banana');
console.log(index); // Выводит 1</code></pre>

<h5>join</h5>
<pre><code class="language-javascript">// Метод join() - объединяет все элементы массива в строку, разделенную указанным разделителем:
const fruits = ['apple', 'banana', 'orange'];
const joinedString = fruits.join(', ');
console.log(joinedString); // Выводит 'apple, banana, orange'</code></pre>

<h5>forEach</h5>
<p>Метод <span class="code">forEach</span> позволяется вызвать определенную функцию для всех элементов массива.</p>
<pre><code class="language-javascript">arr.forEach(function func(el, ind, arr) {
//код функции
});
</code></pre>
<pre><code class="language-javascript">let arr = [1, 2, 3, 4, 5];
arr.forEach(
    function plus_one(el) {
        console.log(el, "+", 1, "=", el + 1)
    }
)
</code></pre>

<h5>map</h5>
<p>Метод <span class="code">map</span> используется для того, чтобы создать новый массив из существующего, используя для каждого элемента функцию, переданную в метод map.</p>
<pre><code class="language-javascript">let arr = prompt().split(" ").map((n) => n ** 2)</code></pre>


<h5>filter</h5>
<p>Метод <span class="code">filter</span> используется для того, чтобы создать новый массив из существующего, оставляя только те элементы, которые проходят через функцию-условие, которая передается в filter.</p>
<pre><code class="language-javascript">let arr = [1, 2, 3, 4, 5, 6, 7];
let arr2 = arr.filter(n => n % 2 === 0) // [ 2, 4, 6]</code></pre>

<h5>reverse</h5>
<p>Меняет порядок массива на обратный.</p>
<pre><code class="language-js">var myArray = new Array("Иванов","Петров","Сидоров","Кузнецов");
myArray.reverse() // ['Кузнецов', 'Сидоров', 'Петров', 'Иванов']</code></pre>

<h5>sort</h5>
<p>Сортирует элементы в исходном массиве и возвращает отсортированный массив. Если метод использовать без аргумента (функции сортировки), то результат будет отсортирован в алфавитном порядке (в порядке следования символов в Unicode), путем преобразования всего, что возможно в строковый тип. Все, что привести к строкам невозможно - помещается в конец массива.</p>
<pre><code class="language-js">var myArray = new Array("Иванов","Петров","Сидоров","Кузнецов");
myArray.sort() // ['Иванов', 'Кузнецов', 'Петров', 'Сидоров']</code></pre>
<p>Чтобы вывести в консоль значения , отсортированные в обратном алфавитном порядке мы можем воспользоваться вот такой командой:</p>
<pre><code class="language-js">console.log(myArray.sort(function(a, b) {return b - a;}));
// ['Сидоров', 'Петров', 'Кузнецов','Иванов']</code></pre>

<h5>splice</h5>
<p>В качестве аргумента в этот метод можно передать следующие данные:</p>
<ul>
    <li>позиция элемента, с которого начинается действие метода</li>
    <li>количество удаляемых элементов, начиная со стартовой позиции, указанной в предыдущем аргументе. (Если второе значение не указано, будут удалены все элементы, начиная с первого аргумента).</li>
    <li>элементы массива, которые будут добавлены начиная с позиции, указанной в первом аргументе.</li>
</ul>
<pre><code class="language-js">var myArray = ["Иванов", "Петров", "Сидоров", "Кузнецов"];

myArray.splice(2, 2);
// вернет ["Сидоров", "Кузнецов"], исходный массив станет равен ["Иванов", "Петров"]
myArray.splice(1);
// вернет ["Петров", "Сидоров", "Кузнецов"], исходный массив превратится в ["Иванов"]
myArray.splice(2, 0, "Смит");
// вернет пустое значение [], в myArray добавится элемент ["Иванов", "Петров", "Смит", "Сидоров", "Кузнецов"]</code></pre>

<h3>Операции</h3>
<pre><code class="language-javascript">// Операторы выполняют действия со значениями (операндами) и воспроизводят
// новое значение. Наиболее часто используемыми являются арифметические операторы:
3 + 2 // => 5: сложение
3 - 2 // => 1: вычитание
3 * 2 // => 6: умножение
3 / 2 // => 1.5: деление
points[1].x - points[0].x // => 1: можно использовать более сложные операнды
"3" + "2" // => "32": + складывает числа, объединяет строки
// В JavaScript имеются некоторые сокращенные формы арифметических операторов
var count = 0; // Объявление переменной
count++; // Увеличение значения переменной на 1
count--; // Уменьшение значения переменной на 1
count += 2; // Добавить 2: то же, что count = count + 2;
count *= 3; // Умножить на 3: то же, что count = count * 3;
count // => 6: имена переменных сами являются выражениями
// Операторы сравнения позволяют проверить два значения на равенство
// или неравенство, выяснить, какое значение меньше или больше, и т. д.
// Они возвращают значение true или false.
var x = 2, y = 3; // Знаки = выполняют присваивание, а не сравнение
x == y // => false: равенство
x != y // => true: неравенство
x < y // => true: меньше
x <= y // => true: меньше или равно
x > y // => false: больше
x >= y // => false: больше или равно
"two" == "three" // => false: две разных строки
"two" > "three" // => true: при упорядочении по алфавиту строка "tw" больше, чем "th"
false == (x > y) // => true: false равно false
// Логические операторы объединяют или инвертируют логические значения
(x == 2) && (y == 3) // => true: оба сравнения истинны. && - "И"
(x > 3) || (y < 3) // => false: оба сравнения ложны. || - "ИЛИ"
!(x == y) // => true: ! инвертирует логическое значение
</code></pre>
<p>Если фразы в языке JavaScript называются <i>выражениями</i>, то полные предложения называются <i>инструкциями</i></p>
<p><b>Выражение</b> – это конструкция, которая вычисляет значение, но ничего не делает: она никак не изменяет состояние программы.</p>
<p><b>Инструкции</b>, напротив, не имеют значения (или их значение не представляет интереса для нас), но они изменяют состояние программы.</p>
<p>Выше уже были показаны инструкции объявления переменных и присваивания значений. Еще одной обширной категорией инструкций являются <b>управляющие конструкции</b> такие, как условные инструкции и инструкции циклов.</p>

<h3>Функции</h3>
<p><b>Функция</b> – это именованный и параметризованный блок программного кода JavaScript, который определяется один раз, а использоваться может многократно.</p>
<p>Создание (определение) функции начинается с ключевого слова <span class="code">function</span>, после которого указываются следующие данные:</p>
<pre><code class="language-javascript">function function printText(a) {           //Определение функции
document.write(a);              //Тело функции - вывод содержимого переменной "а" в документ
};
printText("Hello World!");
</code></pre>
<p>При определении функции после ключевого слова может не быть имени.  Например мы можем объявить функцию из прошлого шага вот таким способом:</p>
<!--todo: уменьшить размер кнопок копирования и раскомменчивания -->
<pre><code class="language-javascript">var printText = function(a) {document.write(a)}</code></pre>
<p>Функция может быть сразу вызвана с необходимым входным параметром. В следующем примере функция сразу будет вызвана - выведет в документ фразу "Hello World!". </p>
<pre><code class="language-javascript">var printedText = (function(a) {document.write(a);})("Hello World!");</code></pre>
<p></p>
<pre><code class="language-javascript">

</code></pre>
<p></p>
<pre><code class="language-javascript">

</code></pre>

<ol>
    <li><b>Имя функции</b>, которое будет использовано при создании переменной, ей же будет присвоен объект нашей новой функции.</li>
    <li><b>Список входных параметров</b> в круглых скобках (их может и не быть).</li>
    <li><b>Тело функции</b> в фигурных скобках - собственно список исполняемых команд (также может отсутствовать) .</li>
</ol>
<pre><code class="language-javascript">// Функции - это параметризованные блоки кода JavaScript,
// которые мы можем вызывать.
function plus1(x){
    return x+1;
}
console.log(plus1(99))

let square = function(x) {
    return x*x;
}

console.log(square(plus1(10)))
// аналог лямбда-функций - стрелочные функции
const plus1 = x => x+1;
const square = x => x*x;
</code></pre>
<p>Функции являются объектами, и как следствие могут, например, присваиваться переменным, передаваться другим функциям, можно присваивать значения их свойствам и вызывать методы.</p>

<pre><code class="language-javascript">// В JavaScript имеются условные инструкции и инструкции циклов, синтаксически
// похожие на аналогичные инструкции C, C++, Java и в других языках.
function abs(x) { // Функция, вычисляющая абсолютное значение
if (x >= 0) { // Инструкция if ...
return x; // выполняет этот код, если сравнение дает true.
} // Конец предложения if.
else { // Необязательное предложение else выполняет свой код,
return -x; // если сравнение дает значение false.
} // Фигурные скобки можно опустить, если предложение
// содержит 1 инструкцию.
} // Обратите внимание на инструкции return внутри if/else.
function factorial(n) { // Функция, вычисляющая факториал
var product = 1; // Начать с произведения, равного 1
while(n > 1) { // Повторять инструкции в {}, пока выраж. в () истинно
product *= n; // Сокращенная форма выражения product = product * n;
n--; // Сокращенная форма выражения n = n - 1
} // Конец цикла
return product; // Вернуть произведение
}
factorial(4) // => 24: 1*4*3*2
function factorial2(n) { // Другая версия, использующая другой цикл
var i, product = 1; // Начать с 1
for(i=2; i <= n; i++) // i автоматически увеличивается с 2 до n
product *= i; // Выполнять в каждом цикле. {} можно опустить,
// если тело цикла состоит из 1 инструкции
return product; // Вернуть факториал
}
factorial2(5) // => 120: 1*2*3*4*5
</code></pre>

<h3>Методы</h3>
<pre><code class="language-javascript">// когда мы применяем функции к объектам, то получаем методы
let a= [];
a.push(1,2,3)
a.reverse();
console.log(a);
// объекту можно присвоить метод
let points=[
    {x:0,y:0},
    {x:1,y:1}
];
// ключевое слово ссылается на используемый объект
points.dist=function(){
    let p1 = this[0];
    let p2=this[1];
    let a = p2.x-p1.x;
    let b =p2.y-p1.y1;
    return Math.sqrt(a*a+b*b);
}
console.log(points.dist());
//классические функции
// модуль
function abs(x){
    if (x>=0){
        return x;
    }
    else{return -x;}
}
//сумма массива
function sum(array){
    let sum=0;
    for (let x of array){sum+=x;}
    return sum;
}
//факториал
function factorial(n){
    let product=1;
    while (n>1){
        product*=n;
        n--;
    }
    return product;
}

console.log(
    abs(-100),
    sum([1,2,3,4,5]),
    factorial(8)
);
</code></pre>

<h3>ООП в JS</h3>
<pre><code class="language-javascript">// Определение функции-конструктора для инициализации нового объекта Point
function Point(x,y) { // По соглашению имя конструкторов начинается с заглавного символа
 this.x = x; // this - ссылка на инициализируемый объект
this.y = y; // Сохранить аргументы в свойствах объекта
} // Ничего возвращать не требуется
// Чтобы создать новый экземпляр, необходимо вызвать функцию-конструктор
// с ключевым словом "new"
var p = new Point(1, 1); // Точка на плоскости с координатами (1,1)
// Методы объектов Point определяются за счет присваивания функций свойствам
// объекта-прототипа, ассоциированного с функцией-конструктором.
Point.prototype.r = function() {
 return Math.sqrt( // Вернуть корень квадратный от x2 + y2
 this.x * this.x + // this - это объект Point, относительно которого...
 this.y * this.y // ...вызывается метод.
 );
};
// Теперь объект p типа Point (и все последующие объекты Point) наследует метод r()
p.r() // => 1.414...
</code></pre>

<h2>Переменные и области видимости</h2>
<pre><code class="language-javascript">let message;
message = 'Hello'; // сохранить строку 'Hello' в переменной с именем message
alert(message); // показывает содержимое переменной
let user = 'Ban', age = 25, message = 'Hello'; // Мы также можем объявить несколько переменных в одной строке
</code></pre>
<p><b>Разница между <span class="code">let</span> и <span class="code">var</span></b>: переменные, объявленные с помощью <span class="code">var</span> имеют глобальную область видимости. Она может использоваться в любом месте функции/файла. Если переменная объявлена внутри функции, она будет видна только внутри этой функции.</p>
<p>Переменные, объявленные с помощью <span class="code">let</span>, имеют блочную область видимости. Это означает, что переменная видна только внутри блока, в котором она была объявлена. Блоком может быть любая область кода, заключенная в фигурные скобки, включая циклы, условные операторы и функции.</p>
<p>Преимущество let в том, что мы не можем объявить переменную с тем же именем, когда она уже была объявлена. </p>
<pre><code class="language-javascript">const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
</code></pre>
<p>Резюмируем:</p>
<ul>
    <li> <span class="code">var</span>
        <ol>
            <li>Имеет <b>глобальную</b> или <b>функциональную область</b> видимости</li>
            <li>Может быть объявлена без инициализации</li>
            <li>Может использоваться для повторного объявления переменной</li>
        </ol>
    </li>
    <li> <span class="code">let</span>
        <ol>
            <li>Имеет <b>глобальную</b> или <b>блочную область видимости</b></li>
            <li>Может быть объявлена без инициализации</li>
            <li><b>НЕ</b> может использоваться для повторного объявления переменной</li>
        </ol>
    </li>
    <li> <span class="code">const</span>
        <ol>
            <li>Имеет <b>глобальную</b> или <b>блочную область видимости</b></li>
            <li><b>НЕ</b> может быть объявлена без инициализации</li>
            <li><b>НЕ</b> может использоваться для повторного объявления переменной</li>
        </ol>
    </li>
</ul>
<h3>Области видимости</h3>
<ul>
    <li>Глобальные - все переменнные определнные за пределами функций:</li>
    <pre><code class="language-js">a = 123 // Глобальная область видимости
var b = 456 // Глобальная область видимости
if (a == 123) var c = 789 // Глобальная область видимости</code></pre>
    <li>Локальные - все переменные определенные внутри тела функции с помощью <span class="code">var</span></li>
    <pre><code class="language-js">function test()
    {
        a = 123 // Глобальная область видимости
        var b = 456 // Локальная область видимости
        if (a == 123) var c = 789 // Локальная область видимости
    }</code></pre>
    <li>Если определить уже определенную глобальную переменную внутри тела функции, то внутри ее она будет иметь значение заданное в функциии, а значение глобальной переменной не изменится:</li>

    <pre><code class="language-javascript">var scope = "global"; // Объявление глобальной переменной
function checkscope() {
    var scope = "local"; // Объявление локальной переменной с тем же именем
    return scope; // Вернет локальное значение, а не глобальное
}
checkscope() // => "local"
scope // => "global"</code></pre>
    <p>Иными словами, внутри функции локальная переменная имеет преимущество перед глобальной с тем же именем.</p>
    <li>За пределами функций мы можем объявлять глобальные переменные без <span class="code">var</span>, но при объявлении локальных мы всегда должны использовать <span class="code">var</span>, иначе произойдет изменение глобальной переменной.</li>
    <pre><code class="language-javascript">scope = "global"; // Объявление глобальной переменной, даже без var.
function checkscope2() {
 scope = "local"; // Ой! Мы изменили глобальную переменную.
 myscope = "local"; // Неявно объявляется новая глоб. переменная.
 return [scope, myscope]; // Вернуть два значения.
}
checkscope2() // => ["local", "local"]: имеется побочный эффект!
scope // => "local": глобальная переменная изменилась.
myscope // => "local": нарушен порядок в глобальном пространстве имен.</code></pre>
</ul>

<p><b>Очень важно</b> остановится на одной особенности JS. Во многих C-подобных ЯП каждый блок программного кода внутри фигурных скобок имеет свою собственную область видимости, а переменные объявленные внутри невидимы за их пределами. Это называется <i>видимостью блоков</i>. JS <b>не</b> имеет такой особенности. Вместо этого JS имеет <b>видимость функции</b>: переменные, объявленные внутри функции, доступны внутри функции, где они объявлены, а также внутри всех функций, вложенных в эту функцию.</p>
<p>Это значит, что переменные объявленные внутри функции видны всюду в теле функции. И даже до того, как они были объявлены. Это явление называется <b>подъемом</b>, т.к. JS ведет себя так, будто все объявления внутри (без присваивания) как бы поднимаются в начало функции:</p>
<pre><code class="language-javascript">var scope = "global";
function f() {
 console.log(scope); // Выведет "undefined", а не "global"
 var scope = "local"; // Инициализируется здесь, а определена везде
 console.log(scope); // Выведет "local"
 //т.е. JS как бы просматривает все объявления переменных функций до ее выполнения.
}</code></pre>
<p>Можно было бы подумать, что первая инструкция внутри функции должна вывести слово «<i>global</i>», потому что инструкция <span class="code">var</span> с объявлением локальной переменной еще не была выполнена. Однако вследствие действия правил <b>области видимости функции</b> выводится совсем другое значение. Локальная переменная определена во всем теле функции, а это означает, что глобальная переменная с тем же именем оказывается скрытой для всей функции. Хотя локальная переменная определена во всем теле функции, она остается неинициализированной до выполнения инструкции <span class="code">var</span>. Станет понятнее, если взглянуть на эквивалентный код:</p>
<pre><code class="language-javascript">function f() {
 var scope; // Объявление локальной переменной в начале функции
 console.log(scope); // Здесь она доступна, но имеет значение "undefined"
 scope = "local"; // Здесь она инициализируется и получает свое значение
 console.log(scope); // А здесь она имеет ожидаемое значение
    }</code></pre>
<h3>Идентификаторы</h3>
<p>Идентификатор - это просто имя. </p>
<pre><code class="language-javascript">//допустимые имена
i
my_variable_name
Wv13
_dummy
$str
</code></pre>
<p>Зарезервированные имена:</p>
<pre><code class="language-javascript">//ключевые слова
break delete function return typeof
case do if switch var
catch else in this void
continue false instanceof throw while
debugger finally new true with
default for null try
//зарезервированные для ECMAScript 5
class const enum export extends import super
// зарезервированы в строгом режиме
implements let private public yield
interface package protected static
arguments eval
//зарезервированные слова JAVA
abstract double goto native static
boolean enum implements package super
byte export import private synchronized
char extends int protected throws
class final interface public transient
const float long short volatile
//глобальные переменные
arguments encodeURI Infinity Number RegExp
Array encodeURIComponent isFinite Object String
Boolean Error isNaN parseFloat SyntaxError
Date eval JSON parseInt TypeError
decodeURI EvalError Math RangeError undefined
decodeURIComponent Function NaN ReferenceError URIError
</code></pre>


<h2>Ввод и вывод</h2>
<pre><code class="language-javascript">prompt() // выводит диалоговое окно с текстом сообщения и полем для ввода данны
confirm() // выводит диалоговое окно с текстом сообщения и двумя кнопками: "ОК" и "Отмена"
alert() // выводит сообщение в модальном окне
console.log('Это сообщение выводится в консоль') // выводит сообщение в консоль
</code></pre>

<h2>Преобразование типов</h2>
<pre><code class="language-javascript">//преобразование строки в число
let str="123";
let num=parseInt(str);
console.log(str);
//преобразование числа в строку
let num=123;
let str = String(num);
typeof(str) //'string'
//явные преобразования
Number("3") // => 3
String(false) // => "false" или можно использовать false.toString()
Boolean([]) // => true
Object(3) // => new Number(3)
</code></pre>
<pre><code class="language-javascript">parseInt("3 blind mice") // => 3
parseFloat(" 3.14 meters") // => 3.14
parseInt("-12.34") // => -12
parseInt("0xFF") // => 255
parseInt("0xff") // => 255
parseInt("-0XFF") // => -255
parseFloat(".1") // => 0.1
parseInt("0.1") // => 0
parseInt(".1") // => NaN: целые числа не могут начинаться с "."
parseFloat("$72.47"); // => NaN: числа не могут начинаться с "$" </code></pre>
<p>Интерпретатор JavaScript выполняет автоматическую сборку мусора для управления памятью. Это означает, что программист на JavaScript в основном не должен волноваться об уничтожении или освобождении объектов либо других значений. Когда значение больше не достижимо, т.е. программа не располагает ни одним способом ссылки на него, интерпретатору известно, что значение никогда не будет применяться снова, и он автоматически возвращает обратно занимаемую им память.</p>
<p>Все объекты, (включая массивы и функции) преобразуются в значение <span class="code">true</span>.</p>
<p>Между числами и строками существует короткая форма преобразования:</p>
<pre><code class="language-js">n = "123"
n *= 1 // Превращение 'n' в число
n = 123
n += "" // Превращение 'n' в строку
// что аналогично
n = "123"
n = parseInt(n) // Превращение 'n' в целое число
n = parseFloat(n) // Превращение 'n' в число с плавающей точкой
n = 123
n = n.toString() // Превращение 'n' в строку</code></pre>

<h3>Глобальные объекты</h3>
    <p><b>Глобальный объект</b> — это обыкновенный объект JavaScript, который служит крайне важной цели: его свойствами являются глобально определенные идентификаторы, доступные программе JavaScript. Когда интерпретатор JavaScript запускается (или всякий раз, когда веб-браузер загружает новую страницу), он создает новый глобальный объект и предоставляет ему начальный набор свойств, которые определяют:</p>
    <ul>
        <li>глобальные константы вроде <span class="code">undefined</span>, <span class="code">Infinity</span> и <span class="code">NaN</span>;</li>
        <li>глобальные функции наподобие <span class="code">isNaN()</span>, <span class="code">parseInt()</span> и <span class="code">eval()</span> </li>
        <li>функции конструкторов вроде <span class="code">Date()</span>, <span class="code">RegExp()</span>, <span class="code">String()</span>, <span class="code">Object()</span> и <span class="code">Array()</span> </li>
        <li>глобальные объекты наподобие <span class="code">Math</span> и <span class="code">JSON</span></li>
        <li>глобальный объект <span class="code">Window</span> в клиентском JS</li>
    </ul>

    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>





</body>

</html>