<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
    <script>hljs.highlightAll();</script>
    <title>Глава 1. Введение в JavaScript</title>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="header"></div>
<h1>Глава 1. Введение в JavaScript</h1>
<h2>Что такое JS?</h2>
<p> Формально JS самый распространенный ЯП в истории, т.к. все современные веб-браузеры включают его интерпретатор.</p>
<p>JS - это ЯП, который:</p>
<ul>
<li>Высокоуровневый</li>
<li>Динамический</li>
<li>Интерпретируемый</li>
<li>Нетипизированный</li>
<li>Подходит для ООП</li>
<li>Подходит для функционального стиля программирования</li>
</ul>

<h3>Практические особенности JS</h3>
<p>JS обладает следующими особенностями:</p>
<ul>
    <li>JS чувствителен к регистру (<span class="code">while</span>=/=<span class="code">WHILE</span>)</li>
    <li>Комментарии:<span class="code">//</span> и <span class="code">/**/</span></li>
    <li>Интерпретатор игнорирует пробелы</li>
    <li><span class="code">;</span> иногда можно опускать, если операторы записаны на разных строках</li>
</ul>



<h2>История JS</h2>
<p>Язык JavaScript был создан в компании Netscape Communications на заре истории веб-сети. Формально “JavaScript” — это торговая марка, зарегистрированная компанией Sun Microsystems (теперь Oracle), которая применяется для описания реализации языка от Netscape (в настоящее время Mozilla).</p>
<p>На протяжении большей части 2010-х годов все веб-браузеры поддерживали версию 5 стандарта ECMAScript. В этой книге ES5 рассматривается как отправная точка совместимости и предшествующие ей версии языка больше не обсуждаются. Стандарт ES6 был выпущен в 2015 году и обзавелся важными новыми средствами, включая синтаксис классов и модулей, которые превратили JavaScript из языка написания сценариев в серьезный универсальный язык, подходящий для крупномасштабной разработки ПО.</p>
<p>Чтобы быть полезным, каждый язык обязан иметь платформу, или стандартную библиотеку, для выполнения таких действий, как базовый ввод и вывод. В основном языке JavaScript определен минимальный API-интерфейс для чисел, текста, массивов, множеств, отображений и т.д., но какая-либо функциональность ввода или вывода отсутствует. За ввод и вывод (а также за более сложные средства наподобие работы с сетью, хранилищем и графикой) несет ответственность “среда размещения”, внутрь котор'ой встраивается JavaScript. Изнчально такой исполняющей средой был веб-браузер.</p>

<h2>Hello, world!</h2>
<pre><code class="language-javascript">console.log('Hello, world!');
</code></pre>

<h2>Базовые типы</h2>
<p>Типы:</p>
<ol>
    <li><b>Элементарные</b>: числа, строки, були, null, undefinеd, symbol</li>
    <li><b>Объектные</b> - все, что не относятся к выше перечисленным
        <ul>
            <li>Массив</li>
            <li>Set</li>
            <li>Map</li>
            <li>RegExp</li>
            <li>Date</li>
            <li>Error</li>
        </ul>
</ol>
<p>Элементарные типы <b>не изменяемы</b>, а объектные типы <b>изменяемы</b></p>
<p>Типы в JS задаются литералами.</p>
<pre><code class="language-javascript">// Все, что следует за двумя символами косой черты, является комментарием.
// Переменная представляет собой символическое имя значения.
// Переменные объявляются с помощью ключевого слова var:
var x; // Объявление переменной по имени х.
// Присваивать значения переменным можно посредством знака =.
x=12;              // int
x=0.01;            // float
x='Hello, world!'; // string
x=true;            // bool
x=/javascript/gi   // regex
x=null;            // Пустой объект
x=undefined;       //
</code></pre>
<p>JS отличается от других статичных ЯП тем, что функции и классы - не просто часть синтаксиса: они сами являются значениями, которыми можно манипулировать.</p>
<ul>
    <li><span class="code">1=='1'</span> вернет <span class="code">true</span></li>
    <li><span class="code">1==='1'</span> вернет <span class="code">false</span></li>
</ul>

<h3>Формы записи чисел</h3>
<p>Существует наиболее общая форма записи для числа в JS, которая имеет следующий вид:</p>
<pre><span class="code">[цифры][.цифры][(E|e)[(+|-)]цифры]</span></pre>
<pre><code class="language-javascript">let billion=1_000_000_000
let bytes= 0x89_AB_CD_EF;
let bits=0b0001_1101_0111;
let fraction = 0.123_456_789;
</code></pre>



<h3>Строки</h3>
<pre><code class="language-javascript">let msg = "Hello," + "world"; //Образует строку "Hello, world"
let name = 'egor';
let greeting = "Welcome to my blog," + " " + name;

let s = "Hello, world";

var s = "hello, world" // Начнем с того же текста.
s.charAt(0)          // => "h": первый символ.
s.charAt(s.length-1) // => "d": последний символ.
s.substring(1,4)     // => "ell": 2-й, 3-й и 4-й символы.
s.slice(1,4)         // => "ell": то же самое
s.slice(-3)          // => "rld": последние 3 символа
s.indexOf("l")       // => 2: позиция первого символа l.
s.lastIndexOf("l")   // => 10: позиция последнего символа l.
s.indexOf("l", 3)    // => 3: позиция первого символа "l", следующего за 3 символом в строке
s.split(", ")        // => ["hello", "world"] разбивает на подстроки
s.replace("h", "H")  // => "Hello, world": замещает все вхождения подстроки
s.toUpperCase()      // => "HELLO, WORLD"
s[0]                 // => "h"
s[s.length-1]        // => "d"

// Шаблонные литералы
let greetings = `Hello ${ name }.`; //Hello egor.
</code> </pre>
<p>В JS определены так называемые управляющие последовательности: <span class="code">\n</span>, <span class="code">\b</span>, <span class="code">\t</span>, <span class="code">\r</span> и т.д.</p>

<h3>Булевые типы</h3>
<pre><code class="language-javascript">
    false==undefined, //false
    false==null,      //false
    false==0,         //true
    false==-0,        //true
    false==NaN,       //false
    false==""         //true
)</code></pre>


<h3>Регулярные выражения</h3>
<p>В языке JavaScript определен конструктор <span class="code">RegExp()</span>, предназначенный для создания объектов, представляющих текстовые шаблоны. Эти шаблоны описываются с помощью регулярных выражений, синтаксис которых был заимствован языком JavaScript из языка Perl. И строки, и объекты RegExp имеют методы, позволяющие выполнять операции сопоставления с шаблоном и поиска с заменой при помощи регулярных выражений.</p>
<pre><code class="language-javascript">/^HTML/ // Соответствует символам H T M L в начале строки
/[1-9][0-9]*/ // Соответствует цифре, кроме нуля, за которой следует любое число цифр
/\bjavascript\b/i // Соответствует подстроке "javascript" как отдельному слову, учитывает регистр символов
var text = "testing: 1, 2, 3"; // Образец текста
var pattern = /\d+/g // Соответствует всем вхождениям одной или более цифр
pattern.test(text) // => true: имеется совпадение
text.search(pattern) // => 9: позиция первого совпадения
text.match(pattern) // => ["1", "2", "3"]: массив всех совпадений
text.replace(pattern, "#"); // => "testing: #, #, #"
text.split(/\D+/); // => ["","1","2","3"]: разбить по нецифровым символам</code></pre>


<h3>Дата и время</h3>
<p>В базовом JS существует конструктор <span class="code">Date()</span> для создания объектов, представляющих дату и время. </p>
<pre><code class="language-javascript">
let timestamp = Date.now(); //Текущее время как отметка времени (число) .
let now = new Date(); // Текущее время как объект Date.
let ms = now.getTime(); // Преобразовать в миллисекундную
let iso = now.toISOString(); // Преобразовать в строку со стандартным
console.log(timestamp,now, ms, iso)
//1702701966891 2023-12-16T04:46:06.891Z 1702701966891 2023-12-16T04:46:06.891Z
</code></pre>
<pre><code class="language-javascript">var then = new Date(2010, 0, 1); // Первый день первого месяца 2010 года
var later = new Date(2010, 0, 1, 17, 10, 30); // Та же дата, в 17:10:30 локального времени
var now = new Date(); // Текущие дата и время
var elapsed = now - then; // Разность дат: интервал в миллисекундах
later.getFullYear() // => 2010
later.getMonth() // => 0: счет месяцев начинается с нуля
later.getDate() // => 1: счет дней начинается с единицы
later.getDay() // => 5: день недели. 0 - воскр., 5 - пятн.
later.getHours() // => 17: 17 часов локального времени
later.getUTCHours() // часы по UTC; зависит от часового пояса
later.toString() // => "Fri Jan 01 2010 17:10:30 GMT+0300"
later.toUTCString() // => "Fri, 01 Jan 2010 14:10:30 GMT"
later.toLocaleDateString() // => "1 Январь 2010 г."
later.toLocaleTimeString() // => "17:10:30"
later.toISOString() // => "2010-01-01T14:10:30.000Z"</code></pre>

<h3>Объекты</h3>
<p><b>Объект в JS</b> - это неупорядоченная коллекция свойств, где каждое свойство имеет имя и значение.</p>
<pre><code class="language-javascript">// Самым важным типом данных JavaScript является объект.
// Объект - это коллекция пар имя/значение
let book = { // объект заключается в фигурные скобки
    topic: 'JavaScript', // свойство топик имееет хг джаваскрипт
    edition: 7
};
// аналог словаря питона, но имя здесь это переменная(?)
// доступ к значениям свойств через . или []
console.log('До добавления нового свойства:',book.topic, book.edition, book['topic']);
book.author='Flanagan'; //создаем новое свойство присваиванием
book.contents={};
console.log('После добавления нового свойства:',book.author);
</code></pre>

<h3>Массивы</h3>
<pre><code class="language-javascript">// js также поддерживает массивы
let primes =[2,3,5,7];
// -1 для массивов js не работает
console.log(primes[0],primes[-1]);
// нужно вызывать свойство length
console.log(primes[primes.length-1]);
//длина пустого массива =0
let empty=[];
// массивы и объекты могу содержать другие массивы и объекты
let points=[
    {x:0,y:0},
    {x:1,y:1}
];
let data = {
    trial1:[[1,2],[3,4]],
    trial2:[[2,3],[4,5]]
};
</code></pre>
<p>Особенности массивов в JS</p>
<ul>
    <li><b>Упорядоченность</b>: Элементы массива располагаются в определенном порядке и доступ к ним осуществляется по индексу. Индексы массива начинаются с 0, то есть первый элемент имеет индекс 0, второй - индекс 1 и так далее.</li>
    <li><b>Динамическое изменение размера</b>: Массивы в JavaScript могут динамически изменять свой размер, добавлять новые элементы или удалять существующие. Нет необходимости задавать начальный размер массива при его создании.</li>
    <li><b>Разнородность данных</b>: Массивы в JavaScript могут содержать значения различных типов данных, например, числа, строки, булевы значения, объекты и даже другие массивы.</li>
    <li><b>Доступ к элементам</b>: Элементы массива могут быть доступны по их индексу с использованием квадратных скобок и индекса элемента. Например, <span class="code">array[0]</span> обращается к первому элементу массива.</li>
</ul>
<h4>Методы массивов</h4>
<pre><code class="language-javascript">//Метод push() - добавляет элементы в конец массива:
const fruits = ['apple', 'banana', 'orange'];
fruits.push('grape');
console.log(fruits); // Выводит ['apple', 'banana', 'orange', 'grape']</code></pre>
<pre><code class="language-javascript">// Метод pop() - удаляет последний элемент из массива и возвращает его:
const fruits = ['apple', 'banana', 'orange'];
const removedFruit = fruits.pop();
console.log(removedFruit); // Выводит 'orange'
console.log(fruits); // Выводит ['apple', 'banana']</code></pre>
<pre><code class="language-javascript">// Метод concat() - объединяет два или более массива:
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const combinedArray = array1.concat(array2);
console.log(combinedArray); // Выводит [1, 2, 3, 4, 5, 6]</code></pre>
<pre><code class="language-javascript">// Метод slice() - создает новый массив, содержащий выбранные элементы из исходного массива:
const fruits = ['apple', 'banana', 'orange', 'grape', 'mango'];
const slicedArray = fruits.slice(1, 4);
console.log(slicedArray); // Выводит ['banana', 'orange', 'grape']</code></pre>
<pre><code class="language-javascript">// Метод indexOf() - возвращает индекс первого вхождения заданного элемента в массиве:
const fruits = ['apple', 'banana', 'orange'];
const index = fruits.indexOf('banana');
console.log(index); // Выводит 1</code></pre>
<pre><code class="language-javascript">// Метод join() - объединяет все элементы массива в строку, разделенную указанным разделителем:
const fruits = ['apple', 'banana', 'orange'];
const joinedString = fruits.join(', ');
console.log(joinedString); // Выводит 'apple, banana, orange'</code></pre>
<p>Метод <span class="code">forEach</span> позволяется вызвать определенную функцию для всех элементов массива.</p>
<pre><code class="language-javascript">arr.forEach(function func(el, ind, arr) {
//код функции
});
</code></pre>
<pre><code class="language-javascript">let arr = [1, 2, 3, 4, 5];
arr.forEach(
    function plus_one(el) {
        console.log(el, "+", 1, "=", el + 1)
    }
)
</code></pre>
<p>Метод <span class="code">map</span> используется для того, чтобы создать новый массив из существующего, используя для каждого элемента функцию, переданную в метод map.</p>
<pre><code class="language-javascript">let arr = prompt().split(" ").map((n) => n ** 2)</code></pre>
<p>Метод <span class="code">filter</span> используется для того, чтобы создать новый массив из существующего, оставляя только те элементы, которые проходят через функцию-условие, которая передается в filter.</p>
<pre><code class="language-javascript">let arr = [1, 2, 3, 4, 5, 6, 7];

let arr2 = arr.filter(n => n % 2 === 0) // [ 2, 4, 6]</code></pre>
<h3>Операции</h3>
<pre><code class="language-javascript">// Операторы выполняют действия со значениями (операндами) и воспроизводят
// новое значение. Наиболее часто используемыми являются арифметические операторы:
3 + 2 // => 5: сложение
3 - 2 // => 1: вычитание
3 * 2 // => 6: умножение
3 / 2 // => 1.5: деление
points[1].x - points[0].x // => 1: можно использовать более сложные операнды
"3" + "2" // => "32": + складывает числа, объединяет строки
// В JavaScript имеются некоторые сокращенные формы арифметических операторов
var count = 0; // Объявление переменной
count++; // Увеличение значения переменной на 1
count--; // Уменьшение значения переменной на 1
count += 2; // Добавить 2: то же, что count = count + 2;
count *= 3; // Умножить на 3: то же, что count = count * 3;
count // => 6: имена переменных сами являются выражениями
// Операторы сравнения позволяют проверить два значения на равенство
// или неравенство, выяснить, какое значение меньше или больше, и т. д.
// Они возвращают значение true или false.
var x = 2, y = 3; // Знаки = выполняют присваивание, а не сравнение
x == y // => false: равенство
x != y // => true: неравенство
x < y // => true: меньше
x <= y // => true: меньше или равно
x > y // => false: больше
x >= y // => false: больше или равно
"two" == "three" // => false: две разных строки
"two" > "three" // => true: при упорядочении по алфавиту строка "tw" больше, чем "th"
false == (x > y) // => true: false равно false
// Логические операторы объединяют или инвертируют логические значения
(x == 2) && (y == 3) // => true: оба сравнения истинны. && - "И"
(x > 3) || (y < 3) // => false: оба сравнения ложны. || - "ИЛИ"
!(x == y) // => true: ! инвертирует логическое значение
</code></pre>
<p>Если фразы в языке JavaScript называются <i>выражениями</i>, то полные предложения называются <i>инструкциями</i></p>
<p><b>Выражение</b> – это конструкция, которая вычисляет значение, но ничего не делает: она никак не изменяет состояние программы.</p>
<p><b>Инструкции</b>, напротив, не имеют значения (или их значение не представляет интереса для нас), но они изменяют состояние программы.</p>
<p>Выше уже были показаны инструкции объявления переменных и присваивания значений. Еще одной обширной категорией инструкций являются <b>управляющие конструкции</b> такие, как условные инструкции и инструкции циклов.</p>

<h3>Функции</h3>
<p><b>Функция</b> – это именованный и параметризованный блок программного кода JavaScript, который определяется один раз, а использоваться может многократно.</p>
<p>Создание (определение) функции начинается с ключевого слова <span class="code">function</span>, после которого указываются следующие данные:</p>
<pre><code class="language-javascript">function function printText(a) {           //Определение функции
document.write(a);              //Тело функции - вывод содержимого переменной "а" в документ
};
printText("Hello World!");
</code></pre>
<p>При определении функции после ключевого слова может не быть имени.  Например мы можем объявить функцию из прошлого шага вот таким способом:</p>
<pre><code class="language-javascript">var printText = function(a) {document.write(a);};</code></pre>
<p>Функция может быть сразу вызвана с необходимым входным параметром. В следующем примере функция сразу будет вызвана - выведет в документ фразу "Hello World!". </p>
<pre><code class="language-javascript">var printedText = (function(a) {document.write(a);})("Hello World!");</code></pre>
<p></p>
<pre><code class="language-javascript">

</code></pre>
<p></p>
<pre><code class="language-javascript">

</code></pre>

<ol>
    <li><b>Имя функции</b>, которое будет использовано при создании переменной, которой будет присвоен объект нашей новой функции.</li>
    <li><b>Список входных параметров</b> в круглых скобках (их может и не быть).</li>
    <li><b>Тело функции</b> в фигурных скобках - собственно список исполняемых команд (также может отсутствовать) .</li>
</ol>
<pre><code class="language-javascript">// Функции - это параметризованные блоки кода JavaScript,
// которые мы можем вызывать.
function plus1(x){
    return x+1;
}
console.log(plus1(99))

let square = function(x) {
    return x*x;
}

console.log(square(plus1(10)))
// аналог лямбда-функций - стрелочные функции
const plus1 = x => x+1;
const square = x => x*x;
</code></pre>
<p>Функции являются объектами, и как следствие могут, например, присваиваться переменным, передаваться другим функциям, можно присваивать значения их свойствам и вызывать методы.</p>

<pre><code class="language-javascript">// В JavaScript имеются условные инструкции и инструкции циклов, синтаксически
// похожие на аналогичные инструкции C, C++, Java и в других языках.
function abs(x) { // Функция, вычисляющая абсолютное значение
if (x >= 0) { // Инструкция if ...
return x; // выполняет этот код, если сравнение дает true.
} // Конец предложения if.
else { // Необязательное предложение else выполняет свой код,
return -x; // если сравнение дает значение false.
} // Фигурные скобки можно опустить, если предложение
// содержит 1 инструкцию.
} // Обратите внимание на инструкции return внутри if/else.
function factorial(n) { // Функция, вычисляющая факториал
var product = 1; // Начать с произведения, равного 1
while(n > 1) { // Повторять инструкции в {}, пока выраж. в () истинно
product *= n; // Сокращенная форма выражения product = product * n;
n--; // Сокращенная форма выражения n = n - 1
} // Конец цикла
return product; // Вернуть произведение
}
factorial(4) // => 24: 1*4*3*2
function factorial2(n) { // Другая версия, использующая другой цикл
var i, product = 1; // Начать с 1
for(i=2; i <= n; i++) // i автоматически увеличивается с 2 до n
product *= i; // Выполнять в каждом цикле. {} можно опустить,
// если тело цикла состоит из 1 инструкции
return product; // Вернуть факториал
}
factorial2(5) // => 120: 1*2*3*4*5
</code></pre>

<h3>Методы</h3>
<pre><code class="language-javascript">// когда мы применяем функции к объектам, то получаем методы
let a= [];
a.push(1,2,3)
a.reverse();
console.log(a);
// объекту можно присвоить метод
let points=[
    {x:0,y:0},
    {x:1,y:1}
];
// ключевое слово ссылается на используемый объект
points.dist=function(){
    let p1 = this[0];
    let p2=this[1];
    let a = p2.x-p1.x;
    let b =p2.y-p1.y1;
    return Math.sqrt(a*a+b*b);
}
console.log(points.dist());
//классические функции
// модуль
function abs(x){
    if (x>=0){
        return x;
    }
    else{return -x;}
}
//сумма массива
function sum(array){
    let sum=0;
    for (let x of array){sum+=x;}
    return sum;
}
//факториал
function factorial(n){
    let product=1;
    while (n>1){
        product*=n;
        n--;
    }
    return product;
}

console.log(
    abs(-100),
    sum([1,2,3,4,5]),
    factorial(8)
);
</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<pre><code class="language-javascript">

</code></pre>

<h3>Численные методы</h3>
<pre><code class="language-javascript">console.log(
    Math.pow(2,53),
    Math.round( .6),
    Math.ceil(.6),
    Math.floor(.6),
    Math.abs(-5),
    Math.max(1,2,3 ),
    Math.min(1,2,3),
    Math.random(),
    Math.PI,
    Math.E,
    Math.sqrt(3),
    Math.pow(3, 1/3),
    Math.sin (0),
    Math.log(10),
    Math.exp(3),
    Math.cbrt(27),
    Math.hypot(3,4),
    Math.log10(100),
    Math.sign(-10),
    Math.trunc(3.9),
    Math.sinh(10)
);
let x=10;
Infinity // Переменная, доступная для чтения/записи,
 // инициализированная значением Infinity.
Number.POSITIVE_INFINITY // То же значение, доступное только для чтения.
1/0 // То же самое значение.
Number.MAX_VALUE + 1 // Это выражение также возвращает Infinity.
Number.NEGATIVE_INFINITY // Возвращают отрицательную бесконечность.
-Infinity
-1/0
-Number.MAX_VALUE - 1
NaN // Переменная, доступная для чтения/записи,
 // инициализированная значением NaN.
Number.NaN // Свойство, доступное только для чтения, с тем же значением.
0/0 // Возвращает NaN.
Number.MIN_VALUE/2 // Потеря значащих разрядов: возвращает 0
-Number.MIN_VALUE/2 // Отрицательный ноль
-1/Infinity // Также отрицательный ноль

var zero = 0; // Обычный ноль
var negz = -0; // Отрицательный ноль
zero === negz // => true: ноль и отрицательный ноль равны
1/zero === 1/negz // => false: Infinity и -Infinity не равны</code></pre>

<h3>ООП в JS</h3>
<pre><code class="language-javascript">// Определение функции-конструктора для инициализации нового объекта Point
function Point(x,y) { // По соглашению имя конструкторов начинается с заглавного символа
 this.x = x; // this - ссылка на инициализируемый объект
this.y = y; // Сохранить аргументы в свойствах объекта
} // Ничего возвращать не требуется
// Чтобы создать новый экземпляр, необходимо вызвать функцию-конструктор
// с ключевым словом "new"
var p = new Point(1, 1); // Точка на плоскости с координатами (1,1)
// Методы объектов Point определяются за счет присваивания функций свойствам
// объекта-прототипа, ассоциированного с функцией-конструктором.
Point.prototype.r = function() {
 return Math.sqrt( // Вернуть корень квадратный от x2 + y2
 this.x * this.x + // this - это объект Point, относительно которого...
 this.y * this.y // ...вызывается метод.
 );
};
// Теперь объект p типа Point (и все последующие объекты Point) наследует метод r()
p.r() // => 1.414...
</code></pre>

<h3>Идентификаторы</h3>
<p>Индентификатор - это просто имя. </p>
<pre><code class="language-javascript">//допустимые имена
i
my_variable_name
Wv13
_dummu
$str
</code></pre>
<p>Зарезервированные имена:</p>
<pre><code class="language-javascript">//ключевые слова
break delete function return typeof
case do if switch var
catch else in this void
continue false instanceof throw while
debugger finally new true with
default for null try
//зарезервированные для ECMAScript 5
class const enum export extends import super
// зарезервированы в строгом режиме
implements let private public yield
interface package protected static
arguments eval
//зарезервированные слова JAVA
abstract double goto native static
boolean enum implements package super
byte export import private synchronized
char extends int protected throws
class final interface public transient
const float long short volatile
//глобальные переменные
arguments encodeURI Infinity Number RegExp
Array encodeURIComponent isFinite Object String
Boolean Error isNaN parseFloat SyntaxError
Date eval JSON parseInt TypeError
decodeURI EvalError Math RangeError undefined
decodeURIComponent Function NaN ReferenceError URIError
</code></pre>
<h2>Ввод и вывод</h2>
<pre><code class="language-javascript">prompt() // выводит диалоговое окно с текстом сообщения и полем для ввода данны
confirm() // выводит диалоговое окно с текстом сообщения и двумя кнопками: "ОК" и "Отмена"
alert() // выводит сообщение в модальном окне
console.log('Это сообщение выводится в консоль') // выводит сообщение в консоль
</code></pre>
<h2>Переменные</h2>
<pre><code class="language-javascript">let message;
message = 'Hello'; // сохранить строку 'Hello' в переменной с именем message
alert(message); // показывает содержимое переменной
let user = 'Ban', age = 25, message = 'Hello'; // Мы также можем объявить несколько переменных в одной строке
</code></pre>
<p><b>Разница между let и var</b>: переменные, объявленные с помощью var имеют глобальную область видимости. Она может использоваться в любом месте функции/файла. Если переменная объявлена внутри функции, она будет видна только внутри этой функции.</p>
<p>Переменные, объявленные с помощью let, имеют блочную область видимости. Это означает, что переменная видна только внутри блока, в котором она была объявлена. Блоком может быть любая область кода, заключенная в фигурные скобки, включая циклы, условные операторы и функции.</p>
<pre><code class="language-javascript">const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
</code></pre>
<h2>Преобразование типов</h2>
<pre><code class="language-javascript">//преобразование строки в число
let str="123";
let num=parseInt(str);
console.log(str);
//преобразование числа в строку
let num=123;
let str = String(num);
typeof(str) //'string'
//явные преобразования
Number("3") // => 3
String(false) // => "false" или можно использовать false.toString()
Boolean([]) // => true
Object(3) // => new Number(3)
</code></pre>
<p>Интерпретатор JavaScript выполняет автоматическую сборку мусора для управления памятью. Это означает, что программист на JavaScript в основном не должен волноваться об уничтожении или освобождении объектов либо других значений. Когда значение больше не достижимо, т.е. программа не располагает ни одним способом ссылки на него, интерпретатору известно, что значение никогда не будет применяться снова, и он автоматически возвращает обратно занимаемую им память.</p>



<h3>Глобальные объекты</h3>
    <p><b>Глобальный объект</b> — это обыкновенный объект JavaScript, который служит крайне важной цели: его свойствами являются глобально определенные идентификаторы, доступные программе JavaScript. Когда интерпретатор JavaScript запускается (или всякий раз, когда веб-браузер загружает новую страницу), он создает новый глобальный объект и предоставляет ему начальный набор свойств, которые определяют:</p>
    <ul>
        <li>глобальные константы вроде <span class="code">undefined</span>, <span class="code">Infinity</span> и <span class="code">NaN</span>;</li>
        <li>глобальные функции наподобие <span class="code">isNaN()</span>, <span class="code">parseInt()</span> и <span class="code">eval()</span> </li>
        <li>функции конструкторов вроде <span class="code">Date()</span>, <span class="code">RegExp()</span>, <span class="code">String()</span>, <span class="code">Object()</span> и <span class="code">Array()</span> </li>
        <li>глобальные объекты наподобие <span class="code">Math</span> и <span class="code">JSON</span></li>
    </ul>

    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>





</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
</html>