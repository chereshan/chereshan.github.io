<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
  <title>Глава 3. JavaScript в веб-браузере</title>

</head>
<body>

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<div id="header"></div>
<h1>Глава 3. JavaScript в веб-браузере</h1>
<h2>Введение</h2>
<p>JS обладает арсеналом API-интерфейсов, которые позволят нашим web-приложениям:</p>
<ul>
    <li>управлять содержимым документа и стилями</li>
    <li>определять экранные позиции элементов документа</li>
    <li>создавать многократно используемые компоненты пользовательского интерфейса</li>
    <li>рисовать графические элементы</li>
    <li>воспроизводить и генерировать звуки</li>
    <li>организовывать навигацию и хронологию браузера</li>
    <li>обмениваться данными через сеть</li>
    <li>сохранять данные на компьютере пользователя</li>
    <li>выполнять параллельные вычисления с помощью потоков</li>
</ul>
<p>Фраза <i>"JavaScript стороны клиента"</i> в сущности синонимична просто коду JS, написанному для запуска в веб-браузере.</p>
<p>Некоторые примеры API-интерфейсов: <span class="code">innerHTML</span>, <span class="code">document.write()</span> (устарел из-за его огромного негативного влияния на производительность), и самый, пожалуй, важный их них - <b>DOM</b>.</p>

<h2>Скрипты JS в веб-документах</h2>
<p>Программы на языке JavaScript могут манипулировать содержимым документа через объект <span class="code">Document</span> и содержащиеся в нем объекты <span class="code">Element</span>. Они могут изменять визуальное представление содержимого, управляя стилями и классами CSS, и определять поведение элементов документа, регистрируя соответствующие обработчики событий.</p>
<p>Комбинация <i>управляемого содержимого</i>, <i>представления</i> и <i>поведения</i> называется <b>динамическим HTML</b> (Dynamic HTML, или DHTML).</p>
<p>Клиентский JS-код может встраиваться в HTML-документы 4 способами:</p>
<ol style="line-height: 150%">
    <li><b>встроенные скрипты в HTML-докупенте</b> между парой тегов <span class="code">script</span>;</li>
    <li><b>из внешнего файла</b>, заданного атрибутом <span class="code">src</span> тега <span class="code">script</span>;</li>
    <li><b>в обработчик события, заданный в качестве значения HTML-атрибута</b>, такого как <span class="code">onclick</span> или <span class="code">onmouseover</span></li>
    <li><b>как тело URL-адреса</b>, использующего специальный спецификатор псевдопротокола JavaScript (<i>сейчас редко используется</i>)</li>
</ol>
<p>Сейчас на уровне этикета <i>Ненавязчивого JS</i> (unobtrusive JS) принято разделять содержимое (разметка HTML) и поведение (код на JS). И потому при прочих равных предпочтительнее второй вариант (встраивание скрипта из внешнего файла с помощью атрибута <span class="code">src</span> тега <span class="code">script</span>).</p>
<h3>Элемент <span class="code">&lt;script></span></h3>
<p>Начнем с примера простого встраиваемого в HTML-документ кода - часов.</p>
<pre><code class="language-javascript">&lt;script> // Определение функции для отображения текущего времени
function displayTime() {
 var elt = document.getElementById("clock"); // Найти элемент с id="clock"
 var now = new Date(); // Получить текущее время
 elt.innerHTML = now.toLocaleTimeString(); // Отобразить его
 setTimeout(displayTime, 1000); // Вызвать снова через 1 сек.
}
window.onload = displayTime; // Начать отображение времени после загрузки документа.
&lt;/script>
&lt;/head>
&lt;body> &lt;!-- Тело - отображаемая часть документа -->
&lt;h1>Цифровые часы&lt;/h1> &lt;!-- Вывести заголовок -->
  &lt;span id="clock" style="
    font: bold 24pt sans;
    background: #ddf;
    padding: 10px;
    border: solid black 2px;
    border-radius: 10px;">
  &lt;/span>
&lt;/body>
</code></pre>
<script>
    // Определение функции для отображения текущего времени
    function displayTime() {
        var elt = document.getElementById("clock"); // Найти элемент с id="clock"
        var now = new Date(); // Получить текущее время
        elt.innerHTML = now.toLocaleTimeString(); // Отобразить его
        setTimeout(displayTime, 1000); // Вызвать снова через 1 сек.
    }
    window.addEventListener("load",displayTime, false); // Начать отображение времени после загрузки документа.
</script>
<span id="clock" style="font: bold 24pt sans;background: #ddf; padding: 10px;border: solid black 2px;border-radius: 10px;"></span> <!-- Время выводится здесь -->
<h3>Сценарии во внешних файлах</h3>
<p>Хотя код JavaScript можно встраивать прямо внутрь <span class="code">&lt;script></span>, с применением атрибута <span class="code">src</span> дескриптора. В данном атрибуте указывается URL (абсолютный URL или URL относительно URL, где находится отображаемый HTML-файл) файла, содержащего код JavaScript. Если мы изымем код JavaScript из HTML-файла и сохраним его в собственный файл scripts/digital_clock.js , то вот как дескриптор <span class="code">&lt;script></span> может ссылаться на файл кода:</p>
<pre><code class="language-html">&lt;script src="scripts/digital_clock.js"&lt;/script></code></pre>
<p>Код вызванный из внешнего файла и код вызванный непосредственно из HTML-документа ведут себя эквивалентно. Однако использование вызова JS-скрипта из внешнего файла обладает рядом преимуществ:</p>
<ul style="line-height: 130%">
    <li>Это делает HTML-документ читабельнее, позволяя убрать блоки кода и отделяя ссодержимое от поведения.</li>
    <li>Если один и тот же скрипт применяется в нескольких документах, то удобнее вызывать его из внешнего файла, который мможно поддерживать и имзенять в одном экземпляре.</li>
    <li>Если скрипт был уже загружен с 1 страницы, то со следующей страницы (где он есть) он может быть загружен из кеша браузера.</li>
    <li>Мы также можем вызывать скрипт других веб-серверов. </li>
</ul>
<h3>Запуск сценария: <span class="code">async</span> и <span class="code">defer</span></h3>
<p>Когда язык JavaScript впервые добавлялся в веб-браузеры, не существовало API-интерфейса для обхода и манипулирования структурой и содержимым уже визуализированного документа. Единственным способом воздействия кода JavaScript на содержимое документа была генерация содержимого на лету, пока документ находился в процессе загрузки. Цель достигалась за счет использования метода <span class="code">document.write()</span> для внедрения HTML-текста внутрь документа в месте нахождения сценария.</p>
<p>Когда <i>синтаксический анализатор HTML</i> встречает элемент <span class="code">&lt;script></span> , он обязан по умолчанию запустить сценарий, просто, чтобы удостовериться в отсутствии вывода любой HTML-разметки, прежде чем можно будет возобновить анализ и визуализацию документа. В итоге анализ и визуализация веб-страницы могут значительно замедлиться.</p>
<p>К счастью, такой стандартный <b>синхронный</b> или <b>блокирующий</b> режим выполнения сценария — не единственный вариант. Дескриптор <span class="code">&lt;script></span> может иметь атрибуты <span class="code">defer</span> и <span class="code">async</span>, которые заставляют сценарии выполняться по-разному. Они являются булевскими атрибутами, т.е. не имеют значения; им нужно лишь присутствовать в дескрипторе <span class="code">&lt;script></span> . Обратите внимание, что упомянутые атрибуты будут осмысленными, только когда используются в сочетании с атрибутом <span class="code">src</span>:</p>
<pre><code class="language-html">&lt;script defer src="deferred.js">&lt;/script>
&lt;script async src="async.js">&lt;/script></code></pre>
<p>Оба атрибута, <span class="code">defer</span> и <span class="code">async</span>, представляют собой способы сообщения браузеру о том, что в связанном сценарии не применяется метод <span class="code">document.write()</span> для генерации вывода HTML, вследствие чего браузер может продолжить синтаксический анализ и визуализацию документа во время загрузки сценария</p>
<p>Атрибут <span class="code">defer</span> заставляет браузер отложить выполнение сценария до тех пор, пока документ полностью не загрузится, будет проанализирован и станет готовым к манипуляциям.</p>
<p>Атрибут <span class="code">async</span> заставляет браузер запустить сценарий как можно раньше, но не блокировать анализ документа во время загрузки сценария. Когда <span class="code">&lt;script></span> содержит оба атрибута, приоритет имеет <span class="code">async</span></p>
<p>Отложенные сценарии запускаются в порядке, в котором они появляются в документе. Асинхронные сценарии запускаются по мере загрузки, т.е. могут выполняться не по порядку.</p>
<p>Сценарии с атрибутом <span class="code">type="module"</span> по умолчанию выполняются после загрузки документа, как если бы они имели атрибут <span class="code">defer</span>. Вы можете переодределить такое поведение посредством атрибута <span class="code">async</span>, который заставит код дополняться, как только модуль и все его зависимости будут загружены.</p>

<h3>Загрузка скриптов по запросу</h3>
<p>Иногда у вас может быть код JavaScript, который не используется при первой
    загрузке документа и необходим лишь тогда, когда пользователь предпринимает
    какое-то действие вроде щелчка на кнопке или открытия меню. </p>
<pre><code class="language-js">// Асинхронно загружает и выполняет сценарий из указанного URL.
// Возвращает объект Promise, который разрешается, когда сценарий загружен
function importScript(url) {
    return new Promise((resolve, reject) => {
        let s = document.createElement ("script"); // Создать элемент &lt;script>.
        s.onload =() => { resolve(); }; // Разрешить объект Promise, когда сценарий загружен,
        s.onerror = (е) => { reject(е); };// Отклонить объект Promise в случае неудачи.
        s.src = url; // Установить URL сценария,
        document.head.append(s); //Добавить &lt;script> в документ
        });
    }
    </code></pre>



<h2>Объектная модель документа</h2>
<p>HTML-документы содержат вложенные друг в друга HTML-элементы, формирующие дерево. Классы <span class="code">Element</span> и <span class="code">Text</span> и сам класс <span class="code">Document</span> являются подклассами более универсального класса <span class="code">Node</span>.</p>

<p>API-интерфейс DOM включает методы для создания новых узлов <span class="code">Element</span> и <span class="code">Text</span>, а также для их вставки в документ как дочерних по отношению к другим объектам <span class="code">Element</span>. Вдобавок есть методы для перемещения элементов внутри документа и для их полного удаления. В то время как приложение стороны сервера может производить простой текстовый вывод, записывая строки с помощью <span class="code">console.log()</span>.</p>

<p>Если суммировать, то DOM-модель разбивает части HTML-документа на отдельные объекты, у которых есть свойства и методы и каждым можно управлять с помощью JS. Продемонстрируем это с помощью простого примера:</p>
<pre><code class="language-html">&lt;script>
    //данная инструкция найдет и запишет текстом названия данного документа
    document.write(document.getElementsByTagName('title')[0].innerHTML)
&lt;/script></code></pre>
<p><b>⇒Вывод</b>:
<script>
    //данная инструкция найдет и запишет текстом названия данного документа
    document.write(document.getElementsByTagName('title')[0].innerHTML)
</script>
</p>

<h3>Глобальный объект в веб-браузерах</h3>
<p>Существует один глобальный объект для окна или вкладки браузера. Весь код JavaScript, выполняющийся в данном окне, разделяет единственный глобальный объект. Это верно вне зависимости от того, сколько скриптов или модулей имеется в документе: все скрипты и модули разделяют единственный глобальный объект; если один скрипт определяет свойство в глобальном объекте, то оно будет видимым также и всем остальным скриптам. </p>
<p>Именно в глобальном объекте определена стандартная библиотека JavaScript — функция <span class="code">parseInt()</span>, объект <span class="code">Math</span>, класс <span class="code">Set</span> и т.д. В веб-браузерах глобальный объект также содержит главные точки входа различных API-интерфейсов для веб-сети. Скажем, свойство <span class="code">document</span> представляет документ, отображаемый в текущий момент, метод <span class="code">fetch()</span> делает сетевые HTTP-запросы, а конструкт <span class="code">Audio()</span> позволяет программам JavaScript воспроизводить звуки.</p>
<p>В веб-браузерах глобальный объект выполняет двойную работу: в дополнение к определению встроенных типов и функций он также представляет текущее окно веб-браузера и определяет такие свойства, как <span class="code">history</span>, которое представляет хронологию просмотра окна, и <span class="code">innerWidth</span> хранящее ширину окна в пикселях. Одно из свойств глобального объекта называется <span class="code">window</span>, а его значением является сам глобальный объект. Таким образом, для ссылки на глобальный объект в коде стороны клиента вы можете просто набрать <span class="code">window</span>. При работе с функциями, специфичными для окна, часто бывает полезно включать префикс <span class="code">window.</span>: например, <span class="code">window.innerWidth</span> выглядит яснее, чем <span class="code">innerWidth</span>.</p>
<h3>Пространство имен скриптов</h3>
<p> Если код верхнего уровня определяет константу, переменную, функцию или класс, то такое определение будет видимым для всех остальных скриптов в том же самом документе. Если в одном скрипте определяется функция <span class="code">f()</span>, а в другом — класс <span class="code">с</span>, тогда в третьем скрипте можно вызывать функцию <span class="code">f()</span> и создавать экземпляр класса <span class="code">с</span>, не предпринимая никаких действий по их импортированию. Таким образом, если вы не применяете модули, тогда независимые скрипты в вашем документе разделяют единственное пространство имен и ведут себя так, словно они все являются частью одного крупного скрипта. Для небольших программ это может быть удобно, но избегание конфликтов имен нередко становится проблематичным в более крупных программах, особенно когда некоторые скрипты относятся к сторонним библиотекам.</p>
<p>Существует ряд исторически сложившихся особенностей работы такого разделяемого пространства имен. Объявления <span class="code">var</span> и <span class="code">function</span> на верхнем уровне создают свойства в разделяемом глобальном объекте. Если в одном скрипте на верхнем уровне определена функция <span class="code">f()</span>, то другой скрипт в том же документе может вызывать ее как <span class="code">f()</span> или как <span class="code">window.f()</span>. С другой стороны, объявления <span class="code">const</span>, <span class="code">let</span> и <span class="code">class</span> из ES6 на верхнем уровне не создают свойств в глобальном объекте. Однако они по-прежнему определены в разделяемом пространстве имен: если в одном сценарии определяется класс <span class="code">С</span>, то другие сце нарии будут иметь возможность создавать экземпляры класса С посредством new <span class="code">С()</span>, но не <span class="code">new window.С()</span>.</p>
<p>Более старые объявления <span class="code">var</span> и <span class="code">function</span> разделяются через свойства глобального объекта. Более новые объявления <span class="code">const</span>, <span class="code">let</span> и <span class="code">class</span> также разделяются и имеют ту же область видимости документа, но не существуют в виде свойств какого-то объекта к которому код JavaScript имел бы доступ.</p>
<h2>Выполнение программ JS</h2>
<p>Формальное определение программы в JavaScript стороны клиента отсутствует, но мы можем сказать, что программа JavaScript состоит из всего кода JavaScript, который находится или на который производится ссылка в документе. Эти отдельные фрагменты кода разделяют единственный глобальный объект <span class="code">window</span>, который дает им доступ к одному и тому же внутреннему объекту <span class="code">Document</span>, представляющему HTML-документ. Немодульные скрипты дополнительно разделяют пространство имен верхнего уровня.</p>
<p>Если веб-страница включает встроенный фрейм (используя элемент <span class="code">&lt;iframe></span>), то код JavaScript во встроенном документе имеет не такой глобальный объект и объект <span class="code">Document</span>, как код в документе, содержащем встроенный документ, и может считаться отдельной программой JavaScript. Однако вспомните, что не существует формального определения границ программы JavaScript. Если контейнерный документ и содержащийся в нем документ загружаются с того же самого сервера, то код в одном документе может взаимодействовать с кодом в другом документе, и при желании вы можете трактовать их как две взаимодействующие части одной программы.</p>
<p>Вы можете считать, что выполнение программы JavaScript происходит в два этапа:</p>
<ul>
    <li>Загружается содержимое документа и запускается код из элементов <span class="code">&lt;script></span> (как встроенные, так и внешние скрипты). Сценарии обычно запускаются в порядке, в котором они появляются в документе, хотя такой стандартный порядок можно изменять с помощью описанных ранее атрибутов async и <span class="code">defer</span>. Код JavaScript внутри любого отдельного скрипта выполняется сверху вниз, подчиняясь, конечно же, условным операторам, циклам и другим управляющим операторам JavaScript. Некоторые скрипты в действительности ничего не делают на первом этапе, а просто определяют функции и классы для применения на втором этапе. Другие скрипты могут выполнять значительный объем работ на первом этапе и ничего не делать на втором. Вообразим себе скрипт в самом конце документа, который ищет все дескрипторы <span class="code">&lt;h1></span> и <span class="code">&lt;h2></span> в документе и модифицирует документ, генерируя и вставляя оглавление в начало документа. Всю работу можно было бы сделать на первом этапе. </li>
    <li>После того, как документ загружен, и все сценарии выполнены, выполнение программы JavaScript переходит ко второму этапу, который является асинхронным и управляемым событиями. Если сценарий собирается принимать участие втором этапе, то тогда одним из действий, которое он обязан предпринять на первом этапе, должна быть регистрация, по крайней мере, одной функции обработчика событий или другой функции обратного вызова, которая будет вызываться асинхронно. На этом втором управляемом событиям и этапе веб-браузер вызывает функции обработчиков событий и другие обратные вызовы в ответ на события, которые происходят асинхронно. Обработчики событий чаще всего вызываются в ответ на пользовательский ввод (щелчки кнопками мыши, нажатия клавиш и т.д.), но многие также запускаются активностью сети, загрузкой документов и ресурсов, истекшим временем или ошибкам и в коде JS.</li>
</ul>
<p>В число первых событий, которые происходят на управляемом событиями этапе, входят события <span class="code">DOMContentLoaded</span> и <span class="code">load</span>. Событие <span class="code">DOMContentLoaded</span> инициируется, когда HTML-документ был полностью загружен и синтаксически проанализирован. Событие <span class="code">load</span> инициируется, когда все внешние ресурсы документа, такие как изображения, также полностью загружены. Программы JavaScript часто используют одно из указанных событий в качестве спускового механизма или стартового сигнала. Вполне обычно видеть программы, сценарии которых определяют функции, но не предпринимают никаких действий, кроме регистрации функции обработчика событий, подлежащего запуску событием <span class="code">load</span> в начале управляемого событиями этапа выполнения. Именно этот обработчик событий <span class="code">load</span> затем манипулирует документом и делает все то, что должна делать программа. Следует отметить, что в программировании на JavaScript функция обработчика событий наподобие описанного здесь обработчика событий <span class="code">load</span> часто регистрирует другие обработчики событий.</p>
<p>Этап загрузки программы JavaScript относительно короткий: в идеале меньше секунды. После того как документ загружен, управляемый событиям этап длится до тех пор, пока документ отображается веб-браузером. Поскольку этот этап асинхронный и управляемый событиями, могут случаться длительные периоды бездействия, когда ни какой код JavaScript не выполняется, перемежающиеся всплескам и активности, которые вызваны событиями от пользователя или сети.</p>
<h3>Потоковая модель JS стороны клиента</h3>
<p>JavaScript — <b>однопоточный</b> язык, а однопоточное выполнение значительно упрощает программирование: вы можете писать код с уверенностью, что два обработчика событий никогда не запустятся одновременно. Вы можете манипулировать содержимым документа, зная о том, что никакой другой поток не попытается его модифицировать в то же самое время, и при написании кода JavaScript вам никогда не придется беспокоиться о блокировках, взаимоблокировках или состязаниях.</p>
<p>Однопоточное выполнение означает, что во время выполнения сценариев и обработчиков событий веб-браузеры перестают реагировать на пользовательский ввод. В итоге ответственность возлагается на программистов на JavaScript. Это значит, что сценарии и обработчики событий JavaScript не должны выполняться слишком долго. Если сценарий выполняет задачу с интенсивными вычислениями, то он внесет задержку в загрузку документа и пользователь не увидит содержимое документа до тех пор, пока сценарий не завершится. Если обработчик событий выполняет задачу с интенсивными вычислениями, то браузер может перестать реагировать, что возможно заставит пользователя думать о его аварийном отказе.
</p>
<p>Веб-платформа определяет управляемую форму параллелизма, называемую “веб-воркером” (<b>web worker</b>). <b>Веб-воркер</b> — это фоновый поток для выполнения задач с интенсивными вычислениями без замораживания пользовательского интерфейса. Код, который выполняется в потоке веб-воркера, не имеет доступа к содержимому документа, не разделяет никакого состояния с главным потоком или другими веб-воркерами и может взаимодействовать с главным потоком и другими веб-воркерами только посредством событий асинхронных сообщений. Таким образом, параллелизм не поддается обнаружению главным потоком, а веб-воркеры не меняют базовую модель однопоточного выполнения программ JavaScript.</p>
<h3>Временная шкала JS стороны клиента</h3>
<p>Вы уже видели, что программы JavaScript начинаются с этапа выполнения сценариев и затем переходят к этапу обработки событий. Указанные два этапа можно дополнительно разбить на следующие шаги.</p>
<ol style="border: solid 1px;">
    <li>Веб-браузер создает объект <span class="code">Document</span> и начинает синтаксический анализ веб-страницы, добавляя в документ объекты <span class="code">Element</span> и узлы <span class="code">Text</span> по мере того, как он анализирует HTML-элементы и их текстовое содержимое. Свойство <span class="code">document.readyState</span> имеет на этом этапе значение <span class="code">loading</span> (загружается).</li>
    <li>Когда синтаксический анализатор HTML встречает дескриптор <span class="code">&lt;script></span>, который не имеет атрибутов <span class="code">async</span>, <span class="code">defer</span> или <span class="code">type="module"</span>, он добавляет такой дескриптор сценария в документ и затем запускает сценарий. Сценарий выполняется синхронно, а синтаксический анализатор HTML приостанавливает работу на время загрузки (при необходимости) и выполнения сценария. В сценарии подобного рода может использоваться метод <span class="code">document.write()</span> для вставки текста во входной поток, и такой текст станет частью документа, когда синтаксический анализатор возобновит работу. В сценарии такого рода часто просто определяются функции и регистрируются обработчики событий для будущего применения, но можно обходить и манипулировать деревом документа в том виде, в каком оно существует в данный момент. То есть немодульный сценарий, который не имеет атрибута async или defer, может видеть собственный дескриптор <span class="code">&lt;script></span> и содержимое документа, находящееся перед ним.</li>
    <li>Когда синтаксический анализатор встречает элемент <span class="code">&lt;script></span>, который имеет установленный атрибут <span class="code">async</span>, он начинает загрузку текста сценария (и если сценарий является модулем, то также рекурсивно загружаются все зависимости сценария) и продолжает анализ документа. Сценарий будет выполнен как можно скорее после окончания его загрузки, но синтаксический анализатор не останавливает работу в ожидании загрузки сценария. В асинхронных сценариях не должен использоваться метод <span class="code">document.write()</span>. Они могут видеть собственные дескриптору <span class="code">&lt;script></span> и все содержимое документа, находящееся перед ними, и могут иметь или не иметь доступ к дополнительному содержимому документа.</li>
    <li>Когда документ полностью проанализирован, значение свойства
        <span class="code">document.readyState</span> изменяется на <span class="code">interactive</span> (взаимодействует).
    </li>
    <li>Любые сценарии, которые имеют установленный атрибут <span class="code">defer</span> (наряду с любыми модульными сценариями, не имеющими атрибута <span class="code">async</span>), выполняются в том порядке, в каком они появляются в документе. В это время также могут выполняться асинхронные сценарии. Отложенные сценарии имеют доступ к полному документу и в них не должен применяться метод <span class="code">document.write()</span>.
    </li>
    <li>Браузер инициирует событие <span class="code">DOMContentLoaded</span> для объекта <span class="code">Document</span>. Это знаменует переход от синхронного этапа выполнения сценариев к асинхронному управляемому событиями этапу выполнения программы. Тем не менее, имейте в виду, что все еще могут существовать асинхронные сценарии, которые в данной точке пока не выполнены.</li>
    <li> В этот момент документ полностью проанализирован, но браузер по-прежнему может ожидать загрузки дополнительного содержимого, такого как изображения. Когда загрузка всего содержимого такого рода завершена, а все асинхронные сценарии загружены и выполнены, значение свойства <span class="code">document.readyState</span> изменяется на <span class="code">complete</span> (укомплектован) и веб-браузер инициирует событие <span class="code">load</span> для объекта <span class="code">Window</span>.
    </li>
    <li>С этого момента обработчики событий вызываются асинхронно в ответ на
        события пользовательского ввода, события сети, события истечения таймера и т.д.</li>
</ol>
<p>На рисунке ниже представлена временная шкала описанных выше событий:</p>
<object data="images/window_events.svg" type="image/svg+xml"></object>
<p>C использованием API навигации по таким событиям (?) мы можем реализовать временную шкалу событий для данной страницы:</p>
<script>
    let loadevents = ['startTime','redirectStart','redirectEnd', 'workerStart','fetchStart', 'domainLookupStart','domainLookupEnd','connectStart','secureConnectionStart','connectEnd','requestStart','responseStart','responseEnd', 'unloadEventStart', 'unloadEventEnd', 'domInteractive', 'domContentLoadedEventStart', 'domContentLoadedEventEnd', 'domComplete', 'loadEventStart', 'loadEventEnd']
    $(document).ready(function(){

        let perftime=window.performance.getEntriesByType("navigation")[0]
        for (key of loadevents){
            //if (perftime[key]!=0 && typeof(perftime[key])=="number")
            $('#key_events ol').append(`<li id="list_${key}">${key + ": " + perftime[key]}</li>`)}
    })
</script>
<!--todo: решить проблему того, что функция начинает слушать еще до domComplete, loadEventStart, loadEventEnd-->
<div id="key_events" style="border: solid black;">
<ol><b>Время наступления событий на этой странице:</b></ol>
</div>
<pre><code class="language-html">&lt;script>
let loadevents = ['startTime','redirectStart','redirectEnd', 'workerStart','fetchStart', 'domainLookupStart','domainLookupEnd','connectStart','secureConnectionStart','connectEnd','requestStart','responseStart','responseEnd', 'unloadEventStart', 'unloadEventEnd', 'domInteractive', 'domContentLoadedEventStart', 'domContentLoadedEventEnd', 'domComplete', 'loadEventStart', 'loadEventEnd']
$(document).ready(function(){
    let perftime=window.performance.getEntriesByType("navigation")[0]
    for (key of loadevents){
        $('#key_events ol').append(`&lt;li id="${key}">${key + ": " + perftime[key]}&lt;/li>`)}
    })
&lt;/script></code></pre>

<h3>Основные источники входных данных</h3>
<ul>
    <li>Содержимое самого документа, доступ к которому код JavaScript может
        получать через API-интерфейс DOM.</li>
    <li>Пользовательский ввод в форме событий, такой как щелчки кнопками
        мыши (или касания сенсорного экрана) на HTML-элементах <span class="code">&lt;button></span> или текст, введенный в HTML-элементах <span class="code">&lt;textarea></span>.</li>
    <li>URL отображаемого документа доступен в коде JavaScript стороны клиента
        как <span class="code">document</span>. URL. Если вы передадите эту строку конструктору URL, то легко сможете получить доступ к частям пути, запроса фрагмента URL.</li>
    <li>Содержимое HTTP-заголовка <span class="code">Cookie</span> запроса доступно в коде JavaScript стороны клиента как document.cookie. Cookie-наборы обычно используются кодом стороны сервера для поддержки пользовательских сеансов, но код стороны клиента при необходимости также может их читать (и записывать).</li>
    <li>Глобальный объект <span class="code">navigator</span> предоставляет доступ к информации о веб-браузере, об операционной системе, под управлением которой он функционирует, и об их возможностях. Например, <span class="code">navigator.userAgent</span> — это строка, идентифицирующая веб-браузер, <span class="code">navigator.language</span> — предпочитаемый пользователем язык и <span class="code">navigator.hardwareConcurrency</span> — количество логических центральных процессоров, доступных веб-браузеру. Аналогично глобальный объект <span class="code">screen</span> предоставляет доступ к размеру дисплея пользователя через свойства <span class="code">screen.width</span> и <span class="code">screen.height</span>. В некотором смысле объекты <span class="code">navigator</span> и <span class="code">screen</span> являются для веб-браузеров тем же, чем переменные среды для программ Node.</li>
</ul>

<h3>Ошибки в программе</h3>
<p>В отличие от приложений (таких как приложения Node), которые выполняются непосредственно под управлением операционной системы, <i>программы JavaScript в веб-браузере не могут по-настоящему “отказать”</i>. Если во время выполнения вашей программы JavaScript возникает исключение, а вы не предусмотрели оператор <span class="code">catch</span> для его обработки, тогда в консоли инструментов разработчика отобразится сообщение об ошибке, но все зарегистрированные обработчики событий продолжат выполняться и реагировать на события.</p>
<p>Если вы хотите определить обработчик ошибок для вызова в качестве последнего средства при возникновении неперехваченного исключения такого рода, тогда установите свойство <span class="code">onerror</span> объекта <span class="code">Window</span> в функцию обработчика ошибок. Когда неперехваченное исключение распространится вверх по стеку вызовов до самого конца и сообщение об ошибке готово отобразиться в консоли инструментов разработчика, функция <span class="code">window.onerror</span> будет вызвана с тремя строковыми аргументами. В первом аргументе <span class="code">window.onerror</span> передайся сообщение, описывающее ошибку. Второй аргумент — это строка, которая содержит URL кода JavaScript, вызвавшего ошибку. В третьем аргументе указывается номер строки внутри документа, где возникла ошибка. Если обработчик <span class="code">onerror</span> возвращает <span class="code">true</span>, то тем самым уведомляет браузер о том, что ошибка обработана и нет необходимости в добавочном действии — другими словами браузер не должен отображать собственное сообщение об ошибке. </p>
<p>Когда объект <span class="code">Promise</span> отклоняется и отсутствует функция <span class="code">.catch()</span> для его обработки, возникает ситуация, во многом похожая на необработанное исключение: непредвиденная или логическая ошибка в вашей программе. Вы можете обнаружить это, определив функцию <span class="code">window.onunhandledrejection</span> или применив <span class="code">window.addEventListener()</span> для регистрации обработчика событий “необработанных отклонений”. Передаваемый такому обработчику объект события будет иметь свойство <span class="code">promise</span>, значением которого является отклоненный объект <span class="code">Promise</span>, и свойство <span class="code">reason</span> со значением, которое передавалось бы функции <span class="code">.catch()</span>. Как и в случае описанных ранее обработчиков ошибок, если вы вызовите <span class="code">preventDefault()</span> на объекте события необработанного отклонения, то оно будет считаться обработанным и не приведет к отображению сообщения об ошибке в консоли инструментов разработчика</p>
<p>Определять обработчики <span class="code">onerror</span> или <span class="code">onunhandledrejection</span> придется нечасто, но они могут оказаться полезными в качестве механизма удаленного измерения, если вы хотите сообщать серверу об ошибках на стороне клиента (скажем, используя функцию <span class="code">fetch()</span> для выполнения HTTP-запроса POST). Такой подход позволит получать информацию о непредвиденных ошибках, которые возникали в браузерах пользователей.</p>
<h3>Что не может делать JavaScript стороны клиента</h3>
<p>JavaScript стороны клиента не предоставляет никаких способов записи или удаления произвольных файлов либо получения списка произвольных каталогов на клиентском компьютере. Это означает, что программа JavaScript не может удалять данные или внедрять вирусы.</p>
<p>Точно так же JavaScript стороны клиента не располагает универсальными сервеными возможностями. Программа JavaScript стороны клиента может делать HTТР-запросы. А еще один стандарт, известный как WebSocket, определяет похожий на сокеты API-интерфейс для взаимодействия со специализированными серверами. Но ни один из таких интерфейсов не разрешает непосредственный доступ к более широкой сети. Универсальные клиенты и серверы Интернета не могут быть написаны на JavaScript стороны клиента</p>
<h4>Политика одного источника</h4>
<p><b>Политика одинакового источника</b> (the same-origin policy) — это обширное ограничение безопасности, касающееся того, с каким веб-содержимым может взаимодействовать код JavaScript. Она обычно вступает в игру, когда веб-страница включает элементы <span class="code">&lt;iframe></span>. В таком случае политика одинакового источника управляет взаимодействием кода JavaScript в одном фрейме с содержимым других фреймов. В частности, сценарий может читать только свойства окон и документов, которые происходят из того же источника, что и документ, содержащий сценарий.</p>
<p>Источник документа определяется как протокол, хост и порт URL, откуда документ был загружен.</p>
<ul>
    <li>Документы, загруженные из разных веб-серверов, имеют отличающиеся источники.</li>
    <li>Документы, загруженные через разные порты того же самого хоста, имеют отличающиеся источники.</li>
    <li> И документ, загруженный посредством протокола <span class="code">http:</span>, имеет источник, отличающийся от источника документа, который загружен с помощью протокола <span class="code">https:</span>, даже если они поступали из того же самого веб-сервера. </li>
    <li>Браузеры обычно трактуют каждый URL типа <span class="code">file:</span> как отдельный источник, так что если вы трудитесь над программой, которая отображает более одного документа из того же самого сервера, то возможно не сумеете протестировать ее локально с применением URL типа <span class="code">file:</span> и будете вынуждены запускать статический веб-сервер во время разработки</li>
</ul>
<p>Важно понимать, что источник самого сценария не имеет отношения к политике одинакового источника: имеет значение источник документа, в который встроен сценарий. Предположим, например, что сценарий, размещенный на хосте А, включен (с использованием свойства src элемента <span class="code">&lt;script></span>) в веб-страницу, обслуживаемую хостом В. Источником данного сценария является хост В, и сценарий получает полный доступ к содержимому документа, куда он внедрен. Если документ имеет элемент <span class="code">&lt;ifrаmе></span>, который содержит второй документ из хоста В, тогда сценарий получает полный доступ и к содержимому второго документа. Но если документ верхнего уровня содержит еще один элемент <span class="code">&lt;ifrаmе></span>, отображающий документ из хоста С (или даже из хоста А), то политика одинакового источника вступает в силу и предотвращает доступ сценария к этому вложенному документу.</p>
<p>Политика одинакового источника также применяется к сценарным НТТР-запросам. В коде JavaScript можно выполнять произвольные HTTP-запросы к веб-серверу, из которого был загружен содержащий документ, но сценариям не разрешено взаимодействовать с другими веб-серверам
    (если только такие веб-серверы не принимают участие в CORS, как будет опи*
    сано далее).</p>
<p>Политика одинакового источника создает проблемы для крупных веб-сай
    тов, которые используют множество поддоменов. Скажем, сценарии с источни
    ком o r d e r s . exam ple. com могут нуждаться в чтении свойств из документов в
    exam ple. com. Чтобы поддерживать многодоменные веб-сайты подобного р0да
    сценарии могут изменять свой источник, устанавливая docum ent. domain в
    суффикс домена</p>
<p>Таким образом, сценарий с источником h ttp s ://o r d e r s .e x a m p le .c o m
    может изменить свой источник на h ttp s ://e x a m p le .c o m за счет установки
    docum ent .dom ain в "exam ple, com". Но сценарий не может устанавливать
    docum ent. domain в "o rd ers.ex am p le", "ample.com" или "com".
</p>
<p>торой методикой ослабления политики одинакового источника является
    совместное использование ресурсов между разными источниками (cross-origin
    resource sharing — CORS), которое позволяет серверам решать, какие источники они готовы обслуживать. CORS расширяет HTTP новым заголовком запроса O rig in : и новым заголовком ответа A ccess-C ontrol-A llow -O rigin.
    Методика CORS дает возможность серверам применять заголовок для явного
    перечисления источников, которые могут запрашивать файл, или использовать групповой символ и разрешать файлу быть запрошенным любым сайтом.
    Браузеры принимают во внимание заголовки CORS и в случае их отсутствия не
    ослабляют политику одинакового источника.
</p>
<h3>Межсайтовые сценарии</h3>
<p>Межсайтовые сценарии (cross-site scripting — XSS) — это термин для обозначения категории проблем, связанных с безопасностью, когда атакующий внедряет HTML-дескрипторы в целевой веб-сайт. Программисты на JavaScript стороны
    клиента обязаны знать о межсайтовых сценариях и защищаться от них.</p>
<p>Веб-страница уязвима для межсайтовых сценариев, если она динамически генерирует содержимое документа и основывает такое содержимое на данных, отправленных пользователем, без предварительной “очистки” данных за счет удаления из них любых внедренных HTML-дескрипторов. В качестве тривиального
    примера рассмотрим следующую веб-страницу, которая применяет JavaScript
    для приветствия пользователя по имени:
</p>
&lt;script>
    let name = new URL (document .URL). sear chParams. get ("name");
    document.querySelector('hi').innerHTML = "Hello " + name;
&lt;/script>

<p>Показанный двухстрочный сценарий извлекает входные данные из пара
    метра запроса "name", указанного в URL документа. Затем он использует А
    интерфейс DOM для внедрения HTML-строки в первый дескриптор <hl> вНУт
        ри документа. Страница предназначена для вызова посредством URL вида:
        http: / /www. example. com/greet. html?name=David</p>
<p>flpn таком использовании она отображает текст "H ello David". Но посмотрйМ> что происходит, когда страница вызывается с таким параметром запроса:
    naitie=%3Cimg%20src=%22x.png%22%20onload=%22alert (%27hacked%27) %22/%ЗЕ
    Когда параметры будут декодированы, URL вызовет внедрение в документ
    ^дукицей HTML-разметки:
    Hello <img src="x.png" onload="alert ('hacked’) "/>
    После загрузки изображения выполняется строка кода JavaScript в атрибуте
    onload- Глобальная функция a l e r t () отображает модальное диалоговое окно.
    Появление одиночного диалогового окна относительно безболезненно, но демонстрирует возможность выполнения на этом сайте произвольного кода, потому что он отображает неочищенную HTML-разметку.
    Атаки межсайтовыми сценариями называются так из-за того, что в них вовлечено более одного сайта. Сайт В включает специально изготовленную ссылку
    (подобную той, что была в предыдущем примере) на сайт А. Если сайт В сумеет
    убедить пользователей щелкнуть на ссылке, тогда они попадут на сайт А, но
    этот сайт теперь будет выполнять код из сайта В. Такой код может повредить
    страницу или заставить ее неправильно работать. Более опасно то, что вредоносный код мог бы прочитать cookie-наборы, сохраненные сайтом А (возможно,
    номера счетов или другую персональную идентифицирующую информацию), и
    отправить полученные данные сайту В. Внедренный код мог бы даже отслеживать нажатые пользователем клавиши и отправлять такие данные сайту В.
    В целом способ предотвращения атак XSS предусматривает удаление HTMLдескрипторов из любых ненадежных данных до их применения при создании
    содержимого динамического документа. Вы можете исправить приведенный
    ранее файл g r e e t . htm l, заменив специальные символы HTML в ненадежной
    входной строке эквивалентными сущностями HTML:</p>
<p>паше = паше
    .replace(/&/g, "Samp;")
    .replace(/</g, "&lt;n)
    .replace(/>/g, "&gt;n)
    .replace(/”/g, "&quot;")
    .replace( / ' / g , ”&#x27;")
    .replace(/\//g, "&#x2F;")
</p>
<p>ще один подход к решению проблемы с атаками XSS заключается в структУРировании веб-приложений, чтобы ненадежное содержимое всегда отображаюсь в элементе <ifram e> с атрибутом sandbox, установленным для запрета
    ВьШолнения сценариев и других возможностей</p>
<p>Межсайтовые сценарии — это опасная уязвимость, корни которой уходят
    ГлУб°ко в архитектуру веб-сети. Ее стоит досконально понимать, но дальнейшее
    Осуждение выходит за рамки настоящей книги. Существует много онлайновых
    Ресурсов> которые помогут вам защититься от межсайтовых сценарие</p>

<h2>Клиентский JS</h2>

<p>Объект <span class="code">window</span> - это окно веб-браузер. Он определяет свойства, например, <span class="code">location</span>, которые ссылаются на объект <span class="code">Location</span>, определяющий URL текущего окна, и позволяет сценарию загружать в окно содержимое других адресов </p>
<pre><code class="language-javascript">// Установить значение свойства для переход на новую веб-страницу
window.location = "http://www.oreilly.com/";</code></pre>
<p>На <a href="#js_access">рис. ниже</a> показано, что доступно JS в браузерном окуржении.</p>
<p>    Как мы видим, имеется корневой объект <span class="code">window</span>, который выступает в 2 ролях:</p>
<ol>
    <li>Во-первых, это глобальный объект для JavaScript-кода.</li>
    <li>Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.</li>
</ol>
<img id="js_access" src="images/js_acces.png" alt="Доступ из объекта window">
<p>Также объект <span class="code">Window</span> определяет методы, такие как <span class="code">alert()</span>, который отображает диалог с сообщением, и <span class="code">setTimeout()</span>, которые регистрирует функцию для вызова через указанный промежуток времени.</p>
<pre><code class="language-javascript">// ждать 2 секунды и вывести диалог с приветствием
setTimeout(function() { alert("Привет, Мир!"); }, 2000);</code></pre>
<p>Объект <span class="code">Window</span> <b>глобальный</b>, т.е. он находится на вершине областей видимости и его свойства и методы - глобальные переменные и функции. </p>
<p>Важным свойством объекта <span class="code">Window</span> является свойство <span class="code">document</span>, которое ссылается на объект <span class="code">Document</span>, которые в свою очередь представляет содержимое объекта, отображаемого в окне. Его методом является, например, <span class="code">getElementById()</span>, которые возвращает единственный элемент документа (пару открывающихся и закрывающихся тегов) по его id и все, что содержится между ними.</p>
<pre><code class="language-javascript">// Отыскать элемент с атрибутом id="timestamp"
var timestamp = document.getElementById("timestamp");</code></pre>
<p>Здесь возвращается объект <span class="code">Element</span>, который также имеет ряд важных свойств и методов, позволяющих скрипту извлекать содержимое элемента и устанавливать значение его атрибутов.</p>
<pre><code class="language-javascript">// Если элемент пуст, вставить в него текущую дату и время
if (timestamp.firstChild == null)
 timestamp.appendChild(document.createTextNode(new Date().toString()));</code></pre>
<p>Каждый объект <span class="code">Element</span> имеет свойства <span class="code">style</span> и <span class="code">className</span>, позволяющие определять стили CSS или изменять имена классов CSS, применяемых к элементу. Это позволяет изменять визуальное представление элемента документа:</p>
<pre><code class="language-javascript">// Явно изменить представление элемента заголовка
timestamp.style.backgroundColor = "yellow";
// Или просто изменить класс и позволить определять особенности
// визуального представления с помощью каскадных таблиц стилей:
timestamp.className = "highlight";</code></pre>
<p>Другим важным множеством свойств объектов <span class="code">Window</span>, <span class="code">Document</span> и <span class="code">Element</span> являются свойства, ссылающиеся на <b>обработчики событий</b>. Они позволяют сценариям определять функции, которые должны вызываться асинхронно при возникновении определенных событий. Обработчики событий позволяют программам на языке JavaScript изменять поведение окон, документов и элементов, составляющих документы. Свойства, ссылающиеся на обработчики событий, имеют имена, начинающиеся с «on», и могут использоваться, как показано ниже:</p>
<pre><code class="language-javascript">// Обновить содержимое элемента timestamp, когда пользователь щелкнет на нем
timestamp.onclick = function() { this.innerHTML = new Date().toString(); }</code></pre>
<p>Одним из наиболее важных обработчиков событий является обработчик <span class="code">onload</span> объекта <span class="code">Window</span>. Это событие возникает, когда содержимое документа, отображаемое в окне, будет загружено полностью и станет доступно для выполнения манипуляций. Программный код на языке JavaScript обычно заключается в обработчик события <span class="code">onload</span>. <a href="#ex1">Пример</a> использует обработчик onload и демонстрирует дополнительные приемы получения ссылок на элементы документа, изменения классов CSS и определения обработчиков других событий в клиентском JavaScript. В этом примере программный код на языке JavaScript заключен в HTML-тег <span class="code">script</span>. Обратите внимание, что в этом примере имеется определение функции, заключенное в определение другой функции. Вложенные функции часто используются в клиентских сценариях на языке JavaScript, особенно в виде обработчиков событий.</p>
<pre><code id="ex1" class="language-html">//открывающийся элемент
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
&lt;style>
/* Стили CSS для этой страницы */
.reveal * { display: none; } /* Элементы с атрибутом class="reveal" невидимы */
.reveal *.handle { display: block;} /* Кроме элементов с class="handle" */
&lt;/style>
&lt;script>
// Ничего не делать, пока документ не будет загружен полностью
window.onload = function() {
  // Отыскать все контейнерные элементы с классом "reveal"
  var elements = document.getElementsByClassName("reveal");
  for(var i = 0; i &lt; elements.length; i++) { // Для каждого такого элемента...
    var elt = elements[i];
    // Отыскать элементы с классом "handle" в контейнере
    var title = elt.getElementsByClassName("handle")[0];
    // После щелчка на этом элементе сделать видимым остальное содержимое
    addRevealHandler(title, elt);
  }
  function addRevealHandler(title, elt) {
    title.onclick = function() {
      if (elt.className == "reveal") elt.className = "revealed";
      else if (elt.className == "revealed") elt.className = "reveal";
    }
  }
};
&lt;/script>
&lt;/head>
&lt;body>
&lt;div class="reveal">
&lt;h1 class="handle">Щелкните здесь, чтобы увидеть скрытый текст&lt;/h1>
&lt;p>Этот абзац невидим. Он появляется после щелчка на заголовке.&lt;/p>
&lt;/div>
&lt;/body>
&lt;/html></code></pre>

<style>
  /* Стили CSS для этой страницы */
  .reveal * { display: none; } /* Элементы с атрибутом class="reveal" невидимы */
  .reveal *.handle { display: block;} /* Кроме элементов с class="handle" */
</style>

<script>
  // Ничего не делать, пока документ не будет загружен полностью
  window.onload = function() {
    // Отыскать все контейнерные элементы с классом "reveal"
    var elements = document.getElementsByClassName("reveal");
    for(var i = 0; i < elements.length; i++) { // Для каждого такого элемента...
      var elt = elements[i];
      // Отыскать элементы с классом "handle" в контейнере
      var title = elt.getElementsByClassName("handle")[0];
      // После щелчка на этом элементе сделать видимым остальное содержимое
      addRevealHandler(title, elt);
    }
    function addRevealHandler(title, elt) {
      title.onclick = function() {
        if (elt.className == "reveal") elt.className = "revealed";
        else if (elt.className == "revealed") elt.className = "reveal";
      }
    }
  };
</script>

<div class="reveal">
  <button class="handle">Щелкните здесь, чтобы увидеть скрытый текст</button>
  <p>Этот абзац невидим. Он появляется после щелчка на заголовке. </p>
</div>



<h2>Обработчики событий</h2>
<p><b>Обработчик событий</b> – это функция JavaScript, которая регистрируется в броузере и вызывается броузером, когда возникает событие определенного типа. Таким событием может быть щелчок мышью или нажатие клавиши (или какое-то движение двумя пальцами на экране смартфона). Обработчик события может также вызываться броузером по окончании загрузки документа, при изменении размеров окна броузера или при вводе данных в элемент HTML-формы.</p>
<pre><code class="language-javascript">// Выводит сообщение в специальной области для отладочных сообщений внутри документа.
// Если документ не содержит такой области, она создается.
function debug(msg) {
 // Отыскать область для отладочных сообщений в документе, поиск по HTML-атрибуту id
 var log = document.getElementById("debuglog");
 // Если элемент с атрибутом id="debuglog" отсутствует, создать его.
 if (!log) {
 log = document.createElement("div"); // Создать элемент &lt;div>
 log.id = "debuglog"; // Установить атрибут id
 log.innerHTML = "&lt;h1>Debug Log&lt;/h1>"; // Начальное содержимое
 document.body.appendChild(log); // Добавить в конец документа
 }
 // Теперь обернуть сообщение в теги &lt;pre> и добавить в элемент log
 var pre = document.createElement("pre"); // Создать тег &lt;pre>
 var text = document.createTextNode(msg); // Обернуть msg в текстовый узел
 pre.appendChild(text); // Добавить текст в тег &lt;pre>
 log.appendChild(pre); // Добавить &lt;pre> в элемент log
}
</code></pre>

<pre><code class="language-javascript">function hide(e, reflow) { // Скрывает элемент e, изменяя его стиль
 if (reflow) { // Если 2-й аргумент true,
 e.style.display = "none" // скрыть элемент и использовать
 } // занимаемое им место
 else { // Иначе
 e.style.visibility = "hidden"; // сделать e невидимым, но оставить
 } // занимаемое им место пустым
}
function highlight(e) { // Выделяет e, устанавливая класс CSS
 // Просто добавляет или переопределяет HTML-атрибут class.
 // Предполагается, что таблица стилей CSS уже содержит определение класса "hilite"
 if (!e.className) e.className = "hilite";
 else e.className += " hilite";
}
</code></pre>

<p>Простейший способ объявления обработчиков событий заключается в использовании HTML-атрибутов, имена которых начинаются с приставки «on». Обработчик «onclick» особенно удобен при создании простых тестовых программ. Предположим, что вы сохранили функции debug() и hide(), представленные выше, в файлах с именами debug.js и hide.js. В этом случае можно было бы написать простой тестовый HTML-файл, использующий элементы &lt;button> с атрибутами onclick, определяющими обработчики событий:</p>
<pre><code>&lt;button onclick="hide(this,true); debug('hide button 1');">Hide1&lt;/button>
&lt;button onclick="hide(this); debug('hide button 2');">Hide2&lt;/button>
</code></pre>
<script src="debuglog.js"></script>
<script src="hide.js"></script>
Hello
<button onclick="hide(this,true); debug('hide button 1');">Hide1</button>
<button onclick="hide(this); debug('hide button 2');">Hide2</button>
World

<h2>Калькулятор платежей по ссуде</h2>
<p>В следующем примере используются следующие приемы JS:</p>
<ul>
  <li>Поиск элементов в документе</li>
  <li>Получение ввода пользователя с помощью элементов форм.</li>
  <li>Изменение содержимого элементов документа</li>
  <li>Сохранение данных в броузере.</li>
  <li>Управление HTTP-запросами.</li>
  <li>Создание графики с помощью элемента &lt;canvas>.</li>
</ul>
<style> /* Таблица стилей CSS: определяет внешний вид вывода программы */
.output { font-weight: bold; } /* Жирный шрифт для вычисленных значений */
#payment { text-decoration: underline; } /* Для элементов с id="payment" */
#graph { border: solid black 1px; } /* Простая рамка для диаграммы */
.calculator th, td { vertical-align: top; } /* Выравнивание в ячейках таблицы */
</style>
<!--
 Это HTML-таблица с элементами <input>, позволяющими вводить данные, и с элементами <span>, в которых отображаются результаты вычислений. Эти элементы имеют идентификаторы,
 такие как "interest" и "years". Данные идентификаторы используются в JavaScript-коде, который следует за определением таблицы. Обратите внимание, что для некоторых элементов ввода определены обработчики событий "onchange" и "onclick". В них заданы строки JavaScript-кода, выполняемого при вводе данных или щелчке на кнопке.
-->
<table class="calculator">
  <tr><th>Enter Loan Data:</th>
    <td></td>
    <th>Loan Balance, Cumulative Equity, and Interest Payments</th></tr>
  <tr><td>Amount of the loan ($):</td>
    <td><input id="amount" onchange="calculate();"></td>
    <td rowspan=8>
      <canvas id="graph" width="400" height="250"></canvas></td></tr>
  <tr><td>Annual interest (%):</td>
    <td><input id="apr" onchange="calculate();"></td></tr>
  <tr><td>Repayment period (years):</td>
    <td><input id="years" onchange="calculate();"></td>
  <tr><td>Zipcode (to find lenders):</td>
    <td><input id="zipcode" onchange="calculate();"></td>
  <tr><th>Approximate Payments:</th>
    <td><button onclick="calculate();">Calculate</button></td></tr>
  <tr><td>Monthly payment:</td>
    <td>$<span class="output" id="payment"></span></td></tr>
  <tr><td>Total payment:</td>
    <td>$<span class="output" id="total"></span></td></tr>
  <tr><td>Total interest:</td>
    <td>$<span class="output" id="totalinterest"></span></td></tr>
  <tr><th>Sponsors:</th><td colspan=2>
    Apply for your loan with one of these fine lenders:
    <div id="lenders"></div></td></tr>
</table>
<script src="loan_calculator.js"></script>

<p>Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.</p>
<pre><code class="language-javascript"></code></pre>// заменим цвет фона на красный,
document.body.style.background = "red";
// а через секунду вернём как было
setTimeout(() => document.body.style.background = "", 1000);<pre><code class="language-javascript"></code></pre>
<p>  Спецификация DOM описывает структуру документа и предоставляет объекты для манипуляций со страницей. Существуют и другие, отличные от браузеров, инструменты, использующие DOM. Например, серверные скрипты, которые загружают и обрабатывают HTML-страницы, также могут использовать DOM. При этом они могут поддерживать спецификацию не полностью.</p>
<p>Правила стилей CSS структурированы иначе чем HTML. Для них есть отдельная спецификация CSSOM, которая объясняет, как стили должны представляться в виде объектов, как их читать и писать. CSSOM используется вместе с DOM при изменении стилей документа. В реальности CSSOM требуется редко, обычно правила CSS статичны. Мы редко добавляем/удаляем стили из JavaScript, но и это возможно.</p>
<p>Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.</p>
<ol>
    <li>Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).</li>
    <li>Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.</li>
</ol>
<pre><code class="language-javascript">alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}</code></pre>
<h2>Браузерные события</h2>
<p> Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).</p>
<p>Вот список самых часто используемых DOM-событий:</p>
<p><b>События мыши</b>:</p>
<ul>
    <li><span class="code">click </span>– происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).</li>
    <script>
        var click_counter= document.getElementById("#click-counter")

    </script>
    <button onclick=""><span id="click-counter"></span></button>
    <li><span class="code">contextmenu</span> – происходит, когда кликнули на элемент правой кнопкой мыши.</li>
    <li><span class="code">mousedown</span> / <span class="code">mouseup</span> – когда нажали / отжали кнопку мыши на элементе.</li>
    <li><span class="code">mousemove</span> – при движении мыши.</li>
</ul>
<p>События на элементах управления:</p>
<ul>
    <li>submit – пользователь отправил форму &lt;form>.</li>
    <li>focus – пользователь фокусируется на элементе, например нажимает на &lt;&lt;&lt;input>.</li>
</ul>
<p>Клавиатурные события:</p>
<ul>
    <li>keydown и keyup – когда пользователь нажимает / отпускает клавишу..</li>
</ul>
<p>События документа:</p>
<ul>
    <li>DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.</li>
</ul>
<p>CSS events:</p>
<ul>
    <li>transitionend – когда CSS-анимация завершена.</li>
</ul>

<h3>Обработчики событий</h3>
<p>Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on&lt;событие>.</p>
<p>Например, чтобы назначить обработчик события click на элементе input, можно использовать атрибут onclick, вот так:</p>
<pre><code class="language-html">&lt;input value="Нажми меня" onclick="alert('Клик!')" type="button"></code></pre>
<p>При клике мышкой на кнопке выполнится код, указанный в атрибуте onclick. Обратите внимание, для содержимого атрибута onclick используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так: onclick="alert("Click!")", код не будет работать.</p>
<p>    Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.</p>
<p>Следующий пример по клику запускает функцию countRabbits():</p>
<pre><code class="language-javascript">&lt;script>
  function countRabbits() {
      for(let i=1; i&lt;=3; i++) {
          alert("Кролик номер " + i);
      }
  }
&lt;/script>

&lt;input type="button" onclick="countRabbits()" value="Считать кроликов!"></code></pre>
<p>   Можно назначать обработчик, используя свойство DOM-элемента on&lt;событие>. К примеру, elem.onclick:</p>
<pre><code class="language-javascript">&lt;input id="elem" type="button" value="Нажми меня!">
&lt;script>
  elem.onclick = function() {
      alert('Спасибо');
  };
&lt;/script></code></pre>
<p>Использование свойства DOM-объекта. Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство. Этот способ, по сути, аналогичен предыдущему. Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.</p>


<pre><code class="language-javascript"></code></pre>
<pre><code class="language-javascript"></code></pre>
<pre><code class="language-javascript"></code></pre>

</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js">

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
<script src="../scripts/body_scripts.js"></script>
</html>