
<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
  <title>Глава 3. JavaScript в веб-браузере</title>

</head>
<body>

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<div id="header"></div>
<h1>Глава 3. JavaScript в веб-браузере</h1>
<h2>Клиентский JS</h2>


<p>Объект window - это окно веб-браузер. Он определяет свойства, например, location, которые ссылаются на объект Location, определяющий URL текущего окна, и позволяет сценарию загружать в окно содержимое других адресов </p>
<pre><code class="language-javascript">// Установить значение свойства для переход на новую веб-страницу
window.location = "http://www.oreilly.com/";</code></pre>
<p>На <a href="#js_access">рис. ниже</a> показано, что доступно JS в браузерном окуржении.</p>
<p>    Как мы видим, имеется корневой объект window, который выступает в 2 ролях:</p>
<ol>
    <li>Во-первых, это глобальный объект для JavaScript-кода.</li>
    <li>Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.</li>
</ol>
<img id="js_access" src="images/js_acces.png">
<p>Также объект Window определяет методы, такие как alert()? который отображает диалог с сообщением, и setTimeout(), которые регистрирует функцию для вызова через указанный промежуток времени.</p>
<pre><code class="language-javascript">// ждать 2 секунды и вывести диалог с приветствием
setTimeout(function() { alert("Привет, Мир!"); }, 2000);</code></pre>
<p>Объект Window глобальный, т.е. он находится на вершине областей видимости и его свойства и методы - глобальные переменные и функции. </p>
<p>Важным свойством объекта Window является свойство document, которое ссылается на объект Document, которые представляет содержимое объекта, отображаемого в окне. Его методом является, например, getElementById(), которые возвращает единственный элемент документа (пару открывающихся и закрывающихся тегов) по его id и все, что содержится между ними</p>
<pre><code class="language-javascript">// Отыскать элемент с атрибутом id="timestamp"
var timestamp = document.getElementById("timestamp");</code></pre>
<p>Здесь возвращается объект Element, который также имеет ряж важный свойств и методов, позволяющих скрипту извлекать содержимое элемента и устанавливать значение его атрибутов. </p>
<pre><code class="language-javascript">// Если элемент пуст, вставить в него текущую дату и время
if (timestamp.firstChild == null)
 timestamp.appendChild(document.createTextNode(new Date().toString()));</code></pre>
<p>Каждый объект Element имеет свойства style и classNamr, позволяющие определять стили CSS или изменять имена классов CSS, применяемых к элементу. Это позволяет изменять визуальное представление элемента документа:</p>
<pre><code class="language-javascript">// Явно изменить представление элемента заголовка
timestamp.style.backgroundColor = "yellow";
// Или просто изменить класс и позволить определять особенности
// визуального представления с помощью каскадных таблиц стилей:
timestamp.className = "highlight";</code></pre>
<p>Другим важным множеством свойств объектов Window, Document и Element являются свойства, ссылающиеся на обработчики событий. Они позволяют сценариям определять функции, которые должны вызываться асинхронно при возникновении определенных событий. Обработчики событий позволяют программам на языке JavaScript изменять поведение окон, документов и элементов, составляющих документы. Свойства, ссылающиеся на обработчики событий, имеют имена, начинающиеся с «on», и могут использоваться, как показано ниже:</p>
<pre><code class="language-javascript">// Обновить содержимое элемента timestamp, когда пользователь щелкнет на нем
timestamp.onclick = function() { this.innerHTML = new Date().toString(); }</code></pre>
<p>Одним из наиболее важных обработчиков событий является обработчик onload объекта Window. Это событие возникает, когда содержимое документа, отображаемое в окне, будет загружено полностью и станет доступно для выполнения манипуляций. Программный код на языке JavaScript обычно заключается в обработчик события onload. Пример 13.1 использует обработчик onload и демонстрирует дополнительные приемы получения ссылок на элементы документа, изменения классов CSS и определения обработчиков других событий в клиентском JavaScript. В этом примере программный код на языке JavaScript заключен в HTML-тег script. Подробнее этот тег описывается в разделе 13.2. Обратите внимание, что в этом примере имеется определение функции, заключенное в определение другой функции. Вложенные функции часто используются в клиентских сценариях на языке JavaScript, особенно в виде обработчиков событий.</p>
<pre><code class="language-html">//открывающийся элемент
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
&lt;style>
/* Стили CSS для этой страницы */
.reveal * { display: none; } /* Элементы с атрибутом class="reveal" невидимы */
.reveal *.handle { display: block;} /* Кроме элементов с class="handle" */
&lt;/style>
&lt;script>
// Ничего не делать, пока документ не будет загружен полностью
window.onload = function() {
  // Отыскать все контейнерные элементы с классом "reveal"
  var elements = document.getElementsByClassName("reveal");
  for(var i = 0; i &lt; elements.length; i++) { // Для каждого такого элемента...
    var elt = elements[i];
    // Отыскать элементы с классом "handle" в контейнере
    var title = elt.getElementsByClassName("handle")[0];
    // После щелчка на этом элементе сделать видимым остальное содержимое
    addRevealHandler(title, elt);
  }
  function addRevealHandler(title, elt) {
    title.onclick = function() {
      if (elt.className == "reveal") elt.className = "revealed";
      else if (elt.className == "revealed") elt.className = "reveal";
    }
  }
};
&lt;/script>
&lt;/head>
&lt;body>
&lt;div class="reveal">
&lt;h1 class="handle">Щелкните здесь, чтобы увидеть скрытый текст&lt;/h1>
&lt;p>Этот абзац невидим. Он появляется после щелчка на заголовке.&lt;/p>
&lt;/div>
&lt;/body>
&lt;/html></code></pre>

<style>
  /* Стили CSS для этой страницы */
  .reveal * { display: none; } /* Элементы с атрибутом class="reveal" невидимы */
  .reveal *.handle { display: block;} /* Кроме элементов с class="handle" */
</style>

<script>
  // Ничего не делать, пока документ не будет загружен полностью
  window.onload = function() {
    // Отыскать все контейнерные элементы с классом "reveal"
    var elements = document.getElementsByClassName("reveal");
    for(var i = 0; i < elements.length; i++) { // Для каждого такого элемента...
      var elt = elements[i];
      // Отыскать элементы с классом "handle" в контейнере
      var title = elt.getElementsByClassName("handle")[0];
      // После щелчка на этом элементе сделать видимым остальное содержимое
      addRevealHandler(title, elt);
    }
    function addRevealHandler(title, elt) {
      title.onclick = function() {
        if (elt.className == "reveal") elt.className = "revealed";
        else if (elt.className == "revealed") elt.className = "reveal";
      }
    }
  };
</script>

<div class="reveal">
  <button class="handle">Щелкните здесь, чтобы увидеть скрытый текст</button>
  <p>Этот абзац невидим. Он появляется после щелчка на заголовке. </p>
</div>

<h2>Скрипты JS в веб-документах</h2>
<p>Клиентский JS-код может встраиваться в HTML-документы 4 способами:</p>
<ol>
  <li>встроенные сценарии между парой тегов script;</li>
  <li>из внешнего файла, заданного атрибутом src тега script;</li>
  <li>в обработчик события, заданный в качестве значения HTML-атрибута, такого как onclick или onmouseover</li>
  <li>как тело URL-адреса, использующего специальный спецификатор псевдопротокола JavaScript (<i>сейчас редко используется</i>)</li>
</ol>
<p>Сейчас на уровне этикета <i>Ненавязчивого JS</i> (unobtrusive JS) принято разделять содержимое (разметка HTML) и поведение (код на JS). И потому при прочих равных предпочтительнее второй вариант (встраивание скрипта из внешнего файла с помощью атрибута src тега script).</p>
<h3>Элемент &lt;script></h3>
<p>Начнем с примера простого встраиваемого в HTML-документ кода - часов.</p>
<pre><code class="language-javascript">&lt;script> // Определение функции для отображения текущего времени
function displayTime() {
 var elt = document.getElementById("clock"); // Найти элемент с id="clock"
 var now = new Date(); // Получить текущее время
 elt.innerHTML = now.toLocaleTimeString(); // Отобразить его
 setTimeout(displayTime, 1000); // Вызвать снова через 1 сек.
}
window.onload = displayTime; // Начать отображение времени после загрузки документа.
&lt;/script>
&lt;/head>
&lt;body> &lt;!-- Тело - отображаемая часть документа -->
&lt;h1>Цифровые часы&lt;/h1> &lt;!-- Вывести заголовок -->
  &lt;span id="clock" style="
    font: bold 24pt sans;
    background: #ddf;
    padding: 10px;
    border: solid black 2px;
    border-radius: 10px;">
  &lt;/span>
&lt;/body>
</code></pre>
<script>
  // Определение функции для отображения текущего времени
  function displayTime() {
    var elt = document.getElementById("clock"); // Найти элемент с id="clock"
    var now = new Date(); // Получить текущее время
    elt.innerHTML = now.toLocaleTimeString(); // Отобразить его
    setTimeout(displayTime, 1000); // Вызвать снова через 1 сек.
  }
  window.addEventListener("load",displayTime, false); // Начать отображение времени после загрузки документа.
</script>
<span id="clock" style="font: bold 24pt sans;background: #ddf; padding: 10px;border: solid black 2px;border-radius: 10px;"></span> <!-- Время выводится здесь -->
<h3>Сценарии во внешних файлах</h3>
<p>Программы на языке JavaScript могут манипулировать содержимым документа
  через объект Document и содержащиеся в нем объекты Element. Они могут изменять визуальное представление содержимого, управляя стилями и классами CSS, и определять поведение элементов документа, регистрируя соответствующие обработчики событий. Комбинация управляемого содержимого, представления и поведения называется динамическим HTML (Dynamic HTML, или DHTML).</p>
<p>Сценарии на JavaScript можно отнести к подручным средствам, которые:</p>
<ul>
  <li>Создают анимационные и другие визуальные эффекты, ненавязчиво руководя действиями пользователя и помогая ему передвигаться по странице.</li>
  <li>Сортируют столбцы таблиц, упрощая пользователю поиск требуемой информации.</li>
  <li>Скрывают определенное содержимое и отображают детали по мере «погружения» пользователя в содержимое.</li>
</ul>

<h2>Обработчики событий</h2>
<p><b>Обработчик событий</b> – это функция JavaScript, которая регистрируется в броузере и вызывается броузером, когда возникает событие определенного типа. Таким событием может быть щелчок мышью или нажатие клавиши (или какое-то движение двумя пальцами на экране смартфона). Обработчик события может также вызываться броузером по окончании загрузки документа, при изменении размеров окна броузера или при вводе данных в элемент HTML-формы.</p>
<pre><code class="language-javascript">// Выводит сообщение в специальной области для отладочных сообщений внутри документа.
// Если документ не содержит такой области, она создается.
function debug(msg) {
 // Отыскать область для отладочных сообщений в документе, поиск по HTML-атрибуту id
 var log = document.getElementById("debuglog");
 // Если элемент с атрибутом id="debuglog" отсутствует, создать его.
 if (!log) {
 log = document.createElement("div"); // Создать элемент &lt;div>
 log.id = "debuglog"; // Установить атрибут id
 log.innerHTML = "&lt;h1>Debug Log&lt;/h1>"; // Начальное содержимое
 document.body.appendChild(log); // Добавить в конец документа
 }
 // Теперь обернуть сообщение в теги &lt;pre> и добавить в элемент log
 var pre = document.createElement("pre"); // Создать тег &lt;pre>
 var text = document.createTextNode(msg); // Обернуть msg в текстовый узел
 pre.appendChild(text); // Добавить текст в тег &lt;pre>
 log.appendChild(pre); // Добавить &lt;pre> в элемент log
}
</code></pre>

<pre><code class="language-javascript">function hide(e, reflow) { // Скрывает элемент e, изменяя его стиль
 if (reflow) { // Если 2-й аргумент true,
 e.style.display = "none" // скрыть элемент и использовать
 } // занимаемое им место
 else { // Иначе
 e.style.visibility = "hidden"; // сделать e невидимым, но оставить
 } // занимаемое им место пустым
}
function highlight(e) { // Выделяет e, устанавливая класс CSS
 // Просто добавляет или переопределяет HTML-атрибут class.
 // Предполагается, что таблица стилей CSS уже содержит определение класса "hilite"
 if (!e.className) e.className = "hilite";
 else e.className += " hilite";
}
</code></pre>

<p>Простейший способ объявления обработчиков событий заключается в использовании HTML-атрибутов, имена которых начинаются с приставки «on». Обработчик «onclick» особенно удобен при создании простых тестовых программ. Предположим, что вы сохранили функции debug() и hide(), представленные выше, в файлах с именами debug.js и hide.js. В этом случае можно было бы написать простой тестовый HTML-файл, использующий элементы &lt;button> с атрибутами onclick, определяющими обработчики событий:</p>
<pre><code>&lt;button onclick="hide(this,true); debug('hide button 1');">Hide1&lt;/button>
&lt;button onclick="hide(this); debug('hide button 2');">Hide2&lt;/button>
</code></pre>
<script src="debuglog.js"></script>
<script src="hide.js"></script>
Hello
<button onclick="hide(this,true); debug('hide button 1');">Hide1</button>
<button onclick="hide(this); debug('hide button 2');">Hide2</button>
World

<h2>Калькулятор платежей по ссуде</h2>
<p>В следующем примере используются следующие приемы JS:</p>
<ul>
  <li>Поиск элементов в документе</li>
  <li>Получение ввода пользователя с помощью элементов форм.</li>
  <li>Изменение содержимого элементов документа</li>
  <li>Сохранение данных в броузере.</li>
  <li>Управление HTTP-запросами.</li>
  <li>Создание графики с помощью элемента &lt;canvas>.</li>
</ul>
<style> /* Таблица стилей CSS: определяет внешний вид вывода программы */
.output { font-weight: bold; } /* Жирный шрифт для вычисленных значений */
#payment { text-decoration: underline; } /* Для элементов с id="payment" */
#graph { border: solid black 1px; } /* Простая рамка для диаграммы */
.calculator th, td { vertical-align: top; } /* Выравнивание в ячейках таблицы */
</style>
<!--
 Это HTML-таблица с элементами <input>, позволяющими вводить данные, и с элементами <span>, в которых отображаются результаты вычислений. Эти элементы имеют идентификаторы,
 такие как "interest" и "years". Данные идентификаторы используются в JavaScript-коде, который следует за определением таблицы. Обратите внимание, что для некоторых элементов ввода определены обработчики событий "onchange" и "onclick". В них заданы строки JavaScript-кода, выполняемого при вводе данных или щелчке на кнопке.
-->
<table class="calculator">
  <tr><th>Enter Loan Data:</th>
    <td></td>
    <th>Loan Balance, Cumulative Equity, and Interest Payments</th></tr>
  <tr><td>Amount of the loan ($):</td>
    <td><input id="amount" onchange="calculate();"></td>
    <td rowspan=8>
      <canvas id="graph" width="400" height="250"></canvas></td></tr>
  <tr><td>Annual interest (%):</td>
    <td><input id="apr" onchange="calculate();"></td></tr>
  <tr><td>Repayment period (years):</td>
    <td><input id="years" onchange="calculate();"></td>
  <tr><td>Zipcode (to find lenders):</td>
    <td><input id="zipcode" onchange="calculate();"></td>
  <tr><th>Approximate Payments:</th>
    <td><button onclick="calculate();">Calculate</button></td></tr>
  <tr><td>Monthly payment:</td>
    <td>$<span class="output" id="payment"></span></td></tr>
  <tr><td>Total payment:</td>
    <td>$<span class="output" id="total"></span></td></tr>
  <tr><td>Total interest:</td>
    <td>$<span class="output" id="totalinterest"></span></td></tr>
  <tr><th>Sponsors:</th><td colspan=2>
    Apply for your loan with one of these fine lenders:
    <div id="lenders"></div></td></tr>
</table>
<script src="loan_calculator.js"></script>

<p>Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.</p>
<pre><code class="language-javascript"></code></pre>// заменим цвет фона на красный,
document.body.style.background = "red";
// а через секунду вернём как было
setTimeout(() => document.body.style.background = "", 1000);<pre><code class="language-javascript"></code></pre>
<p>  Спецификация DOM описывает структуру документа и предоставляет объекты для манипуляций со страницей. Существуют и другие, отличные от браузеров, инструменты, использующие DOM. Например, серверные скрипты, которые загружают и обрабатывают HTML-страницы, также могут использовать DOM. При этом они могут поддерживать спецификацию не полностью.</p>
<p>Правила стилей CSS структурированы иначе чем HTML. Для них есть отдельная спецификация CSSOM, которая объясняет, как стили должны представляться в виде объектов, как их читать и писать. CSSOM используется вместе с DOM при изменении стилей документа. В реальности CSSOM требуется редко, обычно правила CSS статичны. Мы редко добавляем/удаляем стили из JavaScript, но и это возможно.</p>
<p>Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.</p>
<ol>
    <li>Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).</li>
    <li>Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.</li>
</ol>
<pre><code class="language-javascript">alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}</code></pre>
<h2>Браузерные события</h2>
<p> Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).</p>
<p>Вот список самых часто используемых DOM-событий:</p>
<p>События мыши:</p>
<ul>
    <li>click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).</li>
    <li>contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.</li>
    <li>contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.</li>
    <li>mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.</li>
    <li>mousemove – при движении мыши.</li>
</ul>
<p>События на элементах управления:</p>
<ul>
    <li>submit – пользователь отправил форму &lt;form>.</li>
    <li>focus – пользователь фокусируется на элементе, например нажимает на &lt;&lt;&lt;input>.</li>
</ul>
<p>Клавиатурные события:</p>
<ul>
    <li>keydown и keyup – когда пользователь нажимает / отпускает клавишу..</li>
</ul>
<p>События документа:</p>
<ul>
    <li>DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.</li>
</ul>
<p>CSS events:</p>
<ul>
    <li>transitionend – когда CSS-анимация завершена.</li>
</ul>

<h3>Обработчики событий</h3>
<p>Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on&lt;событие>.</p>
<p>Например, чтобы назначить обработчик события click на элементе input, можно использовать атрибут onclick, вот так:</p>
<pre><code class="language-html">&lt;input value="Нажми меня" onclick="alert('Клик!')" type="button"></code></pre>
<p>При клике мышкой на кнопке выполнится код, указанный в атрибуте onclick. Обратите внимание, для содержимого атрибута onclick используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так: onclick="alert("Click!")", код не будет работать.</p>
<p>    Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.</p>
<p>Следующий пример по клику запускает функцию countRabbits():</p>
<pre><code class="language-javascript">&lt;script>
  function countRabbits() {
      for(let i=1; i&lt;=3; i++) {
          alert("Кролик номер " + i);
      }
  }
&lt;/script>

&lt;input type="button" onclick="countRabbits()" value="Считать кроликов!"></code></pre>
<p>   Можно назначать обработчик, используя свойство DOM-элемента on&lt;событие>. К примеру, elem.onclick:</p>
<pre><code class="language-javascript">&lt;input id="elem" type="button" value="Нажми меня!">
&lt;script>
  elem.onclick = function() {
      alert('Спасибо');
  };
&lt;/script></code></pre>
<p>Использование свойства DOM-объекта. Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство. Этот способ, по сути, аналогичен предыдущему. Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.</p>

<pre><code class="language-javascript"></code></pre>
<pre><code class="language-javascript"></code></pre>
<pre><code class="language-javascript"></code></pre>

</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js">

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
</html>