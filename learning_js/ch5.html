<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
    <title>Глава . Выражения и операторы</title>

</head>


<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="header"></div>

<h1>Глава . Выражения и операторы</h1>
<h2>Выражения</h2>
<p><b>Выражение</b> – это фраза языка JavaScript, которая может быть вычислена интерпретатором для получения значения.</p>
<p>Примеры:</p>
<ul>
    <li>Константа - простейшая разновидность выражения;</li>
    <li>Имя переменной - получение значения присвоенного переменной;</li>
    <li>Обращение к элементу объекта - например, <span class="code">arr[10]</span>.</li>
    <li>Вызов функции</li>
</ul>
<p>Типичный способ конструирования сложных выражений из более простых - использование операторов.</p>
<h3>Первичные выражения</h3>
<p><b>Первичные выражения</b> - самостоятельные выражения, не включающие другие выражений.</p>
<ol>
    <li><b>Литералы</b></li>
    <li><span class="code">this</span> - выражение, которое используется в ООП. Внутри метода <span class="code">this</span> возвращает объект, относительно которого был вызван метод.</li>
    <li>Ссылки на переменные</li>
</ol>
<h3>Инициализаторы объектов и массивов</h3>
<p><b>Инициализаторы объектов и массивов</b> – это выражения, значениями которых являются вновь созданные объекты и массивы. Эти выражения-инициализаторы иногда называют «литералами объектов» и «литералами массивов». Однако, в отличие от истинных литералов, они не являются первичными выражениями, потому что включают множество подвыражений, определяющих значения свойств и элементов. Инициализаторы массивов имеют более простой синтаксис, поэтому мы рассмотрим их в первую очередь. </p>
<p><b>Инициализатор массива</b> – это список выражений, разделенных запятыми, заключенный в квадратные скобки. Значением инициализатора массива является вновь созданный массив. Элементы этого нового массива инициализируются значениями выражений из списка:</p>
<pre><code class="language-javascript">[] // Пус­той мас­сив: от­сут­ст­вие вы­ра­же­ний в квад­рат­ных скоб­ках оз­на­ча­ет от­сут­ст­вие эле­мен­тов
[1+2,3+4] // Мас­сив из 2 эле­мен­тов. Пер­вый эле­мент – 3, вто­рой – 7
var matrix = [[1,2,3], [4,5,6], [7,8,9]]; //выражение в инициализатор массива само может быть инициализатором массива
var sparseArray = [1,,,,5]; // В ИМ допустимо включать неопределенные элементы</code></pre>
<p>Выражения в инициализаторе массива, определяющие значения его элементов, вычисляются всякий раз, когда вычисляется значение инициализатора. Это означает, что значение выражения инициализатора массива может отличаться при каждом последующем его вычислении.</p>
<p><b>Инициализаторы объектов</b> похожи на выражения-инициализаторы массивов, но вместо квадратных скобок в них используются фигурные скобки, а каждое подвыражение предваряется именем свойства и двоеточием:</p>
<pre><code class="language-javascript">var p = { x:2.3, y:-1.2 }; // Объ­ект с 2 свой­ст­ва­ми
var q = {}; // Пус­той объ­ект без свойств
q.x = 2.3; q.y = -1.2; // Те­перь q име­ет те же свой­ст­ва, что и p
var rectangle = { upperLeft: { x: 2, y: 2 },
 lowerRight: { x: 4, y: 5 } }; // Литералы объектов могут быть вложенными</code></pre>
<h3>Выражения определения функций</h3>
 <p>Выражение определения функции определяет функцию, а значением такого выражения является вновь созданная функция. В некотором смысле выражение определения функции является «литералом функции» подобно тому, как инициализаторы объектов являются «литералами объектов». Выражение определения функции обычно состоит из ключевого слова <span class="code">function</span>, за которым следует список из нуля или более идентификаторов (имен параметров), разделенных запятыми, в круглых скобках и блок программного кода на языке JavaScript (тело функции) в фигурных скобках.</p>
 <pre><code class="language-javascript">// Эта функ­ция воз­вра­ща­ет квад­рат пе­ре­дан­но­го ей зна­че­ния
var square = function(x) { return x * x; }</code></pre>
<h3>Выражения обращения к свойствам</h3>
<p>Выражение обращения к свойству вычисляет значение свойства объекта или элемента массива. В языке JavaScript имеется два способа обращения к свойствам:</p>
<ul>
    <li><span class="code">вы­ра­же­ние.иден­ти­фи­ка­тор</span></li>
    <li><span class="code">вы­ра­же­ние [вы­ра­же­ние]</span></li>
</ul>
<pre><code class="language-javascript">var o = {x:1,y:{z:3}}; // При­мер объ­ек­та
var a = [o,4,[5,6]]; // При­мер мас­си­ва, со­дер­жа­ще­го объ­ект
o.x // => 1: свой­ст­во x вы­ра­же­ния o
o.y.z // => 3: свой­ст­во z вы­ра­же­ния o.y
o["x"] // => 1: свой­ст­во x объ­ек­та o
a[1] // => 4: эле­мент с ин­дек­сом 1 вы­ра­же­ния a
a[2]["1"] // => 6: эле­мент с ин­дек­сом 1 вы­ра­же­ния a[2]
a[0].x // => 1: свой­ст­во x вы­ра­же­ния a[0]</code></pre>
<p>Обращение к <span class="code">undefined</span> или <span class="code">null</span> вызывает <span class="code">TypeError</span>.</p>
<p>Заметим также, что первый способ обращения (через точку) ограничен в своем применении, так имя идентификатора не должно включать пробелы, быть зарезервированным свойством или именем определенной в области видимости переменной. </p>
<h3>Выражения вызова</h3>
<p>Выражение вызова в языке JavaScript служит для вызова (или выполнения) функции или метода. Оно начинается с выражения, возвращающего функцию, идентифицирующего вызываемую функцию. Вслед за выражением получения функции следуют открывающая круглая скобка, список из нуля или более выражений аргументов, разделенных запятыми, и закрывающая круглая скобка. Например: </p>
<pre><code class="language-javascript">f(0) // f - вы­ра­же­ние функ­ции; 0 - вы­ра­же­ние ар­гу­мен­та.
Math.max(x,y,z) // Math.max - функ­ция; x, y и z - ар­гу­мен­ты.
a.sort() // a.sort - функ­ция; здесь нет ар­гу­мен­тов.</code></pre>
<p>При вычислении выражения вызова первым вычисляется выражение, возвращающее функцию, а затем вычисляются выражения аргументов и создается список значений аргументов.</p>
<p>Далее значения аргументов присваиваются в порядке их следования именам параметров, которые указаны в определении функции, после чего выполняется тело функции. Если внутри функции используется
инструкция <span class="code">return</span>, возвращающая некоторое значение, это значение становится значением выражения вызова. В противном случае выражение вызова возвращает значение <span class="code">undefined</span>. </p>
<p>Все выражения вызова включают пару круглых скобок и выражение перед открывающей круглой скобкой. Если это выражение является выражением обращения к свойству, такой вызов называется <i>вызовом метода</i>. При вызове метода объект или массив, к свойству которого производится обращение, становится значением параметра <span class="code">this</span>, доступного в теле функции во время его выполнения.</p>
<h3>Выражения создания объектов</h3>
<p>Выражение создания объекта создает новый объект и вызывает функцию (называемую конструктором) для инициализации свойств этого объекта. Выражения создания объектов похожи на выражения вызова, за исключением того, что им предшествует ключевое слово <span class="code">new</span>:</p>
<pre><code class="language-javascript">new Object()
new Point(2,3)</code></pre>
<p>Если в выражении создания объекта функции-конструктору не передается ни одного аргумента, пустую пару круглых скобок можно опустить:</p>
<pre><code class="language-javascript">new Object
new Date</code></pre>
<p>При вычислении выражения создания объекта интерпретатор JavaScript сначала создает новый пустой объект, как если бы для создания использовался пустой инициализатор объекта <span class="code">{}</span>, а затем вызывает указанную функцию с указанными аргументами, передавая ей новый объект в качестве значения ключевого слова <span class="code">this</span>. Функция может использовать его для инициализации свойств только что созданного объекта. Функции, которые создаются специально, чтобы играть роль конструктора, не должны возвращать значение, а значением выражения создания объекта становится созданный и инициализированный объект. Если конструктор возвращает какой-либо объект, этот объект становится значением всего выражения создания объекта, а вновь созданный объект уничтожается.</p>
<h2>Операторы</h2>


<p></p>
<p></p>
<p></p>
<p></p>
<p></p>



<pre><code class="language-javascript"></code></pre>
<pre><code class="language-javascript"></code></pre>
&lt;




<span class="code"></span>
<span class="code"></span>
<span class="code"></span>
<span class="code"></span>


</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script>hljs.highlightAll();</script>
</html>
