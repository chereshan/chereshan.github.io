<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
    <title>Глава . Выражения и операторы</title>

</head>


<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="header"></div>

<h1>Глава . Выражения и операторы</h1>
<h2>Выражения</h2>
<p><b>Выражение</b> – это фраза языка JavaScript, которая может быть вычислена интерпретатором для получения значения.</p>
<p>Примеры:</p>
<ul>
    <li>Константа - простейшая разновидность выражения;</li>
    <li>Имя переменной - получение значения присвоенного переменной;</li>
    <li>Обращение к элементу объекта - например, <span class="code">arr[10]</span>.</li>
    <li>Вызов функции</li>
</ul>
<p>Типичный способ конструирования сложных выражений из более простых - использование операторов.</p>
<h3>Первичные выражения</h3>
<p><b>Первичные выражения</b> - самостоятельные выражения, не включающие другие выражений.</p>
<ol>
    <li><b>Литералы</b></li>
    <li><span class="code">this</span> - выражение, которое используется в ООП. Внутри метода <span class="code">this</span> возвращает объект, относительно которого был вызван метод.</li>
    <li>Ссылки на переменные</li>
</ol>
<h3>Инициализаторы объектов и массивов</h3>
<p><b>Инициализаторы объектов и массивов</b> – это выражения, значениями которых являются вновь созданные объекты и массивы. Эти выражения-инициализаторы иногда называют «литералами объектов» и «литералами массивов». Однако, в отличие от истинных литералов, они не являются первичными выражениями, потому что включают множество подвыражений, определяющих значения свойств и элементов. Инициализаторы массивов имеют более простой синтаксис, поэтому мы рассмотрим их в первую очередь. </p>
<p><b>Инициализатор массива</b> – это список выражений, разделенных запятыми, заключенный в квадратные скобки. Значением инициализатора массива является вновь созданный массив. Элементы этого нового массива инициализируются значениями выражений из списка:</p>
<pre><code class="language-javascript">[] // Пус­той мас­сив: от­сут­ст­вие вы­ра­же­ний в квад­рат­ных скоб­ках оз­на­ча­ет от­сут­ст­вие эле­мен­тов
[1+2,3+4] // Мас­сив из 2 эле­мен­тов. Пер­вый эле­мент – 3, вто­рой – 7
var matrix = [[1,2,3], [4,5,6], [7,8,9]]; //выражение в инициализатор массива само может быть инициализатором массива
var sparseArray = [1,,,,5]; // В ИМ допустимо включать неопределенные элементы</code></pre>
<p>Выражения в инициализаторе массива, определяющие значения его элементов, вычисляются всякий раз, когда вычисляется значение инициализатора. Это означает, что значение выражения инициализатора массива может отличаться при каждом последующем его вычислении.</p>
<p><b>Инициализаторы объектов</b> похожи на выражения-инициализаторы массивов, но вместо квадратных скобок в них используются фигурные скобки, а каждое подвыражение предваряется именем свойства и двоеточием:</p>
<pre><code class="language-javascript">var p = { x:2.3, y:-1.2 }; // Объ­ект с 2 свой­ст­ва­ми
var q = {}; // Пус­той объ­ект без свойств
q.x = 2.3; q.y = -1.2; // Те­перь q име­ет те же свой­ст­ва, что и p
var rectangle = { upperLeft: { x: 2, y: 2 },
 lowerRight: { x: 4, y: 5 } }; // Литералы объектов могут быть вложенными</code></pre>
<h3>Выражения определения функций</h3>
 <p>Выражение определения функции определяет функцию, а значением такого выражения является вновь созданная функция. В некотором смысле выражение определения функции является «литералом функции» подобно тому, как инициализаторы объектов являются «литералами объектов». Выражение определения функции обычно состоит из ключевого слова <span class="code">function</span>, за которым следует список из нуля или более идентификаторов (имен параметров), разделенных запятыми, в круглых скобках и блок программного кода на языке JavaScript (тело функции) в фигурных скобках.</p>
 <pre><code class="language-javascript">// Эта функ­ция воз­вра­ща­ет квад­рат пе­ре­дан­но­го ей зна­че­ния
var square = function(x) { return x * x; }</code></pre>
<h3>Выражения обращения к свойствам</h3>
<p>Выражение обращения к свойству вычисляет значение свойства объекта или элемента массива. В языке JavaScript имеется два способа обращения к свойствам:</p>
<ul>
    <li><span class="code">вы­ра­же­ние.иден­ти­фи­ка­тор</span></li>
    <li><span class="code">вы­ра­же­ние [вы­ра­же­ние]</span></li>
</ul>
<pre><code class="language-javascript">var o = {x:1,y:{z:3}}; // При­мер объ­ек­та
var a = [o,4,[5,6]]; // При­мер мас­си­ва, со­дер­жа­ще­го объ­ект
o.x // => 1: свой­ст­во x вы­ра­же­ния o
o.y.z // => 3: свой­ст­во z вы­ра­же­ния o.y
o["x"] // => 1: свой­ст­во x объ­ек­та o
a[1] // => 4: эле­мент с ин­дек­сом 1 вы­ра­же­ния a
a[2]["1"] // => 6: эле­мент с ин­дек­сом 1 вы­ра­же­ния a[2]
a[0].x // => 1: свой­ст­во x вы­ра­же­ния a[0]</code></pre>
<p>Обращение к <span class="code">undefined</span> или <span class="code">null</span> вызывает <span class="code">TypeError</span>.</p>
<p>Заметим также, что первый способ обращения (через точку) ограничен в своем применении, так имя идентификатора не должно включать пробелы, быть зарезервированным свойством или именем определенной в области видимости переменной. </p>
<h3>Выражения вызова</h3>
<p>Выражение вызова в языке JavaScript служит для вызова (или выполнения) функции или метода. Оно начинается с выражения, возвращающего функцию, идентифицирующего вызываемую функцию. Вслед за выражением получения функции следуют открывающая круглая скобка, список из нуля или более выражений аргументов, разделенных запятыми, и закрывающая круглая скобка. Например: </p>
<pre><code class="language-javascript">f(0) // f - вы­ра­же­ние функ­ции; 0 - вы­ра­же­ние ар­гу­мен­та.
Math.max(x,y,z) // Math.max - функ­ция; x, y и z - ар­гу­мен­ты.
a.sort() // a.sort - функ­ция; здесь нет ар­гу­мен­тов.</code></pre>
<p>При вычислении выражения вызова первым вычисляется выражение, возвращающее функцию, а затем вычисляются выражения аргументов и создается список значений аргументов.</p>
<p>Далее значения аргументов присваиваются в порядке их следования именам параметров, которые указаны в определении функции, после чего выполняется тело функции. Если внутри функции используется
инструкция <span class="code">return</span>, возвращающая некоторое значение, это значение становится значением выражения вызова. В противном случае выражение вызова возвращает значение <span class="code">undefined</span>. </p>
<p>Все выражения вызова включают пару круглых скобок и выражение перед открывающей круглой скобкой. Если это выражение является выражением обращения к свойству, такой вызов называется <i>вызовом метода</i>. При вызове метода объект или массив, к свойству которого производится обращение, становится значением параметра <span class="code">this</span>, доступного в теле функции во время его выполнения.</p>
<h3>Выражения создания объектов</h3>
<p>Выражение создания объекта создает новый объект и вызывает функцию (называемую конструктором) для инициализации свойств этого объекта. Выражения создания объектов похожи на выражения вызова, за исключением того, что им предшествует ключевое слово <span class="code">new</span>:</p>
<pre><code class="language-javascript">new Object()
new Point(2,3)</code></pre>
<p>Если в выражении создания объекта функции-конструктору не передается ни одного аргумента, пустую пару круглых скобок можно опустить:</p>
<pre><code class="language-javascript">new Object
new Date</code></pre>
<p>При вычислении выражения создания объекта интерпретатор JavaScript сначала создает новый пустой объект, как если бы для создания использовался пустой инициализатор объекта <span class="code">{}</span>, а затем вызывает указанную функцию с указанными аргументами, передавая ей новый объект в качестве значения ключевого слова <span class="code">this</span>. Функция может использовать его для инициализации свойств только что созданного объекта. Функции, которые создаются специально, чтобы играть роль конструктора, не должны возвращать значение, а значением выражения создания объекта становится созданный и инициализированный объект. Если конструктор возвращает какой-либо объект, этот объект становится значением всего выражения создания объекта, а вновь созданный объект уничтожается.</p>
<h2>Операторы</h2>
<p><b>Ассоциативность оператора</b> определяет порядок выполнения операций с одинаковым приоритетом. Ассоциативность слева направо означает, что операции выполняются слева направо. Например, оператор вычитания имеет ассоциативность слева направо, поэтому следующие два выражения эквивалентны:</p>
<pre><code class="language-javascript">w = x - y - z;
w = ((x - y) - z)</code></pre>
<p>Выражения в языке JavaScript всегда вычисляются слева направо.</p>

<h3>Унарные операторы с ассоциативностью справа налево</h3>
<pre><code class="language-javascript">i++, ++i, j--, --j //префиксный и постфиксный инкремент(декремент), также присваивает
-i //унарный минус
+i 
~i //поразрядная инверсия
!true //логическая инверсия   
delete //удаление свойства
typeof //определение типа операнда
void //Возврат неопределенного значения</code></pre>

<h3>Бинарные операторы с ассоциативностью слева направо</h3>
<pre><code class="language-javascript">i*j, i/j, i%j //Умножение, деление, деление по модулю
var i = 1, j = ++i; // i и j со­дер­жат зна­че­ние 2
var i = 1, j = i++; // i со­дер­жит зна­че­ние 2, j со­дер­жит зна­че­ние 1    
i+j, i-j 
str1+str2 //Конкатенация строк 
&lt;&lt; //Сдвиг влево
>> //Сдвиг вправо с сохранением знака
>>>> //Сдвиг вправо с заполнением нулями
&lt;, &lt;=, >, >= //Сравнение числовых значений
&lt;, &lt;=, >, >= //Сравнение строк 
instanceof //Проверка на принадлежность классу
in //Проверка наличия свойства
== //Проверка равенства
!= //Проверка неравенства
=== //Проверка идентичности
!== //Проверка неидентичности
& //Поразрядное И; Выполняет логическое И над каждым битом своих целочисленных аргументов
^ //Поразрядное ИСКЛЮЧАЮЩЕЕ ИЛИ
| //Поразрядное ИЛИ
&& //Логическое И
|| //Логическое ИЛИ 
</code></pre>
<h3>Бинарные операторы с ассоциативностью справа налево</h3>
<pre><code class="language-javascript">= //Присваивание переменной или свойству
*=, /=, %=, +=, -=, &=, ^=, |=, &lt;&lt;=, >>=, >>>= //Операция с присваиванием     
</code></pre>
<h3>Алгоритм работы оператора +</h3>
<ol>
    <li>Если значением любого из операндов является объект, он преобразуется в простое значение с использованием алгоритма преобразования объекта в простое значение: объекты <span class="code">Date</span> преобразуются с помощью их метода <span class="code">toString()</span>, а все остальные объекты преобразуются с помощью метода <span class="code">valueOf()</span>, если он возвращает простое значение. Однако большинство объектов не имеют метода <span class="code">valueOf()</span>, поэтому они также преобразуются с помощью метода <span class="code">toString()</span>.</li>
    <li>Если после преобразования объекта в простое значение любой из операндов оказывается строкой, другой операнд также преобразуется в строку и выполняется операция конкатенации.</li>
    <li>В противном случае оба операнда преобразуются в числа (или в NaN) и выполняется операция сложения.</li>
</ol>
<pre><code class="language-javascript">1 + 2 // => 3: сло­же­ние
"1" + "2" // => "12": кон­ка­те­на­ция
"1" + 2 // => "12": кон­ка­те­на­ция по­сле пре­об­ра­зо­ва­ния чис­ла в стро­ку
1 + {} // => "1[object Object]": кон­ка­те­на­ция по­сле
// пре­об­ра­зо­ва­ния объ­ек­та в стро­ку
true + true // => 2: сло­же­ние по­сле пре­об­ра­зо­ва­ния ло­ги­че­ско­го зна­че­ния в чис­ло
2 + null // => 2: сло­же­ние по­сле пре­об­ра­зо­ва­ния null в 0
2 + undefined // => NaN: сло­же­ние по­сле пре­об­ра­зо­ва­ния undefined в NaN
1 + 2 + " blind mice"; // => "3 blind mice"
1 + (2 + " blind mice"); // => "12 blind mice"</code></pre>

<h3>Оператор in</h3>
<p>Оператор in требует, чтобы левый операнд был строкой или мог быть преобразован в строку. Правым операндом должен быть объект. Результатом оператора будет значение true, если левое значение представляет собой имя свойства объекта, указанного справа.</p>
<pre><code class="language-javascript">var point = { x:1, y:1 }; // Оп­ре­де­лить объ­ект
"x" in point // => true: объ­ект име­ет свой­ст­во с име­нем "x"
"z" in point // => false: объ­ект не име­ет свой­ст­ва с име­нем "z".
"toString" in point // => true: объ­ект на­сле­ду­ет ме­тод toString
var data = [7,8,9]; // Мас­сив с эле­мен­та­ми 0, 1 и 2
"0" in data // => true: мас­сив со­дер­жит эле­мент "0"
1 in data // => true: чис­ла пре­об­ра­зу­ют­ся в стро­ки
3 in data // => false: нет эле­мен­та 3</code></pre>

<h3>Оператор instanceof</h3>
<p>Оператор <span class="code">instanceof</span> требует, чтобы левым операндом был объект, а правым – имя класса объектов. Результатом оператора будет значение <span class="code">true</span>, если объект, указанный слева, является экземпляром класса, указанного справа.</p>
<pre><code class="language-javascript">var d = new Date(); // Соз­дать но­вый объ­ект с по­мо­щью кон­ст­рук­то­ра Date()
d instanceof Date; // Вер­нет true; объ­ект d был соз­дан с функ­ци­ей Date()
d instanceof Object; // Вер­нет true; все объ­ек­ты яв­ля­ют­ся эк­зем­п­ля­ра­ми Object
d instanceof Number; // Вер­нет false; d не яв­ля­ет­ся объ­ек­том Number
var a = [1, 2, 3]; // Соз­дать мас­сив с по­мо­щью ли­те­ра­ла мас­си­ва
a instanceof Array; // Вер­нет true; a – это мас­сив
a instanceof Object; // Вер­нет true; все мас­си­вы яв­ля­ют­ся объ­ек­та­ми
a instanceof RegExp; // Вер­нет false; мас­си­вы не яв­ля­ют­ся ре­гу­ляр­ны­ми вы­ра­же­ния­ми</code></pre>
<p>Обратите внимание, что все объекты являются экземплярами класса Object. Определяя, является ли объект экземпляром класса, оператор instanceof принимает во внимание и «суперклассы». Если левый операнд instanceof не является объектом, instanceof возвращает false.</p>
<p>Чтобы вычислить значение выражения o instan­ce­of f, интерпретатор JavaScript определяет значение f.prototype и затем пытается отыскать это значение в цепочке прототипов объекта o. В случае успеха объект o считается экземпляром класса f (или суперкласса класса f), и оператор возвращает true. Если значение f.prototype отсутствует в цепочке прототипов объекта o, то объект o не является экземпляром класса f и оператор instanceof возвращает false.</p>

<h3>Вычисление выражений с помощью <span class="code">eval()</span></h2>
<p>Подобно многим интерпретирующим языкам, JavaScript поддерживает возможность интерпретации строк с программным кодом на языке JavaScript, выполняя их, чтобы получить некоторое значение. В JavaScript эта операция выполняется с помощью глобальной функции <span class="code">eval()</span>:</p>
<pre><code class="language-javascript">eval("3+2") // => 5</code></pre>
<p>Вызов <span class="code">eval("x=1")</span> изменит значение локальной переменной. А если выполнить вызов <span class="code">eval("var y = 3;")</span>, будет объявлена новая локальная переменная y. Точно так же можно определять новые локальные функции:</p>
<pre><code class="language-javascript">eval("function f() { return x+1; }");</code></pre>
<h2>Условный опрератор (<span class="code">?:</span>)</h2>
<p>Условный оператор – это единственный тернарный (с тремя операндами) оператор в JavaScript, и иногда он так и называется – «тернарный оператор». Этот оператор обычно записывается как <span class="code">?:</span>, хотя в программах он выглядит по-другому. Он имеет три операнда, первый предшествует символу <span class="code">?</span>, второй – между <span class="code">?</span> и <span class="code">:</span>, третий – после <span class="code">:</span>. Используется он следующим образом:</p>
<pre><code class="language-javascript">x > 0 ? x : -x // Аб­со­лют­ное зна­че­ние x</code></pre>

<p>Тот же результат можно получить с помощью инструкции if, но оператор <span class="code">?:</span> часто оказывается удобным сокращением:</p>
<pre><code class="language-javascript">//с помщью тренарного оператора
greeting = "hello " + (username ? username : "there");
//это эквивалентно
greeting = "hello ";
if (username)
    greeting += username;
else
    greeting += "there";</code></pre>

<h3>Оператор delete</h3>
<p>Унарный оператор delete выполняет попытку удалить свойство объекта или элемент массива, определяемый операндом.Подобно операторам присваивания, инкремента и декремента, оператор delete обычно используется ради побочного эффекта, выражающегося в удалении свойства, а не ради возвращаемого значения. Ниже приводятся несколько примеров его использования:</p>
<pre><code class="language-javascript">var o = {x: 1, y: 2}; // Оп­ре­де­лить объ­ект
delete o.x; // Уда­лить од­но из его свойств
"x" in o // => false: свой­ст­во боль­ше не су­ще­ст­ву­ет
var a = [1,2,3]; // Соз­дать мас­сив
delete a[2]; // Уда­лить по­след­ний эле­мент мас­си­ва
2 in a // => false: второй элемент больше не существует
a.length // => 3: обратите внимание, что длина мас­сива при этом не изменилась</code></pre>
<p>Ниже приводится несколько примеров использования оператора delete: </p>
<pre><code class="language-javascript">var o = {x:1, y:2}; // Оп­ре­де­лить пе­ре­мен­ную; ини­циа­ли­зи­ро­вать ее объ­ек­том
delete o.x; // Уда­лить од­но из свойств объ­ек­та; вер­нет true
typeof o.x; // Свой­ст­во не су­ще­ст­ву­ет; вер­нет "undefined"
delete o.x; // Уда­лить не­су­ще­ст­вую­щее свой­ст­во; вер­нет true
delete o; // Объ­яв­лен­ную пе­ре­мен­ную уда­лить нель­зя; вер­нет false
// В стро­гом ре­жи­ме воз­бу­дит ис­клю­че­ние.
delete 1; // Ар­гу­мент не яв­ля­ет­ся ле­во­сто­рон­ним вы­ра­же­ни­ем; вер­нет true
this.x = 1; // Оп­ре­де­лить свой­ст­во гло­баль­но­го объ­ек­та без var
delete x; // Уда­лить: вер­нет true при вы­пол­не­нии в не­стро­гом ре­жи­ме; в строгом
// режиме возбудит исключение. Используйте 'delete this.x' взамен.
x; // Ошибка времени выполнения: переменная x не определена</code></pre>
<h3>Оператор void</h3>
<p>Унарный оператор void указывается перед своим единственным операндом любого типа. Этот оператор редко используется и имеет необычное действие: он вычисляет значение операнда, затем отбрасывает его и возвращает undefined. Поскольку значение операнда отбрасывается, использовать оператор void имеет смысл только ради побочных эффектов, которые дает вычисление операнда.</p>
<p>Чаще всего этот оператор применяется в клиентском JavaScript, в адресах URL вида Ja­va­Script:, где он позволяет вычислить выражение ради его побочных действий, не отображая в броузере вычисленное значение. Например, оператор void можно использовать в HTML-теге &lt;a>:</p>
<pre><code class="language-html">&lt;a href="ja­va­script:void window.open();">От­крыть но­вое ок­но&lt;/a></code></pre>

<p></p>
<p></p>
<p></p>
<p></p>
<p></p>






<pre><code class="language-javascript"></code></pre>
<pre><code class="language-javascript"></code></pre>
&lt;







<span class="code"></span>


</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script>hljs.highlightAll();</script>
</html>
