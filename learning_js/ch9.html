<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Глава 9. Асинхронный Javascript</title>

    <style>
        @import url("../styles/styles.css");
        @import url("../modules/vs2015.min.css");
    </style>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../modules/jquery-3.7.1.min.js"><'+'/script>')</script>
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>
</head>


<body>
<script src="../common/counters_body.js"></script>

<h1>Глава 9. Асинхронный Javascript</h1>
<h2>Введение в асинхронное программирование</h2>
<p>Программы, встретившиеся нам до сих пор, построены так, чтобы процессор все время был занят, пока они не закончат свою работу. Скорость, с которой выполняется, к примеру, цикл, манипулирующий числами, в значительной степени зависит от скорости процессора. Но многие программы взаимодействуют с устройствами, находящимися вне процессора. Например, они могут обмениваться данными по компьютерной сети или запрашивать их с жесткого диска, что намного медленнее, чем получать их из памяти.</p>
<p>Когда такое происходит, было бы неверно оставлять процессор без работы - может быть, в это время он мог бы сделать что-то полезное. Отчасти эту задачу решает операционная система, которая переключает процессор между несколькими работающими программами. Но это не помогает, если мы хотим, чтобы одна программа могла продолжать выполнение, пока ожидается ответ на запрос по сети.</p>
<p>Программам часто приходится останавливать вычисления в ожидании поступления данных или при возникновении некоторого события. Программы JS в браузере обычно <i>управляются событиями</i>, т.е. они ждут когда пользователь совершит некоторое действие, прежде чем что-то делать.</p>
<p>Асинхронного программирование в JS реализовано с помощью следующих средств:</p>
<ol>
    <li>Объекты <span class="code">Promise</span> - пока недоступный результат асинхронной операции.</li>
    <li>Ключевые слова <span class="code">async</span> и <span class="code">await</span> упрощают асинхронное программирование, позволяя структурировать основанный на <span class="code">Promise</span> код, как если бы он был синхронным.</li>
    <li>Асинхронные операторы и цикл <span class="code">for</span>/<span class="code">await</span> дают возможность работать с потоками асинхронных события, используя простые циклы, которые выглядят синхронными.</li>
</ol>

<h3>Что такое асинхронность?</h3>
<p>В модели <b>синхронного программирования</b> все операции выполняются по
одной строго в том порядке, в котором они появляются. Если вы вызвали функцию, которая выполняет какое-то длительное
действие, она завершит работу и сможет вернуть результат только после
того, как данное действие будет завершено. Благодаря это можно легко определить состояние программы в любой заданной точке кода.</p>
<p><b>Асинхронная модель</b> позволяет делать несколько вещей одновременно. Когда вы запускаете действие, программа продолжает работать. Когда действие
заканчивается, программа получает уведомление об этом и получает доступ
к результату (например, к данным, прочитанным с диска).</p>
<p>Синхронное и асинхронное программирование можно сравнить на простом
примере — программы, которая получает по сети два ресурса, а затем объединяет результаты.</p>
<p>В <i>синхронной среде</i>, где функция запроса возвращает результат только после того, как она завершила свою работу, самый простой способ выполнить эту задачу — сделать запросы один за другим. У такого подхода есть недостаток: выполнение второго запроса начнется только после завершения первого. Общее время будет равно как минимум сумме времени выполнения обоих запросов.</p>
<p>Решение данной проблемы в синхронной системе заключается в запуске дополнительных <i>управляющих потоков</i>. <b>Поток</b> — это еще одна запущенная программа, так что операционная система может чередовать ее выполнение с другими программами. Это возможно, поскольку большинство современных компьютеров имеют несколько процессоров, так что несколько потоков могут выполняться одновременно на разных процессорах. Второй поток может запустить второй запрос, а затем оба потока будут ожидать возвращения результатов, после чего будут повторно синхронизированы для объединения последних.</p>
<img src="https://ltdfoto.ru/images/2024/07/15/image70e304910b03d691.png" alt="image70e304910b03d691.png" border="0" />
<p>На представленной выше схеме <b>жирные линии</b> - это время, которое программа тратит на обычную работу, а <i>тонкие</i> — время, затраченное на ожидание ответа по сети. В синхронной модели время, затраченное на сеть, является частью временной шкалы для данного управляющего потока.</p>
<p>В асинхронной модели начало сетевой операции концептуально вызывает разделение временной шкалы. Программа, которая инициировала действие, продолжает выполняться, а действие выполняется независимо от этого, уведомляя программу о своем завершении.</p>
<p>Еще один способ описать разницу заключается в том, что в синхронной
модели ожидание завершения действий подразумевается неявно, а в асинхронной — явно, и мы его контролируем.</p>
<p>Обе основные платформы программирования на JavaScript — браузеры
и Node.js — выполняют операции, которые могут занять какое-то время,
асинхронно, вместо того чтобы полагаться на потоки. Поскольку программирование с потоками печально известно своей сложностью (понять, что
делает программа, гораздо сложнее, если она делает несколько вещей одновременно), это обычно считается хорошей идеей.</p>


<h2>Асинхронное программирование с использованием обратных вызовов</h2>
<p><b>Обратный вызов</b> - это функция, которую вы пишите, а затем передаете какой-то другой функции. Затем другая функция вызывает вашу функцию (<i>"делает обратный вызов"</i>), когда удовлетворяется определенное условие или происходит некоторое асинхронное событие. Вызов предоставленной вами функции обратного вызова уведомляет вас об условии или событии, а иногда вызов будет включать аргументы функции, которые обеспечивают дополнительные детали.</p>
<p>Один из подходов к асинхронному программированию состоит в том, чтобы заставить функции, которые выполняют медленные действия, принимать дополнительный аргумент — функцию обратного вызова. Действие запускается, и, когда оно будет завершено, вызывается функция обратного вызова, которой передается результат этого действия.</p>








<h3>Таймеры</h3>
<p>В JS существует 2 вида таймеров:</p>
<ul>
    <li><span class="code">setTimeout(function, timer:ms)</span></li>
    <li><span class="code">setInterval(function, timer:ms)</span></li>
</ul>
<p>Функция в аргументе таймер-функции также является функцией обратного вызова. Сама же функция-таймер вызывается для регистрации функции обратного вызова и указания, при каких асинхронных условиях она должна вызываться.</p>

<h3>События</h3>
<h3>События со стороны клиента</h3>
<p>Программа JS стороны клиента почти всегда управляется событиями: т.е. программы ожидают некоторого действия пользователя перед своим выполнением. Программа JS, управляемая событиями, регистрирует функции обратного вызова для указания типов события в заданных контекстах, а веб-браузер вызывает такие функции всякий раз, когда происходит указанные события. Эти функции обратного вызова называются <b>обработчиками (прослушивателями) событий</b> и регистрируются с помощью <span class="code">addEventListener()</span>:</p>
<pre><code class="language-html">&lt;div style="display: flex; flex-direction: column;" id="event-ex1">
    &lt;span>Мин:&lt;input id="min_ex1" type="number" value="0">&lt;/span>
    &lt;span>Макс:&lt;input id="max_ex1" type="number" value="10">&lt;/span>
    &lt;button id="event_button_ex1">Сгенерировать случайное число&lt;/button>
    &lt;div style="background-color: #ffff99" id="random_number_ex1">&lt;/div>
&lt;/div>
&lt;script>
    let rnum_generator=document.getElementById('event_button_ex1')
    //регистрируем функцию обратного вызова, при клике на кнопку
    rnum_generator.addEventListener('click', generateRandom)

    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateRandom(){
        let minN=document.getElementById('min_ex1').value
        let maxN=document.getElementById('max_ex1').value
        if (minN&lt;maxN){
            document.getElementById('random_number_ex1').innerHTML=getRandomInt(minN, maxN)
        }
    }
&lt;/script></code></pre>


<div style="display: flex; flex-direction: column;" id="event-ex1">
<span>Мин:<input id="min_ex1" type="number" value="0"></span>
<span>Макс:<input id="max_ex1" type="number" value="10"></span>
<button id="event_button_ex1">Сгенерировать случайное число</button>
<div style="background-color: #ffff99" id="random_number_ex1"></div>
</div>
<script>
    let rnum_generator=document.getElementById('event_button_ex1')
    //регистрируем функцию обратного вызова, при клике на кнопку
    rnum_generator.addEventListener('click', generateRandom)

    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateRandom(){
        let minN=document.getElementById('min_ex1').value
        let maxN=document.getElementById('max_ex1').value
        if (minN<maxN){
            document.getElementById('random_number_ex1').innerHTML=getRandomInt(minN, maxN)
        }
    }
</script>

<h3>События сети</h3>
<p>Распространенным источником асинхронности являются сетевые запросы.</p>
<pre><code class="language-html">&lt;script>
    //http-запрос версии сервера api
    function getCurrentVersionNumber(versionCallback){
        let request= new XMLHttpRequest();
        request.open("GET", "https://www.example.com/api/version");
        request.send();
        //регистрация обратного вызова, который будет вызыватьсяя при получении ответа
        request.onload=function(){
            if (request.status === 200) {
                //если статус http нормально, то получить номер версии и вызвать коллбэк
                let currentVersion=parseFloat(request.responseText);
                versionCallback(null, currentVersion);
            }
            else {
                versionCallback(request.statusText, null)
            }
        }
        //регистрация коллбэка для ошибок
        request.onerror=request.ontimeout=function(e){
            versionCallback(e.type, null)
        }
    }
&lt;/script></code></pre>
<p>В коде сервера стороны клиента можно использовать класс <span class="code">XMPHttpRequest</span> и коллбэк, чтобы делать HTTP-запросы и асинхронным образом обрабатывать ответы сервера, когда они поступают.</p>
<p>В примере выше не используется способ регистрации прослушивателя событий на объекте генерирующем события через метод <span class="code">addEventListener()</span>. Вместо этого, свойству объекта присваивается колббэк. Эта своства <span class="code">onload</span>, <span class="code">onerror</span>, <span class="code">ontimeout</span>. Способ с <span class="code">addEventListener()</span> более гибкий, т.к. он позволяет добавлять множество обработчиков событий. </p>

<h3>События в Node</h3>
<!--todo: вернуться к событиям в Node после начала изучения Node-->
<p>См. Флэнаган (стр. 379)</p>

<h2>Объекты <span class="code">Promise</span></h2>
<p>Объект <span class="code">Promise</span> - асинхронное действие, которое может заершится в какой-то момент и произвести значение. Не существует способа синхронно получить значение объекта <span class="code">Promise</span>, мы можем только предложить <span class="code">Promise</span> вызвать какую-то колбэк-функцию, когда значение готово. </p>
<p>Одна настоящая проблема с асинхронным программированием на основе обратных вызовов заключается в том, что нередко приходится сталкиваться с обратными вызовами внутри обратных вызовов внутри обратных вызовов, когда строки кода имеют настолько широкие отступы, что их трудно читать. Объекты <span class="code">Promise</span> позволяют выражать вложенные обратные вызовы подобного рода в виде более линейной цепочки объектов <span class="code">Promise</span> которая легче для чтения и понимания, тем самым предотвращая ситуацию т.н. <i>колбэк-ада</i>.</p>

<p>Начиная с ECMAScript6, <span class="code">Promise</span> является поддерживаемым ссылочным типом и может быть создан с помощью оператора <span class="code">new</span>. Для этого требуется передать параметр функции исполнителя, который здесь является пустым объектом функции, чтобы угодить интерпретатору:</p>
<pre><code >let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise &lt;pending></code></pre>


<p>Самый простой способ создать промис — вызвать <span class="code">Promise.resolve</span>. Эта
функция гарантирует, что переданное ей значение будет обернуто в промис. Если это значение и так уже является промисом, то оно будет просто
возвращено, в противном случае вы получите новый промис, который сразу
же выдает заданное значение в качестве результата.</p>

<pre><code>&lt;script>
    let fifteen = Promise.resolve(15);
    fifteen.then(value => console.log(`Получено ${value}`));
&lt;/script>
</code></pre>
<div class="code-example-output-title"><span>Вывод:</span>
<div class="code-example-output">
<pre id="promise-ex1">
<script>
    let fifteen = Promise.resolve(15);
    fifteen.then(value => addOutputString("#promise-ex1",`Получено ${value}`));
</script>
</pre>
</div>
</div>
<p>Чтобы получить результат промиса, можно использовать его метод <span class="code">then</span>.
Этот метод регистрирует функцию обратного вызова, которая будет вызвана,
когда промис разрешится и создаст значение. У одного промиса может быть
несколько обратных вызовов, и они будут вызываться, даже если добавить
их после того, как промис будет разрешен (завершен).</p>

<p>Но это еще не все, что делает метод <span class="code">then</span>. Он возвращает другой промис,
разрешаемый значением, которое возвращает функция-обработчик, или,
если та возвращает промис, ожидает этого промиса и затем разрешает его
результат.</p>

<p>Бывает полезно рассматривать промисы как устройства, позволяющие
перенести значения в асинхронную реальность. Обычное значение просто
существует. Обещанное значение — это значение, которое <i>может уже существовать</i> или <i>может появиться в какой-то момент в будущем</i>. Вычисления,
определенные в терминах промисов, оперируют такими упакованными
значениями и выполняются асинхронно, по мере того как значения становятся доступными.</p>

<p>Чтобы создать промис, можно использовать <span class="code">Promise</span> в качестве конструктора.
У <span class="code">Promise</span> немного странный интерфейс — конструктор ожидает в качестве
аргумента функцию, которую он немедленно вызывает, передавая ей функцию, которую можно использовать для разрешения промиса. Конструктор
работает таким образом, а не, например, с методом <span class="code">resolve</span>, поэтому разрешить промис может только код, создавший этот промис.</p>
<p>Ниже показано, как можно создать интерфейс на основе промисов для
функции readStorage:</p>
<pre><code >function storage(nest, name) {
    return new Promise(resolve => {
        nest.readStorage(name, result => resolve(result));
    });
}

storage(bigOak, "enemies")
.then(value => console.log("Получено", value));</code></pre>



<h3>Машина состояний промисов</h3>
<p>При передаче экземпляра промиса в <span class="code">console.log</span> выводы консоли (которые могут различаться в разных браузерах) указывают, что этот экземпляр промиса находится в состоянии ожидания. Как упоминалось ранее, промис — это объект с состоянием, который может существовать в одном из трех состояний:</p>
<ul>
    <li><b>в ожидании</b> (<i>Pending</i>);</li>
    <li><b>выполнен</b> (иногда также называется <b>решенным</b>) (<i>Fulfilled</i>);</li>
    <li><b>отклонен</b> (<i>Rejected</i>).</li>
</ul>
<p><b>Состояние ожидания</b> - это начальное состояние, с которого начинается промис. Из состояния ожидания промис может быть переведен в <b>выполненное состояние</b>, указывающее на успех, или <b>отклоненное</b>, указывающее на отказ.</p>
<p>Э<i>тот переход к установленному состоянию необратим</i>; как только происходит переход к выполненному или отклоненному состоянию, состояние промиса уже не сможет измениться. Кроме того, не гарантируется, что промис когда-либо покинет состояние ожидания. Следовательно, хорошо структурированный код должен вести себя правильно, если промис успешно разрешается, если он отклоняется или никогда не выходит из состояния ожидания.
</p>
<p>Важно отметить, что состояние промиса является частным и не может быть напрямую проверено в JavaScript. Причина этого заключается прежде всего в том, чтобы предотвратить синхронную программную обработку объекта промиса на основе его состояния при чтении. Кроме того, состояние промиса не может быть изменено внешним JS-кодом по той же причине, по которой состояние не может быть прочитано: промис намеренно инкапсулирует блок асинхронного поведения, а внешний код, выполняющий синхронное определение его состояния, противоречит его цели.</p>






</body>
</html>