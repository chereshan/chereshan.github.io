<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
    <title>Чернышев Егор. Обо мне</title>

</head>
<!--todo: мигрировать на phpstorm-->



<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="header"></div>
<h1>Гл. 1. Введение в PHP</h1>

<ol>
    <b>Источники:</b>
    <li>Маклафлин Б. PHP и MySQL. Исчерпывающее руководство. 2-е изд. — СПб.: Питер, 2014. — 544 с.: ил. — (Серия «Бестселлеры O’Reilly»).</li>
    <li>Татро Кевин, Макинтайр Питер. Создаем динамические веб-сайты на PHP. 4-е междунар. изд. — СПб.: Питер,
        2021. — 544 с.: ил. — (Серия «Бестселлеры O’Reilly»).</li>
    <li>Колисниченко Д. Н. Современный сайт на РНР и JavaScript (+CD). — СПб.: Питер, 2009. — 176 с.</li>
    <li>Никсон Р. Создаем динамические веб-сайты с помощью PHP, MySQL, JavaScript, CSS и HTML5. 4-е изд. — СПб.: Питер, 2016. — 768 с.: ил. — (Серия «Бестселлеры O’Reilly»).</li>
</ol>


<h2>Основы, заложенные Бернерсом-Ли</h2>
<p>HTTP представляет собой стандарт взаимодействия, регулирующий порядок направления запросов и получения ответов — процесса, происходящего между браузером, запущенным на компьютере конечного пользователя, и веб-сервером.</p>
<p>Задача сервера состоит в том, чтобы принять запрос от клиента и попытаться дать на него содержательный ответ, обычно передавая ему запрошенную веб-страницу. Именно поэтому и используется термин <i>«сервер»</i> («обслуживающий»). Партнером, взаимодействующим с сервером, является клиент, поэтому данное понятие применяется как к браузеру, так и к компьютеру, на котором он работает.</p>
<p>Между клиентом и сервером может располагаться ряд других устройств, например маршрутизаторы, модули доступа, шлюзы и т. д. Они выполняют различные задачи по обеспечению безошибочного перемещения запросов и ответов между клиентом и сервером. Как правило, для отправки этой информации используется интернет. Некоторые из этих промежуточных устройств могут также ускорить интернет путем локального сохранения страниц или информации в так называемом кэше, обслуживая затем данное содержимое для клиентов непосредственно из кэша, без постоянного извлечения его из сервера-источника.</p>
<h3>Процедура «запрос—ответ»</h3>
<p>В наиболее общем виде процесс «запрос — ответ» состоит из просьбы браузера или другой платформы к веб-серверу отправить ему веб-страницу и выполнения браузером данной просьбы. После этого браузер занимается отображением или рендерингом страницы.</p>
<img src="imgs/request-responce.png">
При этом соблюдается такая последовательность действий.
<ol>
    <li>Вы вводите в адресную строку браузера <span class="code">http://server.com</span></li>
    <li>Ваш браузер ищет IP-адрес, соответствующий доменному имени server.com</li>
    <li>Браузер посылает запрос на главную страницу <span class="code">server.com</span>.</li>
    <li>Запрос проходит по интернету и поступает на веб-сервер server.com.</li>
    <li>Веб-сервер, получивший запрос, ищет веб-страницу на своем жестком диске.</li>
    <li>Сервер извлекает веб-страницу и отправляет ее по обратному маршруту в адрес браузера.</li>
    <li>Браузер отображает веб-страницу</li>
</ol>

<p>При передаче типовой веб-страницы этот процесс также осуществляется для каждого имеющегося на ней объекта: элемента графики, встроенного видео- или Flash-ролика и даже шаблона CSS.</p>
<p>Обратите внимание на то, что на шаге 2 браузер ищет IP-адрес, принадлежащий доменному имени server.com. У каждой машины, подключенной к интернету, включая и ваш компьютер, есть свой IP-адрес. Но, как правило, доступ к веб-серверам осуществляется по именам, таким как google.com. Браузер обращается к вспомогательной интернет-службе, так называемой системе доменных имен (Domain Name System — DNS), чтобы найти связанный с сервером IP-адрес, а затем воспользоваться им для связи с компьютером.</p>
<p>Для динамического сайта эта последовательность действий может принимать следующий вид:</p>
<img src="imgs/dynamic_request-responce.png" alt="">
<ol>
    <li>Вы вводите в адресную строку браузера <span class="code">http://server.com</span>.</li>
    <li>Ваш браузер ищет IP-адрес, соответствующий доменному имени server.com</li>
    <li>Браузер посылает запрос на главную страницу <span class="code">server.com</span></li>
    <li>Запрос проходит по Сети и поступает на веб-сервер <span class="code">server.com</span></li>
    <li>Веб-сервер, получивший запрос, ищет веб-страницу на своем жестком диске.</li>
    <li>Теперь, когда главная страница размещена в его памяти, веб-сервер замечает, что она представлена файлом, включающим в себя PHP-сценарии, и передает страницу интерпретатору PHP</li>
    <li>Интерпретатор PHP выполняет PHP-код.</li>
    <li>Кое-какие фрагменты кода PHP содержат MySQL-инструкции, которые интерпретатор PHP, в свою очередь, передает процессору базы данных MySQL</li>
    <li>База данных MySQL возвращает результаты выполнения инструкции интерпретатору PHP</li>
    <li>Интерпретатор PHP возвращает веб-серверу результаты выполнения кода PHP, а также результаты, полученные от базы данных MySQL</li>
    <li>Веб-сервер возвращает страницу выдавшему запрос клиенту, который отображает эту страницу на экране</li>
</ol>
<p>Также не стоит забывать о JavaScript-коде, который интерпретируется локально на машине клиента.</p>
<p></p>
<p></p>



<h2>Динамические веб-страницы</h2>

<p>Использование PHP существенно упрощает встраивание средств, придающих веб-страницам динамические свойства. Когда страницам присваивается расширение PHP, у них появляется прямой доступ к языку сценариев. Разработчику нужно лишь написать код, похожий на этот:</p>
<pre><code class="language-php">&lt;?php
    echo  "Сегодня" . date('T') . ". ";
?>
// или эквивалентно
Сегодня &lt;?php echo date("l"); ?>. Последние новости.
Последние новости.</code></pre>
<p>Открывающий тег <span class="code">&lt;?php</span> дает веб-серверу разрешение на интерпретацию всего последующего кода вплоть до тега <span class="code">?></span>. Все, что находится за пределами этой конструкции, отправляется клиенту в виде простого HTML. Поэтому текст <i>Последние новости</i> просто выводится в браузер. А внутри PHP-тегов встроенная функция <span class="code">date()</span> отображает текущий день недели, соответствующий системному времени сервера.</p>
<p>Упомянув PHP, не забудем также и о других героях программирования динамических веб-страниц, а именно MySQL, JavaScript, CSS, HTML5 и, конечно, Apache</p>
<p>Мы уже немного касались того, что делает веб-сервер в процессе обмена информацией между клиентом и сервером по протоколу HTTP, но на самом деле негласно он выполняет куда более масштабную работу</p>
<p>В дополнение к модулям PHP наиболее важными для вас как для веб-программиста будут модули, занимающиеся обеспечением безопасности. В качестве других примеров может послужить модуль Rewrite, позволяющий веб-серверу обрабатывать широкий диапазон типов URL-адресов и перезаписывать их в соответствии с его внутренними требованиями, и модуль Proxy, который можно использовать для обслуживания часто запрашиваемых страниц из кэша, чтобы снизить нагрузку на сервер.</p>
<p>Истинная красота рождается однако в сочетании этих технологий: PHP занят основной работой на веб-сервере, MySQL управляет данными, а CSS и JavaScript вместе заботятся о представлении веб-страницы. JavaScript может также взаимодействовать с вашим PHP-кодом на веб-сервере, когда ему нужно что-нибудь обновить (как на сервере, так и на веб-странице). И с новыми, высокоэффективными свойствами HTML5, такими как холсты, аудио, видео и геолокация, можно придать вашим веб-страницам более высокую динамичность, интерактивность и мультимедийность.</p>
<p>Неплохо бы теперь подвести краткий итог всему, что изложено в данной части главы, и рассмотреть процесс, сочетающий в себе некоторые из этих технологий в повседневно использующейся многими сайтами функции асинхронного обмена данными: проверке в процессе регистрации новой учетной записи, не занято ли выбранное имя другим посетителем сайта. Хорошим примером подобного использования технологий может послужить почтовый сервер Gmail. Этот асинхронный процесс состоит из следующих шагов:</p>
<ol>
    <li>Сервер выдает код HTML для создания веб-формы, запрашивающей необходимые данные: имя пользователя, настоящее имя, настоящую фамилию и адрес электронной почты.</li>
    <li>Одновременно с этим сервер вкладывает в HTML JavaScript-код, позволяющий отслеживать содержимое поля ввода имени пользователя и проверять два обстоятельства: введен ли в это поле какой-нибудь текст и был ли фокус ввода перемещен из этого поля по щелчку пользователя на другом поле ввода.</li>
    <li>Как только будет введен текст и фокус ввода перемещен на другой элемент формы, код JavaScript в фоновом режиме передает введенное имя пользователя PHP-сценарию на веб-сервере и ждет ответной реакции.</li>
    <li>Веб-сервер осуществляет поиск имени пользователя и возвращает коду JavaScript ответ, в котором сообщает, было ли уже задействовано такое же имя.</li>
    <li>Затем JavaScript размещает под полем ввода имени пользователя индикатор приемлемости имени пользователя, возможно, в виде зеленой галочки или красного крестика, сопровождая его текстом.</li>
    <li>Если пользователь ввел неприемлемое имя, но все же пытается отправить форму, код JavaScript прерывает отправку и повторно обращает внимание пользователя (возможно, выводя более крупный графический индикатор и (или) открывая окно предупреждения) на необходимость выбора другого имени.</li>
    <li>Усовершенствованная версия этого процесса может даже изучить имя, запрошенное пользователем, и предложить альтернативное доступное на данный момент имя.</li>
</ol>

<h2>Установка сервера, предназначенного для разработки</h2>
<p><b>WAMP</b>, <b>MAMP</b> и <b>LAMP</b> — это сокращения от «Windows, Apache, MySQL и PHP», «Mac, Apache, MySQL и PHP» и «Linux, Apache, MySQL и PHP» соответственно. Данными сокращениями описываются полноценные функциональные установки, используемые для разработки динамических веб-страниц.</p>
<p>Существует несколько доступных WAMP-серверов, каждый из которых предлагает свою, немного отличающуюся от других конфигурацию. Среди различных есплатных вариантов с открытым кодом самым лучшим будет AMPPS.</p>
<p>После установки и запуска <b>AAMPS</b> по адресу <span class="code">localhost</span> или <span class="code">http://127.0.0.1/</span> мы увидим корневой каталог нашего сервера. </p>
<p>Перейдя на страницу <span class="code">http://localhost/ampps/index.php?</span> мы увидим настройки сервера. </p>
<p><span class="code">file:///C:/Program%20Files/Ampps/www/</span></p>

<h2>Введение в PHP</h2>
<p><b>Серверные скрипты:</b> Язык PHP изначально разрабатывался для создания динамического веб-контента и до сих пор лучше других языков подходит для этой задачи. Для генерирования разметки HTML вам понадобится парсер PHP и веб-сервер для отправки закодированных файлов. PHP также отлично генерирует динамический контент через подключение к БД, документы XML, графику, файлы PDF и т. д.</p>
<p><b>Скрипты командной строки:</b> PHP может выполнять скрипты в режиме командной строки по аналогии с Perl, awk или командной оболочкой Unix. Скрипты командной строки могут использоваться для таких задач системного администрирования, как резервное копирование и разбор журналов, а также для разработки некоторых скриптов в стиле заданий CRON (невизуальных задач PHP).</p>
<p>PHP - это интерпретатор, а не компилятор. Компиляторы создают исполняемый код, который может выполняться без самого компилятора. Интерпретатор такого кода не создает, поэтому для выполнения программ, написанных на PHP, вам понадобится интерпретатор PHP — программа, которая будет выполнять ваши PHP-сценарии.</p>

<h2>Краткая история PHP</h2>
<p>Расмус Лердорф (Rasmus Lerdorf) начал задумываться о создании PHP в 1994 году, но PHP, который используется сегодня, сильно отличается от исходной версии. Чтобы понять, как PHP пришел к его нынешнему виду, полезно знать историю эволюции языка. Эта история описана ниже (с комментариями и сообщениями самого Расмуса).</p>

<h3>Эволюция PHP</h3>
<h4>PHP 1.0 (1995)</h4>

<h4>PHP 2.0 (1996)</h4>

<h4>PHP 3.0 (1998)</h4>

<p>По умолчанию в конце имен PHP-документов ставится расширение PHP. Когда веб-сервер встречает в запрашиваемом файле это расширение, он автоматически передает файл PHP-процессору. Веб-серверы имеют довольно широкий диапазон настроек, и некоторые веб-разработчики выбирают такой режим работы, при котором для разбора PHP-процессору принудительно передаются также файлы с расширениями HTM или HTML. Обычно это связано с тем, что разработчики хотят скрыть факт использования PHP.</p>
<p>Программа на PHP отвечает за возвращение файла в чистом виде, пригодном для отображения в браузере. В простейшем случае на выходе документа PHP будет получаться только код HTML. Чтобы убедиться в этом, можно взять любой HTML-документ и сохранить его в качестве PHP-документа (например, сохраняя файл index.html под именем index.php), и он будет отображаться точно так же, как исходный файл.</p>
<p>Небольшая PHP-программа Hello World может иметь вид, показанный в примере</p>
<pre><code class="language-php">&lt;?php
 echo "Hello world";
?>
//эквивалентно
&lt;?
 echo "Hello world";
?></code></pre>
<p>Некоторые программисты открывают его в начале документа, а закрывают в самом конце и выводят любой код HTML путем непосредственного использования команды PHP. Другие программисты предпочитают помещать в эти теги как можно меньшие фрагменты кода PHP и именно в тех местах, где нужно воспользоваться динамическими сценариями, а весь остальной документ составлять из стандартного кода HTML. Сторонники последнего метода программирования зачастую аргументируют свой выбор тем, что такой код выполняется быстрее, а сторонники первого метода утверждают, что увеличение скорости настолько мизерное, что оно не может оправдать дополнительные сложности многочисленных вставок PHP в отдельно взятый документ.</p>
<p>Несмотря на то что при выборе <span class="code">&lt;?</span> неочевиден вызов PHP-парсера, это вполне приемлемый альтернативный синтаксис, который, как правило, также работает. Но я не советую его использовать, поскольку он несовместим сXML и в настоящее время его применение не приветствуется (это значит, что он больше не рекомендуется и его поддержка может быть удалена в будущих версиях).</p>
<p>Если в файле содержится только код PHP, то закрывающий тег ?> можно опустить. Именно так и нужно делать, чтобы гарантировать отсутствие в файлах PHP лишнего пустого пространства (что имеет особую важность при написании объектно-ориентированного кода).</p>
<ul>
    <b>Основные черты PHP:</b>
    <li>Комментарии: <span class="code">//однострочник</span> и <span class="code">/*многотрочник*/</span></li>
    <li>Команды PHP завершаются точкой с запятой <span class="code">;</span></li>
    <li>Перед именем всех переменных ставится <span class="code">$</span></li>
    <li>В PHP используются стандартные литералы.</li>
    <li>Отсчет индексов начинается с 0</li>
    <li>PHP чувствителен к регистру</li>
    <li>PHP - слабо типизированный язык, т.е. переменные не требуют объявления перед использованием и что PHP всегда преобразует переменные в тот тип, который требуется для их окружения на момент доступа к ним. </li>
</ul>
<p>Символ <span class="code">$</span> используется в разных языках программирования в различных целях. Например, в языке BASIC символ <span class="code">$</span> применялся в качестве завершения имен переменных, чтобы показать, что они относятся к строкам</p>



<p>А в PHP символ <span class="code">$</span> должен ставиться перед именами всех переменных. Это нужно для того, чтобы PHP-парсер работал быстрее, сразу же понимая, что имеет дело с переменной. К какому бы типу ни относились переменные — к числам, строкам или массивам, все они должны выглядеть так, как показано</p>
<pre><code class="language-php">&lt;?php
 $mycounter = 1;
 $mystring = "Hello";
 $myarray = array("One", "Two", "Three");
?></code></pre>
<p>PHP дает полную свободу использования (или игнорирования) любых отступов и любого количества пробелов на ваше усмотрение. В действительности же разумное использование того, что называется свободным пространством, обычно поощряется (наряду с подробным комментированием), поскольку помогает разобраться в собственном коде, когда к нему приходится возвращаться по прошествии некоторого времени. Это помогает и другим программистам, вынужденным поддерживать ваш код</p>
<p>Первая PHP-программа:</p>
<pre><code class="language-php">&lt;?php // test1.php
 $username = "Fred Smith";
 echo $username;
 echo "&lt;br>";
 $current_user = $username;
 echo $current_user;
?></code></pre>
<h3>Массивы</h3>
<pre><code class="language-php">&lt;?php
$team = array(Bill', 'Mary', 'Mike', 'Chris', 'Anne');
echo $team[3]; // Эта команда отображает имя Chris
//Двумерный массив
$oxo = array(array('x', ' ', 'o'),
        array('o', 'o', 'x'),
        array('x', 'o', ' '));
echo $oxo[1][2]; // Эта команда отображает х
?></code></pre>

<h3>Правила присваивания имен переменных</h3>
<ul>
    <li>Имена после знака $ должны начинаться с буквы или с _</li>
    <li>Имена могут содержать [a-zA-Z0-9_]</li>
    <li>Имена не могут включать пробелы</li>
    <li>Имена переменных чувствительны к регистру символов</li>
</ul>

<h3>Операторы</h3>
<h4>Арифметические операции</h4>
<p>Отличия от других языков</p>
<table>
    <tbody>
    <tr>
        <td>Описание</td>
        <td>Пример</td>
    </tr>
    <tr>
        <td>Инкремент</td>
        <td>++$j</td>
    </tr>
    <tr>
        <td>Декремент</td>
        <td>--$j</td>
    </tr>
    <tr>
        <td>Возведение в степень</td>
        <td>$j**3</td>
    </tr>
    </tbody>
</table>

<h4>Операторы присваивания</h4>
<p>Аналогичные другим языкам за исключением <span class="code">.=</span></p>

<h4>Операторы сравнения</h4>
<p>Аналогичные другим языкам за исключением <span class="code">&lt;></span> (второй вариант "не равно"), <span class="code">===</span> (тождественно) и <span class="code">!==</span> (не тождественно)</p>

<h4>Логические операторы</h4>
<pre><code class="language-php">if ($hour > 12 && $hour < 14) dolunch();</code></pre>
<p>Аналогично другим языкам, т.е. PHP имеет следующие логические операторы: <span class="code">and</span> (<span class="code">&&</span>), <span class="code">or</span> (<span class="code">||</span>), <span class="code">!</span>, <span class="code">xor</span> (исключающее ИЛИ).</p>
<h4>Конкатенация строк</h4>
<p>Самый простой способ объединения строк выглядит следующим образом:</p>
<pre><code class="language-php">echo "У вас " . $msgs . " сообщений.";</code></pre>
<p>Так же как с помощью оператора += можно добавить значение к числовой переменной, с помощью оператора .= можно добавить одну строку к другой:</p>
<pre><code class="language-php"><$bulletin .= $newsflash;</code></pre>
<h4>Строки</h4>
<p>если требуется включить в состав строки значение переменной, используется строка, заключенная в двойные кавычки:</p>
<pre><code class="language-php">echo "На этой неделе ваш профиль просмотрело $count человек ";</code></pre>
<p>Инструкция echo может выводить сразу несколько строк</p>
<pre><code class="language-php">&lt;?php
 $author = "Steve Ballmer";
 echo "Developers, Developers, developers, developers,
 developers,developers, developers, developers, developers!
 $author.";
?></code></pre>
<p>Многострочное присваивание</p>
<pre><code class="language-php">&lt;?php
 $author = "Bill Gates";
 $text = "Measuring programming progress by lines of code is like
 measuring aircraft building progress by weight.
 – $author.";
?></code></pre>
<p>Еще один вариант инструкции echo, использующей сразу
    несколько строк</p>
<pre><code class="language-php">&lt;?php
 $author = "Brian W. Kernighan";
 echo &lt;&lt;&lt;_END
 Debugging is twice as hard as writing the code in the first place.
 Therefore, if you write the code as cleverly as possible, you are,
 by definition, not smart enough to debug it.
 $author.
_END;
?></code></pre>
<p>Этот код предписывает PHP вывести все, что находится между двумя тегами
    <span class="code">_END</span>, как будто все это является строкой, заключенной в двойные кавычки (за
    исключением того, что изменять предназначение кавычек в heredoc не нужно). Это означает, что разработчику можно, например, написать целый раздел
    HTML-кода прямо в коде PHP, а затем заменить конкретные динамические
    части переменными PHP.</p>
<p>Присваивание переменной многострочного значения</p>
<pre><code class="language-php">&lt;?php
 $author = "Scott Adams";
 $out = &lt;&lt;&lt;_END
 Normal people believe that if it ain't broke, don't fix it.
 Engineers believe that if it ain't broke, it doesn't have enough
 features yet.
 – $author.
_END;
echo $out;
?></code></pre>
<h3>Типы переменных</h3>
<p>PHP автоматически преобразует типы.</p>
<p>Например, автоматическое преобразование числа в строку</p>
<pre><code class="language-php">&lt;?php
 $number = 12345 * 67890;
 echo substr($number, 3, 1);
?></code></pre>
<p>Когда присваивается значение, $number является числовой переменной. Но во
    второй строке кода вызов значения этой переменной помещен в PHP-функцию
    substr(), которая должна вернуть из переменной $number один символ, стоящий
    на четвертой позиции.  Для выполнения этой задачи PHP превращает $number в строку, состоящую из девяти символов, чтобы функция substr() могла получить к ней
    доступ и вернуть символ, в данном случае 1</p>
<p>Автоматическое преобразование строки в число:</p>
<pre><code class="language-php">&lt;?php
 $pi = "3.1415927";
 $radius = 5;
 echo $pi * ($radius * $radius);
?></code></pre>
<h4>Константы</h4>
<p>Константы, как и переменные, хранят информацию для последующего доступа,
    за исключением того, что они оправдывают свое название (постоянные). Иными
    словами, после определения констант их значения устанавливаются для всей
    остальной программы и не могут быть изменены. </p>
<p>К примеру, константа может использоваться для хранения местоположения
    корневого каталога вашего сервера (папки, содержащей основные файлы вашего
    сайта). Определить такую константу можно следующим образом:</p>
<pre><code class="language-php">define("ROOT_LOCATION", "/usr/local/www/");</code></pre>
Затем для чтения содержимого константы нужно просто сослаться на нее как
на обычную переменную (но не предваряя ее имя знаком доллара):
<pre><code class="language-php">$directory = ROOT_LOCATION;</code></pre>
<p>Теперь, как только понадобится запустить ваш PHP-код на другом сервере
    с другой конфигурацией папок, придется изменить только одну строку кода.</p>
<p>Важно помнить о двух основных особенностях констант: перед их именами
    не нужно ставить символ $ (в отличие от имен обычных переменных) и их
    можно определить только с помощью функции define().</p>
<p>По общепринятому соглашению считается правилом хорошего тона использовать в именах констант буквы только верхнего регистра, особенно если ваш код
    будет также читать кто-нибудь другой.</p>
<h4>Предопределенные константы</h4>
<p>существуют константы, известные как волшебные, которые могут оказаться для вас полезными с самого начала. У имен волшебных констант в начале
    и в конце всегда стоят два символа подчеркивания, чтобы нельзя было случайно
    назвать одну из собственных констант уже занятым под эти константы именем</p>
<table>
    <tr>
        <td>волшебная
            константа</td>
        <td>описание</td>
    </tr>
    <tr>
        <td>__line__</td>
        <td>номер текущей строки вфайле</td>
    </tr>
    <tr>
        <td>__file__</td>
        <td>полное путевое имя файла. если используется внутри инструкции include,
            товозвращается имя включенного файла. внекоторых операционных системах
            допускается использование псевдонимов для каталогов, которые называются
            символическими ссылками; в__file__ они всегда заменяются реальными
            каталогами</td>
    </tr>
    <tr>
        <td>__dir__ </td>
        <td>каталог файла. если используется внутри инструкции include, то возвращается каталог включенного файла. такой же результат дает применение функции
            dirname(__file__). вэтом имени каталога отсутствует замыкающий слеш,
            если только этот каталог не является корневым</td>
    </tr>
    <tr>
        <td>__function__ </td>
        <td>имя функции. возвращает имя функции, под которым она была объявлена
            (сучетом регистра символов). вphp 4 возвращаемое значение всегда составлено из символов нижнего регистра </td>
    </tr>
    <tr>
        <td>__class__</td>
        <td>имя класса. возвращает имя класса, под которым он был объявлен (с учетом
            регистра символов). вphp4 возвращаемое значение всегда составлено изсимволов нижнего регистра</td>
    </tr>
    <tr>
        <td>__method__</td>
        <td>имя метода класса. возвращает имя метода, под которым он был объявлен
            (сучетом регистра символов)</td>
    </tr>
    <tr>
        <td>__namespace__</td>
        <td>имя текущего пространства имен (с учетом регистра символов). эта константа
            определена во время компиляции </td>
    </tr>
</table>
<p>Эти константы полезны при отладке, когда нужно вставить строку кода, чтобы
    понять, до какого места дошло выполнение программы:
</p>
<pre><code class="language-php">echo "Это строка " . _LINE_ . " в файле " . _FILE_;</code></pre>
<p>Эта команда выведет в браузер текущую строку программы с указанием текущего
    файла, исполняемого в данный момент (включая путь к нему).</p>

<h3>echo и print</h3>
<p>В общем, команда echo обычно работает при выводе обычного текста быстрее
    print, поскольку она не устанавливает возвращаемое значение. С другой стороны, поскольку она не является функцией, ее, в отличие от print, нельзя использовать как часть более сложного выражения. В следующем примере для
    вывода информации о том, является значение переменной истинным (TRUE) или
    ложным (FALSE), используется функция print, но сделать то же самое с помощью команды echo не представляется возможным, поскольку она выведет на экран
    сообщение об ошибке синтаксического разбора — Parse error:</p>
<pre><code class="language-php">$b ? print "TRUE" : print "FALSE";</code></pre>
<h3>Функции</h3>
<p>Простое объявление функции</p>
<pre><code class="language-php">&lt;?php
 function longdate($timestamp)
 {
 return date("l F jS Y", $timestamp);
 }
?></code></pre>
<p>Эта функция возвращает дату в формате «день_недели месяц число год». Между
    стоящими после имени функции круглыми скобками может размещаться любое количество параметров, но для этой функции выбран прием только одного
    параметра. Весь код, который выполняется при последующем вызове функции,
    заключается в фигурные скобки. Обратите внимание, что в этом примере первой буквой в вызове функции даты является L в нижнем регистре, которую не
    следует путать с цифрой 1.</p>
<p>Чтобы с помощью этой функции вывести сегодняшнюю дату, нужно поместить
    в свой код следующий вызов:</p>
<pre><code class="language-php">echo longdate(time());</code></pre>
<h4>Область видимости переменной</h4>
<p>сли программа очень длинная, то с подбором подходящих имен переменных
    могут возникнуть трудности, но программируя на PHP, можно определить область видимости переменной. Иными словами, можно, к примеру, указать, что
    переменная $temp будет использоваться только внутри конкретной функции,
    чтобы забыть о том, что она после возврата из кода функции применяется гденибудь еще. Фактически именно такой в PHP является по умолчанию область
    видимости переменных.</p>
<p>В качестве альтернативы можно проинформировать PHP о том, что переменная
    имеет глобальную область видимости и доступ к ней может быть осуществлен
    из любого места программы.</p>
<h5>Локальные переменные</h5>
<p>Локальные переменные создаются внутри функции и к ним имеется доступ
    только из кода этой функции. Обычно это временные переменные, которые
    используются до выхода из функции для хранения частично обработанных
    результатов.</p>
<pre><code class="language-php">&lt;?php
 function longdate($timestamp)
 {
 $temp = date("l F jS Y", $timestamp);
 return "Дата: $temp";
 }
?></code></pre>
<p>Неудачная попытка получить доступ к переменной $temp
    в функции longdate()</p>
<pre><code class="language-php">&lt;?php
 $temp = "Дата: ";
 echo longdate(time());
 function longdate($timestamp)
 {
 return $temp . date("l F jS Y", $timestamp);
 }
?></code></pre>
<p>Но поскольку переменная $temp не была создана внутри функции longdate,
    а также не была передана ей в качестве параметра, функция longdate не может
    получить к ней доступ. Поэтому этот фрагмент кода выведет только дату без
    предшествующего ей текста. На самом деле в зависимости от параметров конфигурации PHP сначала может быть отображено сообщение об ошибке, предупреждающее об использовании неопределенной переменной (Notice: Undefined
    variable: temp), показывать которое пользователям не хотелось бы.</p>
<p>. Решить проблему можно путем переноса ссылки на переменную
    $temp в ее локальную область видимости</p>
<pre><code class="language-php">&lt;?php
 $temp = "Дата: ";
 echo $temp . longdate(time());
 function longdate($timestamp)
 {
 return date("l F jS Y", $timestamp);
 }
?></code></pre>
<h5>Глобальные переменные</h5>
<p>Бывают случаи, когда требуется переменная, имеющая глобальную область видимости, поскольку нужно, чтобы к ней имелся доступ из всего кода программы. </p>
<pre><code class="language-php">global $is_logged_in;
</code></pre>
<h5>Статические переменные</h5>
<p>Если функция
    вызывается многократно, то она начинает свою работу со свежей копией переменной и ее прежние установки не имеют никакого значения.
    Интересно, а что, если внутри функции есть такая локальная переменная,
    к которой не должно быть доступа из других частей программы, но значение оторой желательно сохранять до следующего вызова функции? Зачем? Возможно, потому, что нужен некий счетчик, чтобы следить за количеством вызовов функции. Решение, показанное в примере 3.17, заключается в объявлении
    статической переменной.
</p>
<pre><code class="language-php">&lt;?php
 function test()
 {
 static $count = 0;
 echo $count;
 $count++;
 }
?></code></pre>
<p>В этом примере в самой первой строке функции создается статическая переменная по имени $count, которой присваивается нулевое начальное значение.
    В следующей строке выводится значение переменной, а в последней строке это
    значение увеличивается на единицу.</p>
<pre><code class="language-php">&lt;?php
 static $int = 0; // Допустимо
 static $int = 1+2; // Верно (в PHP 5.6)
 static $int = sqrt(144); // Недопустимо
?></code></pre>
<h5>Суперглобальные переменные</h5>
<p> Смысл этого названия заключается в том, что они предоставляются средой окружения PHP
    и имеют глобальную область видимости внутри программы, то есть доступны
    абсолютно из любого ее места. В этих суперглобальных переменных содержится масса полезной информации
    о текущей работающей программе и ее окружении</p>
<table>
    <tr>
        <td>имя суперглобальной
            переменной</td>
        <td>ее содержимое</td>
    </tr>
    <tr>
        <td>$globals</td>
        <td>все переменные, которые на данный момент определены вглобальной области видимости сценария. имена переменных служат ключами массива</td>
    </tr>
    <tr>
        <td>$_server</td>
        <td>информация озаголовках, путях, местах расположения сценариев. элементы
            этого массива создаются веб-сервером, иэто не дает гарантии, что каждый
            веб-сервер будет предоставлять какую-то часть информации или ее всю</td>
    </tr>
    <tr>
        <td>$_get </td>
        <td>переменные, которые передаются текущему сценарию http-методом get
        </td>
    </tr>
    <tr>
        <td>$_post</td>
        <td>переменные, которые передаются текущему сценарию http-методом post
        </td>
    </tr>
    <tr>
        <td>$_files</td>
        <td>элементы, подгруженные ктекущему сценарию http-методом post</td>
    </tr>
    <tr>
        <td>$_cookie</td>
        <td>переменные, переданные текущему сценарию посредством http cookies</td>
    </tr>
    <tr>
        <td>$_session</td>
        <td>переменные сессии, доступные текущему сценарию</td>
    </tr>
    <tr>
        <td>$_request </td>
        <td>содержимое информации, переданной от браузера; по умолчанию $_get,
            $_post и$_cookie</td>
    </tr>
    <tr>
        <td>$_env </td>
        <td>переменные, полученные из окружения </td>
    </tr>
</table>

<p>Для иллюстрации порядка применения суперглобальных переменных приведен
    типовой пример. Среди многой другой интересной информации, предоставляемой суперглобальными переменными, есть и URL-адрес той страницы, с которой
    пользователь был перенаправлен на текущую веб-страницу. Эта информация
    может быть получена следующим образом:</p>
<pre><code class="language-php">$came_from = $_SERVER['HTTP_REFERRER'];</code></pre>
<p>Обратите внимание, что суперглобальные переменные часто используются
    злоумышленниками, пытающимися отыскать средства для атаки и вмешательства в работу вашего сайта. Они загружают в $_POST, $_GET или в другие
    суперглобальные переменные вредоносный код, например команды UNIX или MySQL, которые, если вы по незнанию к ним обратитесь, могут разрушить или
    отобразить незащищенные данные. Именно поэтому перед применением суперглобальных переменных их всегда
    следует подвергать предварительной обработке. Для этого можно воспользоваться PHP-функцией htmlentities. Она занимается преобразованием всех
    символов в элементы HTML. Например, символы «меньше» и «больше» (< и >)
    превращаются в строки &lt; и &gt;, то же самое делается для перевода в безопасное состояние всех кавычек, обратных слешей и т. д.</p>
<p>более подходящий способ доступа к $_SERVER (и другим суперглобальным переменным) выглядит следующим образом:</p>
<pre><code class="language-php">$came_from = htmlentities($ SERVER['HTTP REFERRER']);</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>


</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script>hljs.highlightAll();</script>
</html>
