<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
    <title>Гл. 2. Введение в PHP</title>

</head>


<body>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<div id="header"></div>
<!--TODO: ADD LEFT SLIDER-->
<h1>Гл. 2. Введение в PHP</h1>
<h2>Краткая история PHP</h2>
<p><abbr title="Rasmus Lerdorf">Расмус Лердорф</abbr> начал задумываться о создании PHP в 1994 году, но PHP, который используется сегодня, сильно отличается от исходной версии. Чтобы понять, как PHP пришел к его нынешнему виду, полезно знать историю эволюции языка. Эта история описана ниже (с комментариями и сообщениями самого Расмуса).</p>
<h2>????</h2>
<p><b>Основные черты PHP:</b></p>
<ul>
    <li>Комментарии: <span class="code">//однострочник</span> и <span class="code">/*многотрочник*/</span></li>
    <li>Команды PHP завершаются точкой с запятой <span class="code">;</span></li>
    <li>Перед именем всех переменных ставится <span class="code">$</span></li>
    <li>В PHP используются стандартные литералы.</li>
    <li>Отсчет индексов начинается с 0</li>
    <li>PHP чувствителен к регистру</li>
    <li>PHP - слабо типизированный язык, т.е. переменные не требуют объявления перед использованием и что PHP всегда преобразует переменные в тот тип, который требуется для их окружения на момент доступа к ним. </li>
    <li>В PHP будет игнорировать любые отступы, кроме простых разделений команд (как во всех языках).</li>
</ul>

<p><b>Серверные скрипты:</b> Язык PHP изначально разрабатывался для создания динамического веб-контента и до сих пор лучше других языков подходит для этой задачи. Для генерирования разметки HTML вам понадобится парсер PHP и веб-сервер для отправки закодированных файлов. PHP также отлично генерирует динамический контент через подключение к БД, документы XML, графику, файлы PDF и т. д.</p>
<p><b>Скрипты командной строки:</b> PHP может выполнять скрипты в режиме командной строки по аналогии с Perl, awk или командной оболочкой Unix. Скрипты командной строки могут использоваться для таких задач системного администрирования, как резервное копирование и разбор журналов, а также для разработки некоторых скриптов в стиле заданий CRON (невизуальных задач PHP).</p>
<p>PHP - это интерпретатор, а не компилятор. Компиляторы создают исполняемый код, который может выполняться без самого компилятора. Интерпретатор такого кода не создает, поэтому для выполнения программ, написанных на PHP, вам понадобится интерпретатор PHP — программа, которая будет выполнять ваши PHP-сценарии.</p>


<!--todo: write history of PHP-->
<h2>Размещение PHP-кода</h2>
<!--TODO: Дать нормальное имя-->
<p>Параметры конфигурации PHP обычно хранятся в файле с именем <span class="code">php.ini</span>. Настройки в этом файле управляют поведением разных функций PHP, таких, как поддержка сеансов и обработка форм.</p>
<p>По умолчанию в конце имен PHP-документов ставится расширение <span class="code">.php</span>. Когда веб-сервер встречает в запрашиваемом файле это расширение, он автоматически передает файл PHP-процессору. Веб-серверы имеют довольно широкий диапазон настроек, и некоторые веб-разработчики выбирают такой режим работы, при котором для разбора PHP-процессору принудительно передаются также файлы с расширениями HTM или HTML. Обычно это связано с тем, что разработчики хотят скрыть факт использования PHP.</p>
<p>Программа на PHP отвечает за возвращение файла в чистом виде, пригодном для отображения в браузере. В простейшем случае на выходе документа PHP будет получаться только код HTML. Чтобы убедиться в этом, можно взять любой HTML-документ и сохранить его в качестве PHP-документа (например, сохраняя файл <span class="code">index.html</span> под именем <span class="code">index.php</span>), и он будет отображаться точно так же, как исходный файл.</p>
<p>Небольшая PHP-программа Hello World может иметь вид, показанный в примере:</p>
<pre><code class="language-php">&lt;?php
 echo "Hello world";
?></code></pre>

<p>Существуют 2 распространенных способа размещения <span class="code">&lt;?php?> тэга:</span></p>
<ol>
    <li>Некоторые программисты предпочитают помещать в эти теги как можно меньшие фрагменты кода PHP и именно в тех местах, где нужно воспользоваться динамическими сценариями, а весь остальной документ составлять из стандартного кода HTML. (Такой код выполняется быстрее)</li>
    <li> Другие программисты открывают его в начале документа, а закрывают в самом конце и выводят любой код HTML путем непосредственного использования команды PHP. (увеличение скорости настолько мизерное, что оно не может оправдать дополнительные сложности многочисленных вставок PHP в отдельно взятый документ)</li>
</ol>
<p>Несмотря на то что при выборе <span class="code">&lt;?</span> неочевиден вызов PHP-парсера, это вполне приемлемый альтернативный синтаксис, который, как правило, также работает. Но я не советую его использовать, поскольку он несовместим c XML и в настоящее время его применение не приветствуется (это значит, что он больше не рекомендуется и его поддержка может быть удалена в будущих версиях).</p>
<p>Если в файле содержится только код PHP, то закрывающий тег <span class="code">?></span> можно опустить. Именно так и нужно делать, чтобы гарантировать отсутствие в файлах PHP лишнего пустого пространства (что имеет особую важность при написании объектно-ориентированного кода).</p>
<h2>Переменные</h2>
<p>Символ <span class="code">$</span> используется в разных языках программирования в различных целях. Например, в языке BASIC символ <span class="code">$</span> применялся в качестве завершения имен переменных, чтобы показать, что они относятся к строкам</p>

<p>А в PHP символ <span class="code">$</span> должен ставиться перед именами всех переменных. Это нужно для того, чтобы PHP-парсер работал быстрее, сразу же понимая, что имеет дело с переменной. К какому бы типу ни относились переменные — к числам, строкам или массивам, все они должны выглядеть так, как показано</p>
<pre><code class="language-php">&lt;?php
 $mycounter = 1;
 $mystring = "Hello";
 $myarray = array("One", "Two", "Three");
?></code></pre>
<h3>Правила присваивания имен переменных</h3>
<ul>
    <li>Имена после знака $ должны начинаться с буквы или с _</li>
    <li>Имена могут содержать [a-zA-Z0-9_]</li>
    <li>Имена не могут включать пробелы</li>
    <li>Имена переменных чувствительны к регистру символов</li>
</ul>

<p>Первая PHP-программа:</p>
<pre><code class="language-php">&lt;?php // test1.php
 $username = "Fred Smith";
 echo $username;
 echo "&lt;br>";
 $current_user = $username;
 echo $current_user;
?></code></pre>
<h2>Массивы</h2>
<pre><code class="language-php">&lt;?php
$team = array('Bill', 'Mary', 'Mike', 'Chris', 'Anne');
echo $team[3];/*Эта команда отображает имя Chris*/
/*Двумерный массив*/
$oxo = array(array('x', ' ', 'o'),
        array('o', 'o', 'x'),
        array('x', 'o', ' '));
echo $oxo[1][2]; // Эта команда отображает х
?></code></pre>

<h2>Операторы</h2>
<h3>Арифметические операции</h3>
<p>Отличия от других языков</p>
<table>
    <tbody>
    <tr>
        <td>Описание</td>
        <td>Пример</td>
    </tr>
    <tr>
        <td>Инкремент</td>
        <td><span class="code">++$j</span></td>
    </tr>
    <tr>
        <td>Декремент</td>
        <td><span class="code">--$j</span></td>
    </tr>
    <tr>
        <td>Возведение в степень</td>
        <td><span class="code">$j**3</span></td>
    </tr>
    </tbody>
</table>

<h3>Операторы присваивания</h3>
<p>Аналогичные другим языкам за исключением <span class="code">.=</span></p>

<h3>Операторы сравнения</h3>
<p>Аналогичные другим языкам за исключением <span class="code">&lt;></span> (второй вариант "не равно"), <span class="code">===</span> (тождественно) и <span class="code">!==</span> (не тождественно)</p>

<h3>Логические операторы</h3>
<pre><code class="language-php">if ($hour > 12 && $hour < 14) dolunch();</code></pre>
<p>Аналогично другим языкам, т.е. PHP имеет следующие логические операторы: <span class="code">and</span> (<span class="code">&&</span>), <span class="code">or</span> (<span class="code">||</span>), <span class="code">!</span>, <span class="code">xor</span> (исключающее ИЛИ).</p>
<h3>Конкатенация строк</h3>
<p>Самый простой способ объединения строк выглядит следующим образом:</p>
<pre><code class="language-php">echo "У вас " . $msgs . " сообщений.";</code></pre>
<p>Так же как с помощью оператора += можно добавить значение к числовой переменной, с помощью оператора .= можно добавить одну строку к другой:</p>
<pre><code class="language-php"><$bulletin .= $newsflash;</code></pre>
<h2>Строки</h2>
<p>если требуется включить в состав строки значение переменной, используется строка, заключенная в двойные кавычки:</p>
<pre><code class="language-php">echo "На этой неделе ваш профиль просмотрело $count человек ";</code></pre>
<p>Инструкция echo может выводить сразу несколько строк</p>
<pre><code class="language-php">&lt;?php
 $author = "Steve Ballmer";
 echo "Developers, Developers, developers, developers,
 developers,developers, developers, developers, developers!
 $author.";
?></code></pre>
<p>Многострочное присваивание</p>
<pre><code class="language-php">&lt;?php
 $author = "Bill Gates";
 $text = "Measuring programming progress by lines of code is like
 measuring aircraft building progress by weight.
 – $author.";
?></code></pre>
<p>Еще один вариант инструкции echo, использующей сразу
    несколько строк</p>
<pre><code class="language-php">&lt;?php
 $author = "Brian W. Kernighan";
 echo &lt;&lt;&lt;_END
 Debugging is twice as hard as writing the code in the first place.
 Therefore, if you write the code as cleverly as possible, you are,
 by definition, not smart enough to debug it.
 $author.
_END;
?></code></pre>
<p>Этот код предписывает PHP вывести все, что находится между двумя тегами
    <span class="code">_END</span>, как будто все это является строкой, заключенной в двойные кавычки (за
    исключением того, что изменять предназначение кавычек в heredoc не нужно). Это означает, что разработчику можно, например, написать целый раздел
    HTML-кода прямо в коде PHP, а затем заменить конкретные динамические
    части переменными PHP.</p>
<p>Присваивание переменной многострочного значения</p>
<pre><code class="language-php">&lt;?php
 $author = "Scott Adams";
 $out = &lt;&lt;&lt;_END
 Normal people believe that if it ain't broke, don't fix it.
 Engineers believe that if it ain't broke, it doesn't have enough
 features yet.
 – $author.
_END;
echo $out;
?></code></pre>
<h3>Типы переменных</h3>
<p>PHP автоматически преобразует типы.</p>
<p>Например, автоматическое преобразование числа в строку</p>
<pre><code class="language-php">&lt;?php
 $number = 12345 * 67890;
 echo substr($number, 3, 1);
?></code></pre>
<p>Когда присваивается значение, $number является числовой переменной. Но во
    второй строке кода вызов значения этой переменной помещен в PHP-функцию
    substr(), которая должна вернуть из переменной $number один символ, стоящий
    на четвертой позиции.  Для выполнения этой задачи PHP превращает $number в строку, состоящую из девяти символов, чтобы функция substr() могла получить к ней
    доступ и вернуть символ, в данном случае 1</p>
<p>Автоматическое преобразование строки в число:</p>
<pre><code class="language-php">&lt;?php
 $pi = "3.1415927";
 $radius = 5;
 echo $pi * ($radius * $radius);
?></code></pre>
<h4>Константы</h4>
<p>Константы, как и переменные, хранят информацию для последующего доступа,
    за исключением того, что они оправдывают свое название (постоянные). Иными
    словами, после определения констант их значения устанавливаются для всей
    остальной программы и не могут быть изменены. </p>
<p>К примеру, константа может использоваться для хранения местоположения
    корневого каталога вашего сервера (папки, содержащей основные файлы вашего
    сайта). Определить такую константу можно следующим образом:</p>
<pre><code class="language-php">define("ROOT_LOCATION", "/usr/local/www/");</code></pre>
Затем для чтения содержимого константы нужно просто сослаться на нее как
на обычную переменную (но не предваряя ее имя знаком доллара):
<pre><code class="language-php">$directory = ROOT_LOCATION;</code></pre>
<p>Теперь, как только понадобится запустить ваш PHP-код на другом сервере
    с другой конфигурацией папок, придется изменить только одну строку кода.</p>
<p>Важно помнить о двух основных особенностях констант: перед их именами
    не нужно ставить символ $ (в отличие от имен обычных переменных) и их
    можно определить только с помощью функции define().</p>
<p>По общепринятому соглашению считается правилом хорошего тона использовать в именах констант буквы только верхнего регистра, особенно если ваш код
    будет также читать кто-нибудь другой.</p>
<h4>Предопределенные константы</h4>
<p>существуют константы, известные как волшебные, которые могут оказаться для вас полезными с самого начала. У имен волшебных констант в начале
    и в конце всегда стоят два символа подчеркивания, чтобы нельзя было случайно
    назвать одну из собственных констант уже занятым под эти константы именем</p>
<table class="first_column_code">
    <tr>
        <td>Волшебная
            константа</td>
        <td>Описание</td>
    </tr>
    <tr>
        <td>__line__</td>
        <td>номер текущей строки вфайле</td>
    </tr>
    <tr>
        <td>__file__</td>
        <td>полное путевое имя файла. если используется внутри инструкции include,
            то возвращается имя включенного файла. внекоторых операционных системах
            допускается использование псевдонимов для каталогов, которые называются
            символическими ссылками; в__file__ они всегда заменяются реальными
            каталогами</td>
    </tr>
    <tr>
        <td>__dir__ </td>
        <td>каталог файла. если используется внутри инструкции include, то возвращается каталог включенного файла. такой же результат дает применение функции
            dirname(__file__). вэтом имени каталога отсутствует замыкающий слеш,
            если только этот каталог не является корневым</td>
    </tr>
    <tr>
        <td>__function__ </td>
        <td>имя функции. возвращает имя функции, под которым она была объявлена
            (сучетом регистра символов). вphp 4 возвращаемое значение всегда составлено из символов нижнего регистра </td>
    </tr>
    <tr>
        <td>__class__</td>
        <td>имя класса. возвращает имя класса, под которым он был объявлен (с учетом
            регистра символов). вphp4 возвращаемое значение всегда составлено изсимволов нижнего регистра</td>
    </tr>
    <tr>
        <td>__method__</td>
        <td>имя метода класса. возвращает имя метода, под которым он был объявлен
            (сучетом регистра символов)</td>
    </tr>
    <tr>
        <td>__namespace__</td>
        <td>имя текущего пространства имен (с учетом регистра символов). эта константа
            определена во время компиляции </td>
    </tr>
</table>
<p>Эти константы полезны при отладке, когда нужно вставить строку кода, чтобы
    понять, до какого места дошло выполнение программы:
</p>
<pre><code class="language-php">echo "Это строка " . _LINE_ . " в файле " . _FILE_;</code></pre>
<p>Эта команда выведет в браузер текущую строку программы с указанием текущего
    файла, исполняемого в данный момент (включая путь к нему).</p>

<h3>echo и print</h3>
<p>В общем, команда echo обычно работает при выводе обычного текста быстрее
    print, поскольку она не устанавливает возвращаемое значение. С другой стороны, поскольку она не является функцией, ее, в отличие от print, нельзя использовать как часть более сложного выражения. В следующем примере для
    вывода информации о том, является значение переменной истинным (TRUE) или
    ложным (FALSE), используется функция print, но сделать то же самое с помощью команды echo не представляется возможным, поскольку она выведет на экран
    сообщение об ошибке синтаксического разбора — Parse error:</p>
<pre><code class="language-php">$b ? print "TRUE" : print "FALSE";</code></pre>
<h3>Функции</h3>
<p>Простое объявление функции</p>
<pre><code class="language-php">&lt;?php
 function longdate($timestamp)
 {
 return date("l F jS Y", $timestamp);
 }
?></code></pre>
<p>Эта функция возвращает дату в формате «день_недели месяц число год». Между
    стоящими после имени функции круглыми скобками может размещаться любое количество параметров, но для этой функции выбран прием только одного
    параметра. Весь код, который выполняется при последующем вызове функции,
    заключается в фигурные скобки. Обратите внимание, что в этом примере первой буквой в вызове функции даты является L в нижнем регистре, которую не
    следует путать с цифрой 1.</p>
<p>Чтобы с помощью этой функции вывести сегодняшнюю дату, нужно поместить
    в свой код следующий вызов:</p>
<pre><code class="language-php">echo longdate(time());</code></pre>
<h4>Область видимости переменной</h4>
<p>сли программа очень длинная, то с подбором подходящих имен переменных
    могут возникнуть трудности, но программируя на PHP, можно определить область видимости переменной. Иными словами, можно, к примеру, указать, что
    переменная $temp будет использоваться только внутри конкретной функции,
    чтобы забыть о том, что она после возврата из кода функции применяется гденибудь еще. Фактически именно такой в PHP является по умолчанию область
    видимости переменных.</p>
<p>В качестве альтернативы можно проинформировать PHP о том, что переменная
    имеет глобальную область видимости и доступ к ней может быть осуществлен
    из любого места программы.</p>
<h5>Локальные переменные</h5>
<p>Локальные переменные создаются внутри функции и к ним имеется доступ
    только из кода этой функции. Обычно это временные переменные, которые
    используются до выхода из функции для хранения частично обработанных
    результатов.</p>
<pre><code class="language-php">&lt;?php
 function longdate($timestamp)
 {
 $temp = date("l F jS Y", $timestamp);
 return "Дата: $temp";
 }
?></code></pre>
<p>Неудачная попытка получить доступ к переменной $temp
    в функции longdate()</p>
<pre><code class="language-php">&lt;?php
 $temp = "Дата: ";
 echo longdate(time());
 function longdate($timestamp)
 {
 return $temp . date("l F jS Y", $timestamp);
 }
?></code></pre>
<p>Но поскольку переменная $temp не была создана внутри функции longdate,
    а также не была передана ей в качестве параметра, функция longdate не может
    получить к ней доступ. Поэтому этот фрагмент кода выведет только дату без
    предшествующего ей текста. На самом деле в зависимости от параметров конфигурации PHP сначала может быть отображено сообщение об ошибке, предупреждающее об использовании неопределенной переменной (Notice: Undefined
    variable: temp), показывать которое пользователям не хотелось бы.</p>
<p>. Решить проблему можно путем переноса ссылки на переменную
    $temp в ее локальную область видимости</p>
<pre><code class="language-php">&lt;?php
 $temp = "Дата: ";
 echo $temp . longdate(time());
 function longdate($timestamp)
 {
 return date("l F jS Y", $timestamp);
 }
?></code></pre>
<h5>Глобальные переменные</h5>
<p>Бывают случаи, когда требуется переменная, имеющая глобальную область видимости, поскольку нужно, чтобы к ней имелся доступ из всего кода программы. </p>
<pre><code class="language-php">global $is_logged_in;
</code></pre>
<h5>Статические переменные</h5>
<p>Если функция
    вызывается многократно, то она начинает свою работу со свежей копией переменной и ее прежние установки не имеют никакого значения.
    Интересно, а что, если внутри функции есть такая локальная переменная,
    к которой не должно быть доступа из других частей программы, но значение оторой желательно сохранять до следующего вызова функции? Зачем? Возможно, потому, что нужен некий счетчик, чтобы следить за количеством вызовов функции. Решение, показанное в примере 3.17, заключается в объявлении
    статической переменной.
</p>
<pre><code class="language-php">&lt;?php
 function test()
 {
 static $count = 0;
 echo $count;
 $count++;
 }
?></code></pre>
<p>В этом примере в самой первой строке функции создается статическая переменная по имени $count, которой присваивается нулевое начальное значение.
    В следующей строке выводится значение переменной, а в последней строке это
    значение увеличивается на единицу.</p>
<pre><code class="language-php">&lt;?php
 static $int = 0; // Допустимо
 static $int = 1+2; // Верно (в PHP 5.6)
 static $int = sqrt(144); // Недопустимо
?></code></pre>
<h5>Суперглобальные переменные</h5>
<p> Смысл этого названия заключается в том, что они предоставляются средой окружения PHP
    и имеют глобальную область видимости внутри программы, то есть доступны
    абсолютно из любого ее места. В этих суперглобальных переменных содержится масса полезной информации
    о текущей работающей программе и ее окружении</p>
<table class="first_column_code">
    <tr>
        <td>Имя суперглобальной
            переменной</td>
        <td>Ее содержимое</td>
    </tr>
    <tr>
        <td>$globals</td>
        <td>все переменные, которые на данный момент определены в глобальной области видимости сценария. Имена переменных служат ключами массива</td>
    </tr>
    <tr>
        <td>$_server</td>
        <td>информация озаголовках, путях, местах расположения сценариев. элементы
            этого массива создаются веб-сервером, иэто не дает гарантии, что каждый
            веб-сервер будет предоставлять какую-то часть информации или ее всю</td>
    </tr>
    <tr>
        <td>$_get </td>
        <td>переменные, которые передаются текущему сценарию http-методом get
        </td>
    </tr>
    <tr>
        <td>$_post</td>
        <td>переменные, которые передаются текущему сценарию http-методом post
        </td>
    </tr>
    <tr>
        <td>$_files</td>
        <td>элементы, подгруженные ктекущему сценарию http-методом post</td>
    </tr>
    <tr>
        <td>$_cookie</td>
        <td>переменные, переданные текущему сценарию посредством http cookies</td>
    </tr>
    <tr>
        <td>$_session</td>
        <td>переменные сессии, доступные текущему сценарию</td>
    </tr>
    <tr>
        <td>$_request </td>
        <td>содержимое информации, переданной от браузера; по умолчанию <span class="code">$_get</span>,
            <span class="code">$_post</span> и <span class="code">$_cookie</span></td>
    </tr>
    <tr>
        <td>$_env </td>
        <td>переменные, полученные из окружения </td>
    </tr>
</table>

<p>Для иллюстрации порядка применения суперглобальных переменных приведен
    типовой пример. Среди многой другой интересной информации, предоставляемой суперглобальными переменными, есть и URL-адрес той страницы, с которой
    пользователь был перенаправлен на текущую веб-страницу. Эта информация
    может быть получена следующим образом:</p>
<pre><code class="language-php">$came_from = $_SERVER['HTTP_REFERRER'];</code></pre>
<p>Обратите внимание, что суперглобальные переменные часто используются
    злоумышленниками, пытающимися отыскать средства для атаки и вмешательства в работу вашего сайта. Они загружают в $_POST, $_GET или в другие
    суперглобальные переменные вредоносный код, например команды UNIX или MySQL, которые, если вы по незнанию к ним обратитесь, могут разрушить или
    отобразить незащищенные данные. Именно поэтому перед применением суперглобальных переменных их всегда
    следует подвергать предварительной обработке. Для этого можно воспользоваться PHP-функцией htmlentities. Она занимается преобразованием всех
    символов в элементы HTML. Например, символы «меньше» и «больше» (< и >)
    превращаются в строки &lt; и &gt;, то же самое делается для перевода в безопасное состояние всех кавычек, обратных слешей и т. д.</p>
<p>более подходящий способ доступа к $_SERVER (и другим суперглобальным переменным) выглядит следующим образом:</p>
<pre><code class="language-php">$came_from = htmlentities($ SERVER['HTTP REFERRER']);</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

</body>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script>hljs.highlightAll();</script>
</html>
