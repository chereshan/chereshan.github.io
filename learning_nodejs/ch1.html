<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Глава 1. Введение в NodeJS</title>

    <style>
        @import url("../styles/styles.css");
        @import url("../modules/vs2015.min.css");
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../modules/jquery-3.7.1.min.js"><'+'/script>')</script>
    <script src="../modules/highlight.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script src="../common/counters_head.js"></script>


</head>


<body>
<script src="../common/counters_body.js"></script>

<h1>Глава 1. Введение в NodeJS</h1>
<h2>Введение</h2>
Node.js — асинхронная управляемая событиями исполнительная платформа
JavaScript с мощной, но компактной стандартной библиотекой. Ее сопровождением
и поддержкой занимается Node.js Foundation — отраслевой консорциум с открытой моделью управления. Существует две активно поддерживаемые версии Node:
текущая (C urrent) и пользующаяся долгосрочной поддержкой (LTS, Long Term
Support).
<p>Среда Node — это JavaScript с привязками к лежащей в основе операционной системе (ОС), что делает возможным написание программ на JavaScript, которые выполняют чтение и запись файлов, запускают дочерние процессы и взаимодействуют через сеть. В результате среда Node пригодна в качестве:</p>
<ul>
    <li>современной альтернативы сценариям командной оболочки, которая не обладает загадочным синтаксисом bash и других оболочек Unix;</li>
    <li>универсального языка программирования для выполнения доверенных программ, не подверженного ограничениям безопасности, которые веб-браузеры налагают на ненадежный код;</li>
    <li>популярной среды для написания эффективных веб-серверов с высокой степенью параллелизма</li>
</ul>
<p>Определяющей характеристикой среды Node является ее однопоточный основанный на событиях параллелизм, обеспечиваемый по умолчанию асинхронным API-интерфейсом.</p>
<p>Помимо исполняемого файла <span class="code">Node</span> установка Node также включает <span class="code">npm</span> — диспетчер пакетов, который обеспечивает легкий доступ к обширной экосистеме инструментов и библиотек JavaScript. В примерах настоящей главы будут применяться только встроенные пакеты Node, a npm или любые внешние библиотеки не потребуются.</p>

<h2>Типичное веб-приложение Node</h2>
<p>Одна из сильных сторон Node и JavaScript вообще — однопоточная модель программирования. Программные потоки (<span class="code">threads</span>) являются стандартным источником ошибок, и хотя некоторые из недавно появившихся языков программирования, включая Go и Rust, пытаются предоставить безопасные инструменты параллельного программирования, Node работает с моделью, используемой в браузере.</p>
<p>Браузерный код представляет собой последовательность команд, которые выполняются одна за одной; код не выполняется параллельно.</p>
<p>Для пользовательских интерфейсов такая модель не имеет смысла: пользователь не хочет дожидаться завершения медленных операций (например, обращений к данным по сети или к файлам). Для решения этой проблемы в браузерах используются события: когда пользователь щелкает на кнопке, инициируется событие, и выполняется функция, которая была определена ранее, но еще не выполнялась. Тем самым предотвращаются некоторые проблемы, встречающиеся в многопоточном программировании, включая взаимные блокировки (<b>deadlocks</b>) ресурсов и состояния гонки (<b>race conditions</b>).</p>

<h3>Неблокирующий ввод/вывод</h3>
<p>Что это означает в контексте программирования <i>на стороне сервера</i>? Ситуация аналогична: запросы ввода/вывода (например, обращения к диску или сетевым
ресурсам) также выполняются относительно медленно, поэтому исполнительная среда не должна блокировать выполнение бизнес-логики во время чтения файлов
или передачи сообщений по сети. </p>
Для этого в Node используются три концепции:<p>
</p><ol>
    <li>события</li>
    <li>асинхронные API</li>
    <li>неблокирующий ввод/вывод</li>
</ol>
<p><b>Неблокирующий ввод/вывод</b> — низкоуровневый термин с точки зрения программиста Node. Он означает,
что программа может обратиться с запросом к сетевому ресурсу и заняться чем-то другим. А потом, когда сетевая операция будет завершена, выполняется функция
обратного вызова, которая обработает результат.</p>
<p>На <a href="#async_nonblocking_components">рис. ниже</a> изображено типичное веб-приложение Node, использующее библиотеку веб-программирования Express для обработки заказов в магазине. В нем:</p>
<ol>
    <li>Браузеры выдают запросы на приобретение продукта;</li>
    <li>приложение проверяет текущее состояние складских запасов</li>
    <li>создает учетную запись для пользователя</li>
    <li>отправляет квитанцию
        по электронной почте</li>
    <li>возвращает H T T P-ответ в формате JSON</li>
    <b>Одновременно с этим:</b>
    <li>квитанция отправляется по электронной почте</li>
    <li>база данных обновляется информацией от пользователя и данными заказа</li>
</ol>
<p>По сути, перед нами прямолинейный императивный код JavaScript, но исполнительная среда работает параллельно, потому что она использует неблокирующий ввод/вывод.</p>
<img id="async_nonblocking_components" src="images/async_nonblocking_components.png" alt="async nonblocking components">
<p>На <a href="#async_nonblocking_components">рис. выше</a> приложение обращается к базе данных по сети. В Node сетевые операции выполняются без блокировки, потому что Node при помощи библиотеки <span class="code">libuv</span> использует неблокирующие сетевые вызовы операционной системы. Эта функциональность по-разному реализована для Linux, macOS и Windows, но вам придется иметь дело только с удобной библиотекой JavaScript для работы с базами данных. Хотя вы пишете команды типа <span class="code">db.insert(query, err => {})</span>, Node во внутренней реализации выполняет оптимизированные неблокирующие сетевые операции.</p>
<p>Обращения к диску происходят примерно так же, но, как ни странно, полного совпадения нет. Когда приложение генерирует квитанцию, отправляемую по электронной почте, и шаблон сообщения читается с диска, <span class="code">libuv</span> использует пул потоков для создания иллюзии использования неблокирующего вызова. Управление пулом потоков — довольно тяжелое дело, но понять команду <span class="code">email.send('template.ejs', (err, html) => {})</span> определенно намного проще.</p>
<p>Истинное преимущество использования асинхронных API с неблокирующими
операциями ввода/вывода заключается в том, что Node может заниматься другими делами во время выполнения относительно медленных процессов. И хотя выполняться может только однопоточное и однопроцессное веб-приложение Node,
в любой момент времени оно может обрабатывать сразу несколько подключений
от тысяч потенциальных посетителей сайта. Чтобы понять, как это происходит,
необходимо познакомиться с циклом событий.</p>



<h2>Основы программирования в Node</h2>
<h3>Вывод на консоль</h3>
<p>Если вы привыкли к программированию на JavaScript для веб-браузеров, тогда одним из небольших сюрпризов, касающихся Node, будет то, что функция
<span class="code">console.log()</span> предназначена не только для отладки. Она является простейшим способом отображения сообщения пользователю в Node или в более общем плане отправки вывода в поток stdout. Вот как выглядит классическая
программа <span class="code">“Hello World”</span> в Node:</p>
<pre><code >console.log("Hello World!");</code></pre>

<p>В веб-браузерах <span class="code">console.log()</span>, <span class="code">console.warn()</span> и <span class="code">console.error()</span>, как правило, отображают маленькие значки рядом со своим выводом в консоли инструментов разработчика, чтобы обозначать различные журнальные
сообщения.</p>

<h3>Аргументы командной строки и переменные среды</h3>
<p>Если вы ранее писали программы в стиле Unix, предназначенные для вызова из окна терминала или другого интерфейса командной строки, то вам известно, что такие программы обычно получают свой ввод в первую очередь из аргументов командной строки и во вторую очередь из переменных среды.</p>
Среда Node следует таким соглашениям Unix. Программа Node может читать свои аргументы командной строки из массива строк <span class="code">process.argv</span>. Первый элемент этого массива всегда будет путем к исполняемому файлу Node. Второй аргумент — путь к файлу кода JavaScript, который Node выполняет. Оставшиеся элементы в массиве <span class="code">process.argv</span> являются аргументами, отделенными друг от друга пробелами, которые вы передали в командной строке, когда вызывали Node. Например, пусть вы сохранили приведенную ниже очень короткую программу Node в файле <span class="code">argv.js</span>:
<pre><code>console.log(process.argv);</code></pre>
<p><b>Вывод:</b></p>
<pre><code >$ node --trace-uncaught argv.js --arg1 --arg2 filename
[
    '/usr/local/bin/node',
    '/private/tmp/argv.js',
    '--arg1',
    '--arg2',
    'filename'
]</code></pre>
<p>Здесь необходимо отметить два момента:</p>
<ul>
    <li>Первый и второй элементы <span class="code">process.argv</span> будут полными путями в файловой системе к исполняемому файлу Node и запущенному файлу кода JavaScript, даже если вы не вводили их в таком виде.</li>
    <li>Аргументы командной строки, которые предназначены для Node и интерпретируются им, потребляются самим исполняемым файлом Node и не присутствуют в <span class="code">process.argv</span>. (Аргумент командной строки <span class="code">--trace-uncaught</span> в предыдущем примере фактически не делает ничего полезного; он нужен лишь для того, чтобы продемонстрировать его отсутствие в выводе.) Любые аргументы (наподобие <span class="code">--arg1</span> и <span class="code">filename</span>) следующие после имени файла кода JavaScript, будут появляться в <span class="code">process.argv</span>.</li>
</ul>
<p>Программы Node могут также принимать ввод от переменных среды в стиле
Unix. Среда Node делает их доступными через объект <span class="code">process.env</span>. Именами свойств этого объекта будут имена переменных среды, а значениями (всегда строковыми) свойств — значения переменных среды.</p>
<p>Вот неполный список переменных среды в некоторой системе:</p>
<pre><code >$ node -р -е 'process.env'
{
    SHELL: '/bin/bash',
    USER: 'david',
    PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin',
    PWD: '/tmp',
    LANG: 'en_US.UTF-8',
    HOME: '/Users/david',
}</code></pre>
Вы можете использовать <span class="code">node -h</span> или <span class="code">node -help</span>, чтобы выяснить, для чего предназначены аргументы командной строки <span class="code">-р</span> и <span class="code">-е</span>. Однако имейте в виду, что вы могли бы переписать предыдущую строку следующим образом: <span class="code">node --eval 'process.env' --print</span>.

<h3>Жизненный цикл программы</h3>







</body>
</html>