<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="../scripts/body_scripts.js"></script>
    <script>$(function(){$("#header").load("../common/header.html");});</script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WD3PT3ZV');</script>
    <!-- End Google Tag Manager -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript">
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();
            for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
            k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(95750180, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script> <noscript></noscript>
  </head>
  <body>
    <div><img src="https://mc.yandex.ru/watch/95750180" style="position:absolute; left:-9999px;"

        alt=""></div>
    <!-- /Yandex.Metrika counter -->
    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-N43FPXHDPN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-N43FPXHDPN');
    </script>
    <title>Глава 3. Что такое Kotlin?</title>
    <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WD3PT3ZV"

style="display:none;visibility:hidden" height="0" width="0"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="header"></div>
    <!--TODO: ADD LEFT SLIDER-->
    <h1>Глава 3. Что такое Kotlin?</h1>
    <h2>История Kotlin</h2>
    <p>Kotlin был создан компанией JetBrains из Санкт-Петербурга. Kotlin был
      разработан для совместимости с Java, хоя он поддерживает и другие
      платформы (iOS, WebAssembly, Kotlin/JS и т.д.). Ключ к обширному
      использованию Kotlin - это поддержка им виртуальной машины Java (JVM).
      Поскольку код на Kotlin можно компилировать в байт-код Java, он может
      работать везде, где работает JVM. Однако не стоит думать, что Kotlin - это
      диалект Java, с такими языками как Scala, Swift и C# он связан почти также
      сильно как и с Java. </p>
    <h2>Введение в Kotlin</h2>
    <pre><code class="language-kotlin">data class Person (val name: String,//класс данных
                           val age: Int? = null ) //тип, допускающий значение null; значение параметра по умолчанию
fun main(args: Array&lt;string&gt;){ //функция верхнего уровня
  val persons = listOf(Person("Alice"),
                                Person("Bob", age = 29)) //именованый аргумент
  val oldest = persons.maxBy {it.age ?: 0} //лямбда-выражение; оператор "Элвис"
  println("The oldest is: $oldest") //строка шаблон
          }
//The oldest is: Person(name=Bob, age=29) //часть вывода автоматически сгенерирована методом toString</code></pre>
    <p></p>
    <h2></h2>
    <p>Здесь мы определяем класс Person с
        двумя свойствами name и age. Свойство age по умолчанию имеет значение
        null. Мы создаем список из экземпляров класса Person, а затем находим
        самого старого применив к этому списку метод maxByC с аргументом
        лямбда-функцией (принимает 1 параметр с именем it и возвращает 0, если
        возраст имеет значение null). Т.к. возраст Алисы не указан, то то
        оператор заменит его 0, поэтому самым старым окажется Bob.</p>

    <h3>Основные черты языка Kotlin</h3>
    <p>Основная цель языка Kotlin – предложить более компактную, производительную и безопасную альтернативу языку Java, пригодную для использования везде, где сегодня применяется Java</p>
    <ul>
        Наиболее типичные области применения Kotlin:
        <li>Разработка кода стороны сервера (как правило, серверной части веб-приложений)</li>
        <li>Создание Andrpoid-приложений</li>
    </ul>
    <p>Помимо Java, код на Kotlin можно скомпилировать в код на JavaScript и выполнять его в браузере.</p>
    <h4>Статическая типизация</h4>
    <p>Kotlin – <b>статически типизированный язык программирования</b>. Это означает, что тип каждого выражения в программе известен во время компиляции, и компилятор может проверить, что методы и поля, к которым вы обращаетесь, действительно существуют в используемых объектах</p>
    <p>Этим Kotlin отличается от <b>динамически типизированных</b>языков программирования на платформе JVM (Groovy и JRuby). Такие языки позволяют определять переменные и функции, способные хранить или возвращать данные любого типа, а ссылки на поля и методы определяются во время выполнения. Это позволяет писать более компактный код и дает большую гибкость в создании структур данных.
    <p>Но в языках с динамической типизацией есть свои недостатки: например, опечатки в именах нельзя обнаружить во время компиляции, что влечет появление ошибок во время выполнения.</p>
    <p><b>НО!</b> Kotlin не требует явно указывать тип каждой переменной, и в большинстве случаев тип может быть определен автоматически.</p>
    <pre><code class="language-kotlin">val x = 1</code></pre>
    <p>Мы объявляем переменную, но т.к. она инициализируется целочисленным значением, то будет автоматически определен тип <span class="code">Int</span>. Это явление называется <b>type inference</b>.</p>
    <ul>
        Некоторые преимущества статической типизации:
        <li><b>Производительность</b> – вызов методов происходит быстрее, поскольку во время выполнения не нужно выяснять, какой метод должен быть вызван.</li>
        <li><b>Надежность</b> – корректность программы проверяется компилятором,
            поэтому вероятность ошибок во время выполнения меньше.</li>
        <li><b>Удобство сопровождения</b> – работать с незнакомым кодом проще, потому что сразу видно, с какими объектами код работает.</li>
        <li><b>Поддержка инструментов</b> – статическая типизация позволяет увереннее выполнять рефакторинг, обеспечивает точное автодополнение кода и поддержку других возможностей IDE.</li>
    </ul>
    <p>Важным нововведением Kotlin является поддержка типов, допускающих null (nullable types), что позволяет писать более надежные программы за счет выявления потенциальных ошибок обращения к пустому указателю на этапе компиляции.</p>
    <p>Другим нововведением является поддержка функциональных типов (function types)</p>

    <h3>Функциональное программирование</h3>
    <ol>
        Основные понятия функционального программирования:
        <li><b>Функции как полноценные объекты</b> – с функциями (элементами поведения) можно работать как со значениями. Их можно хранить в переменных, передавать в аргументах или возвращать из других функций.</li>
        <li><b>Неизменяемость</b> – программные объекты никогда не изменяются,
            что гарантирует неизменность их состояния после создания.</li>
        <li><b>Отсутствие побочных эффектов</b> – функции всегда возвращают один
            и тот же результат для тех же аргументов, не изменяют состояние
            других объектов и не взаимодействуют с окружающим миром.</li>
    </ol>
    <p>Теперь, допустим, что у нас 2 схожих фрагмента, решающих одну и ту же проблему, которые отличаются в деталях. Мы легко сможем перенести общую логику в функцию, передавая отличающиеся части в виде аргументов. Эти аргументы сами будут функциями, но вы сможете описать их, используя лаконичный синтаксис анонимных функций, называемых лямбда-выражениями:</p>
<pre><code class="language-kotlin">fun findAlice() = findPerson { it.name == "Alice" } //Функция findPerson() описывает общую логику поиска
fun findBob() = findPerson { it.name == "Bob" } //Блок кода в фигурных скобках задает свойства искомого элемента</code></pre>











    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <script>hljs.highlightAll();</script>
    <!--Автооглавление главы-->
    <script src="../scripts/body_scripts.js"></script>
  </body>
</html>
